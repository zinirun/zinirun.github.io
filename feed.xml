<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zinirun</title>
  
  <subtitle>tech blog by Zini</subtitle>
  <link href="https://zinirun.github.io/feed.xml" rel="self"/>
  
  <link href="https://zinirun.github.io/"/>
  <updated>2020-09-05T07:55:03.056Z</updated>
  <id>https://zinirun.github.io/</id>
  
  <author>
    <name>zini</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQLD 38회 후기 (국가공인 SQL 개발자 자격증)</title>
    <link href="https://zinirun.github.io/2020/09/05/sqld-38-review/"/>
    <id>https://zinirun.github.io/2020/09/05/sqld-38-review/</id>
    <published>2020-09-05T07:07:22.000Z</published>
    <updated>2020-09-05T07:55:03.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL-개발자-자격시험"><a href="#SQL-개발자-자격시험" class="headerlink" title="SQL 개발자 자격시험"></a>SQL 개발자 자격시험</h2><p>한국데이터산업진흥원에서 주관하는 국가공인 SQL 개발자 시험이다. 1년에 4번 실시되고, 커트라인은 100점 만점에 60점인데, 크게 파트 2개로 나뉜다.</p><ul><li>데이터 모델링의 이해 (10문항)</li><li>SQL 기본 및 활용 (40문항 - 주관식 8문항 포함)</li></ul><p>각 파트마다 40%을 넘겨야 합격 처리된다. 생각보다 10문항짜리 첫 파트에서 실수가 많아지면 안되기에 마냥 쉽다고는 할 수 없다.</p><p>나는 일주일에 1시간 정도를 할애해서 전반적으로 개념을 짚었고, 시험 직전 이틀을 5시간 정도를 문제 풀이와 개념 외우기에 집중했다. 그래서 순공시간은 17시간? 정도 될 것 같다. 기존 프로젝트를 하면서 SQL Query 사용은 많이 해봤고 데이터베이스 기초 전공 과목을 수강했기에 공부가 크게 어렵지는 않았다.</p><h2 id="38회-후기"><a href="#38회-후기" class="headerlink" title="38회 후기"></a>38회 후기</h2><p>오늘 본 SQLD는 38회인데, 학교가 경기도에 위치해 있어서 강변 근처에 밥도 먹으러 갈 김에 서울 성수중학교에서 시험을 봤다. 코로나의 여파 때문인지 좌석간의 거리도 넓고 날씨도 많이 풀려서 전반적으로 쾌적했다.</p><h3 id="인쇄-오류"><a href="#인쇄-오류" class="headerlink" title="인쇄 오류"></a>인쇄 오류</h3><p>이번 시험에는 큰 인쇄 오류가 있었다. 고사장의 절반 가까이 되는 시험지가 마지막 주관식 2문제(7, 8번)가 제대로 인쇄되어 있지 않아 엄청난 혼동을 일으켰는데, 결국 주관식 7번과 8번은 풀이하지 말라는 공지가 방송되었다. (배점은 어떻게 바뀔지 모르겠다. 4점을 그냥 줄지 없는 문제로 칠지는 나중에 알 것 같다.)</p><h3 id="파트별-후기"><a href="#파트별-후기" class="headerlink" title="파트별 후기"></a>파트별 후기</h3><p>문제를 풀기 시작하고 생각보다 첫번째 파트 <code>데이터 모델링의 이해</code>가 까다로웠다. 기본적인 개념을 묻는 퍼주기식 문제는 거의 없었고 엔터티간의 상관관계를 그림으로 주고 묻는 문제가 생각보다 많이 나왔다. 사실 그 부분을 완벽하게 공부하지 않아서 거의 감으로 풀었다. 엔터티를 분류하는 속성이 <code>키 속성</code>인지 <code>기본키 속성</code>인지 너무 헷갈렸고, <code>기본키 속성</code>으로 찍었다가 결국 틀린 것을 알게 되었다.</p><p>두번째 파트인 <code>SQL 기본 및 활용</code>은 SQL문을 주고 결과를 쓰거나, 결과를 주고 SQL문을 찾는 문제가 과반수였고, 간단해서 눈으로 바로 풀 수 있는 문제 절반, 생각을 좀 해야하는 문제 절반이었다. 퍼주는 개념 문제도 5개 정도는 있었던 것 같다. 문제와 보기에 말장난이 정말 많아서 잘 봐야한다.</p><h3 id="전반적인-느낌"><a href="#전반적인-느낌" class="headerlink" title="전반적인 느낌"></a>전반적인 느낌</h3><p>시험 시간은 10시부터 11시 30분이었는데 40분 정도에 모두 풀고, 붙잡고 있어봤자 답이 안나오는 걸 알아서 성수중학교 1등으로 나왔다. 50문제에 1시간 30분을 주므로 시간은 충분하다 못해 넘치는 것 같다. 하지만 비전공자가 보기엔 당연히 어려운 시험이고, 도전하기 위해서는 꽤 많은 노력이 필요할 것 같다.</p><p>보통 책을 사서 공부할텐데, 정말 책에 오타가 너무 많고 문제와 답이 다른 경우도 있고 개념 설명도 너무 부실해서 빨리 경쟁 업체에서 다른 책을 출시해야 할 것 같다. 거의 독점하다시피 책을 내는데 왜 이 모양으로 책을 내는지 모르겠다. 요즘 책에 오탈자를 찾으면 상품권을 주는데 아마 이 책에서 오탈자나 잘못된 정보로 상품권을 줬다면 냉장고 한 대는 뽑았을 것 같다.</p><p>그렇다고 전공자가 인강을 보는 일은 없었으면 좋겠다. 100점을 맞는다고 좋은 것도 아니고 60점만 넘기면 되므로 좀 짜증나는 책을 가지고도 60점 정도는 넘길 수 있다고 생각한다. SQLP는 모르겠는데, SQLD는 절대 인강까지 볼 만큼 까다로운 시험이 아니다.</p><blockquote><p>38회 시험의 결과는 10월 6일에 나온다. 이 글을 보신 분들 중 오늘 시험을 치르신 분들이 있다면 꼭 합격하시길 빕니다!</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SQL-개발자-자격시험&quot;&gt;&lt;a href=&quot;#SQL-개발자-자격시험&quot; class=&quot;headerlink&quot; title=&quot;SQL 개발자 자격시험&quot;&gt;&lt;/a&gt;SQL 개발자 자격시험&lt;/h2&gt;&lt;p&gt;한국데이터산업진흥원에서 주관하는 국가공인 SQL 개발자</summary>
      
    
    
    
    <category term="Etc" scheme="https://zinirun.github.io/categories/Etc/"/>
    
    
    <category term="sqld" scheme="https://zinirun.github.io/tags/sqld/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 30 - Day 18 Adding Up Times with Reduce</title>
    <link href="https://zinirun.github.io/2020/09/03/js-course30-18/"/>
    <id>https://zinirun.github.io/2020/09/03/js-course30-18/</id>
    <published>2020-09-02T15:19:16.000Z</published>
    <updated>2020-09-02T17:00:15.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-18-Adding-Up-Times-with-Reduce"><a href="#Day-18-Adding-Up-Times-with-Reduce" class="headerlink" title="Day 18 - Adding Up Times with Reduce"></a>Day 18 - Adding Up Times with Reduce</h2><div class="video-container"><iframe src="https://www.youtube.com/embed/SadWPo2KZWg" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>이번 과제는 map, reduce에 대한 방법만 알고 있다면 간단하게 해결할 수 있다.</p><h2 id="Full-Script"><a href="#Full-Script" class="headerlink" title="Full Script"></a>Full Script</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timeNodes = [...document.querySelectorAll(<span class="string">&quot;[data-time]&quot;</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> seconds = timeNodes</span><br><span class="line">  .map(<span class="function">(<span class="params">node</span>) =&gt;</span> node.dataset.time)</span><br><span class="line">  .map(<span class="function">(<span class="params">timeCode</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [mins, secs] = timeCode.split(<span class="string">&quot;:&quot;</span>).map(<span class="built_in">parseFloat</span>);</span><br><span class="line">    <span class="keyword">return</span> mins * <span class="number">60</span> + secs;</span><br><span class="line">  &#125;)</span><br><span class="line">  .reduce(<span class="function">(<span class="params">total, eachSeconds</span>) =&gt;</span> total + eachSeconds);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> secondsLeft = seconds;</span><br><span class="line"><span class="keyword">const</span> hours = <span class="built_in">Math</span>.floor(secondsLeft / <span class="number">3600</span>);</span><br><span class="line">secondsLeft %= <span class="number">3600</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mins = <span class="built_in">Math</span>.floor(secondsLeft / <span class="number">60</span>);</span><br><span class="line">secondsLeft %= <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hours, mins, secondsLeft);</span><br></pre></td></tr></table></figure><p><code>querySelectorAll</code>로 가져온 데이터는 Node List의 형태이므로 spread 문법을 이용하여 풀어서 배열화시켜 저장한다. <code>Array.from()</code>을 사용해도 상관없다.</p><p>우선 시간에 대한 데이터는 각각 <code>&lt;li data-time=&quot;4:04&quot;&gt;Video 58&lt;/li&gt;</code> 형식의 태그 안에 dataset으로 들어있는데, 이를 <code>map</code>으로 시간을 추출하기 위해 먼저 매핑한다.</p><p>그 후 시간의 형식이 <code>mm:ss</code> 형식이므로 <code>:</code>를 기준으로 <code>split()</code>을 사용하여 나눈 후 <code>parseFloat</code>을 이용하여 실수형 형변환을 시킨다.</p><p>그 값을 <code>reduce</code>를 사용하여 더해주면 되는데, 첫번째 인자인 <code>total</code>은 총 누적 값이고, 두번째 인자인 <code>eachSeconds</code>는 누적 값이다.</p><p>두번의 매핑 후 한번의 리듀스를 거치면 결국 초 단위로 바꾼 총 누적 값이 되고, 이 값을 시간, 분, 초로 잘라서 콘솔에 출력하면 된다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day-18-Adding-Up-Times-with-Reduce&quot;&gt;&lt;a href=&quot;#Day-18-Adding-Up-Times-with-Reduce&quot; class=&quot;headerlink&quot; title=&quot;Day 18 - Adding Up Times</summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="javascript30" scheme="https://zinirun.github.io/tags/javascript30/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search - 정렬된 배열에서 수의 개수 구하기 (이분탐색)</title>
    <link href="https://zinirun.github.io/2020/09/02/ps-binarysearch-get-count-of-sorted-array/"/>
    <id>https://zinirun.github.io/2020/09/02/ps-binarysearch-get-count-of-sorted-array/</id>
    <published>2020-09-01T16:22:37.000Z</published>
    <updated>2020-09-01T16:35:36.519Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>정렬된 숫자의 배열에서 특정 수의 개수를 구한다.<br>시간복잡도가 <code>O(logN)</code> 이하여야 시간초과 판정을 받지 않는다.<br>수가 배열에 존재하지 않는 경우 <code>-1</code>을 출력한다.</p><p>입력<br><code>n</code>: 배열의 길이(1~1000000), <code>x</code>: 찾을 수</p></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line">n,x=map(int,input().split())</span><br><span class="line">num = sorted(list(map(int, input().split())))</span><br><span class="line">count=bisect.bisect_right(num,x)-bisect.bisect_left(num,x)</span><br><span class="line"><span class="keyword">if</span> count&lt;<span class="number">0</span>: print(<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">else</span>: print(count)</span><br></pre></td></tr></table></figure><p>특정 수의 개수는 <code>count()</code> 메소드로 찾을 수 있지만, 정렬된 배열의 조건, 배열의 길이를 봐서 일반적인 loop로 완전탐색으로 돌다가는 당연히 시간초과가 날 것을 알고 <strong>이분 탐색</strong>이라는 포인트를 잡을 수 있어야 한다.</p><p><code>bisect</code> 라이브러리에서 <code>bisect_right()</code> 메소드와 <code>bisect_left()</code> 메소드를 사용하면 첫번째 인자의 배열에 두번째 요소를 집어넣을 때 각각 오른쪽에서 넣을 경우, 왼쪽에서 넣을 경우에서 몇 번째 인덱스에 넣어야 하는지를 반환한다.</p><p>예를 들어, 배열이 <code>1 1 2 2 2 2 3</code>으로 구성되었다고 가정해보자.<br>2의 개수를 찾는 경우 2를 오른쪽부터 넣을 때의 인덱스는 6이고, 왼쪽부터 넣을 때의 인덱스는 2이다. 이 두 값을 빼면 바로 개수가 된다. 2가 없을 경우 두 값이 모두 같을 것이고, 자연스레 count는 0이 된다.</p><blockquote><p>이분탐색 방식으로 코드를 직접 구현해도 되지만 외부 라이브러리 제한조건이 없는 경우 번거로운 수고를 덜수도 있다. 하지만 라이브러리는 기초를 알고 쓰자.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;정렬된 숫자의 배열에서 특정 수의 개수를 구한다.&lt;br&gt;시간복잡도가 &lt;code&gt;O(logN)&lt;/code&gt; 이하여야 시간초과 판정을 받지 않는다.&lt;br&gt;수가 배열에 존재하지 않는 경우 &lt;code&gt;-1&lt;/code&gt;을 출력한다.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Javascript 30 - Day 17 Sort Without Articles</title>
    <link href="https://zinirun.github.io/2020/09/01/js-course30-17/"/>
    <id>https://zinirun.github.io/2020/09/01/js-course30-17/</id>
    <published>2020-09-01T06:51:24.000Z</published>
    <updated>2020-09-01T07:13:04.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-17-Sort-Without-Articles"><a href="#Day-17-Sort-Without-Articles" class="headerlink" title="Day 17 - Sort Without Articles"></a>Day 17 - Sort Without Articles</h2><div class="video-container"><iframe src="https://www.youtube.com/embed/PEEo-2mRQ7A" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>이번 과제는 문자열로 구성된 배열을 정렬하는 과제이다. 문제는 그냥 정렬이 아니라 앞에 관사를 제외하고 정렬하여 <code>&lt;li&gt;</code> 객체를 넣어주어야 한다.</p><h2 id="strip-함수-만들기"><a href="#strip-함수-만들기" class="headerlink" title="strip() 함수 만들기"></a>strip() 함수 만들기</h2><p><code>strip()</code> 메소드는 자바스크립트에서 지원하는 기능이 아니다. 직접 정의하는 이 함수는 regex를 사용하여 관사 <code>a</code> <code>an</code> <code>the</code>를 제거하고, 문자열에 사용할 수 있는 기본 메소드인 <code>trim()</code>을 사용하여 앞, 뒤 공백을 제거한 후 반환한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strip</span>(<span class="params">band</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//regex - ^:starts with, i:insensitive(full matched)</span></span><br><span class="line">  <span class="keyword">return</span> band.replace(<span class="regexp">/^(a |the |an )/i</span>, <span class="string">&quot;&quot;</span>).trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 이 함수로 <code>bands</code> 배열을 정렬한 새로운 <code>sortedBands</code> 배열을 만들 것이다.</p><h2 id="sort-사용하기"><a href="#sort-사용하기" class="headerlink" title="sort() 사용하기"></a>sort() 사용하기</h2><p>기본 내장된 <code>sort()</code> 메소드를 사용한다. 위에서 작성한 <code>strip()</code> 메소드에 정렬할 인자를 각각 넣어서 정렬한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortedBands = bands.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (strip(a) &gt; strip(b) ? <span class="number">1</span> : <span class="number">-1</span>));</span><br></pre></td></tr></table></figure><h2 id="map-join-사용하기"><a href="#map-join-사용하기" class="headerlink" title="map, join 사용하기"></a>map, join 사용하기</h2><p>이제 적절한 위치에 정렬한 <code>sortedBand</code> 요소를 각각 <code>&lt;li&gt;</code> 객체로 매핑하여 <code>innerHTML</code>에 넣어주면 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bandsList.innerHTML = sortedBands.map(<span class="function">(<span class="params">band</span>) =&gt;</span> <span class="string">`&lt;li&gt;<span class="subst">$&#123;band&#125;</span>&lt;/li&gt;`</span>).join(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>join(&#39;&#39;)</code>을 마지막에 사용하지 않으면 <code>,</code>가 들어간 이상한 리스트가 출력될 것이다. <code>innerHTML</code>에 태그들을 매핑하여 넣을 때는 외우다싶이 마지막에 <code>join()</code> 메소드를 사용하자.</p><h2 id="Full-Script"><a href="#Full-Script" class="headerlink" title="Full Script"></a>Full Script</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bands = [</span><br><span class="line">  <span class="string">&quot;The Plot in You&quot;</span>,</span><br><span class="line">  <span class="string">&quot;The Devil Wears Prada&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Pierce the Veil&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Norma Jean&quot;</span>,</span><br><span class="line">  <span class="string">&quot;The Bled&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Say Anything&quot;</span>,</span><br><span class="line">  <span class="string">&quot;The Midway State&quot;</span>,</span><br><span class="line">  <span class="string">&quot;We Came as Romans&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Counterparts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Oh, Sleeper&quot;</span>,</span><br><span class="line">  <span class="string">&quot;A Skylit Drive&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Anywhere But Here&quot;</span>,</span><br><span class="line">  <span class="string">&quot;An Old Dog&quot;</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bandsList = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#bands&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strip</span>(<span class="params">band</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//regex - ^:starts with, i:insensitive(full matched)</span></span><br><span class="line">  <span class="keyword">return</span> band.replace(<span class="regexp">/^(a |the |an )/i</span>, <span class="string">&quot;&quot;</span>).trim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sortedBands = bands.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (strip(a) &gt; strip(b) ? <span class="number">1</span> : <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">bandsList.innerHTML = sortedBands.map(<span class="function">(<span class="params">band</span>) =&gt;</span> <span class="string">`&lt;li&gt;<span class="subst">$&#123;band&#125;</span>&lt;/li&gt;`</span>).join(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>regex 사용은 여전히 어려운 것 같다. 외우려고 하기 보다는 필요할 때 찾아서 쓰고, 기본적인 틀 정도만 상기시켜야겠다. 이제 13개밖에 남지 않았다!</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day-17-Sort-Without-Articles&quot;&gt;&lt;a href=&quot;#Day-17-Sort-Without-Articles&quot; class=&quot;headerlink&quot; title=&quot;Day 17 - Sort Without Articles&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="javascript30" scheme="https://zinirun.github.io/tags/javascript30/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 제대로 쓰기 - Code This, NOT That!</title>
    <link href="https://zinirun.github.io/2020/09/01/js-way-to-better-code/"/>
    <id>https://zinirun.github.io/2020/09/01/js-way-to-better-code/</id>
    <published>2020-09-01T05:23:20.000Z</published>
    <updated>2020-09-01T06:15:04.403Z</updated>
    
    <content type="html"><![CDATA[<div class="video-container"><iframe src="https://www.youtube.com/embed/Mus_vwhTCq0" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>본 글은 유튜브를 보다가 우연히 찾은 Javascript Pro Tips - Code This, NOT That 영상인데, 자바스크립트 ES6에서 지향하는 클린 코드를 잘 정리해주셔서 리마인드할 겸 다시 정리한다.</p><h2 id="console-log-console-table"><a href="#console-log-console-table" class="headerlink" title="console.log, console.table"></a>console.log, console.table</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123; <span class="attr">name</span>: <span class="string">&quot;tom&quot;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">nervous</span>: <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> bar = &#123; <span class="attr">name</span>: <span class="string">&quot;dick&quot;</span>, <span class="attr">age</span>: <span class="number">40</span>, <span class="attr">nervous</span>: <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> baz = &#123; <span class="attr">name</span>: <span class="string">&quot;harry&quot;</span>, <span class="attr">age</span>: <span class="number">50</span>, <span class="attr">nervous</span>: <span class="literal">true</span> &#125;;</span><br></pre></td></tr></table></figure><p>위의 3가지 객체들을 콘솔에 나타낼 때 <code>console.log(foo); console.log(bar) ...</code>처럼 작성하면 쓸데없는 코드가 늘어나게 되고, 한 눈에 봐도 비효율적으로 보인다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123; foo, bar, baz &#125;);</span><br></pre></td></tr></table></figure><p>이렇게 한번에 나타낼 수 있다. <code>&#123;&#125;</code> 표현은 정말 많이 쓰인다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.table([foo, bar, baz]);</span><br></pre></td></tr></table></figure><p><code>console.table</code>에 배열 객체로 넘겨주면 정리된 표 형식으로 볼 수도 있다.</p><h2 id="console-time"><a href="#console-time" class="headerlink" title="console.time"></a>console.time</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">&quot;looper&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">1000000</span>) &#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&quot;looper&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>console.time</code>부터 <code>console.timeEnd</code>까지의 시간을 측정하여 출력해준다. 함수의 인자로 들어가는 이름이 일치해야 그룹으로 묶인다.</p><h2 id="console-trace"><a href="#console-trace" class="headerlink" title="console.trace"></a>console.trace</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deleteMe = <span class="function">() =&gt;</span> <span class="built_in">console</span>.trace(<span class="string">&quot;bye bye database&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>console.trace</code>를 사용하면 함수가 호출될 때의 stack trace를 확인할 수 있다.</p><h2 id="destructuring"><a href="#destructuring" class="headerlink" title="destructuring"></a>destructuring</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> turtle = &#123;</span><br><span class="line">  name: <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">  legs: <span class="number">4</span>,</span><br><span class="line">  shell: <span class="literal">true</span>,</span><br><span class="line">  type: <span class="string">&quot;amphibious&quot;</span>,</span><br><span class="line">  meal: <span class="number">10</span>,</span><br><span class="line">  diet: <span class="string">&quot;berries&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이 turtle 객체를 함수의 인자로 넘겨서 객체 안의 값에 접근해보자. <code>feed</code>라는 함수를 예로 들면,</p><p><code>잘못된 코드</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">feed</span>(<span class="params">animal</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Feed <span class="subst">$&#123;animal.name&#125;</span> <span class="subst">$&#123;animal.meal&#125;</span> kilos of <span class="subst">$&#123;animal.diet&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이는 명백히 비효율적이고 잘못된 코드이다. 클린 코딩의 방법은 2가지인데,</p><p><code>올바른 코드</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">feed</span>(<span class="params">&#123; name, meal, diet &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Feed <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;meal&#125;</span> kilos of <span class="subst">$&#123;diet&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위처럼 인자 자체를 객체를 풀어주는 방법이 있고,</p><p><code>올바른 코드</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">feed</span>(<span class="params">animal</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, meal, diet &#125; = animal;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Feed <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;meal&#125;</span> kilos of <span class="subst">$&#123;diet&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위처럼 함수 내에서 별도로 객체를 풀어주는 방법이 있다.</p><h2 id="Template-Literals"><a href="#Template-Literals" class="headerlink" title="Template Literals"></a>Template Literals</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> horse = &#123;</span><br><span class="line">  name: <span class="string">&quot;Topher&quot;</span>,</span><br><span class="line">  size: <span class="string">&quot;large&quot;</span>,</span><br><span class="line">  skills: [<span class="string">&quot;jousting&quot;</span>, <span class="string">&quot;racing&quot;</span>],</span><br><span class="line">  age: <span class="number">7</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>위 객체의 값을 활용해서 새로운 값을 선언해보자.</p><p><code>잘못된 코드</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bio =</span><br><span class="line">  horse.name +</span><br><span class="line">  <span class="string">&quot; is a &quot;</span> +</span><br><span class="line">  horse.size +</span><br><span class="line">  <span class="string">&quot; horse skilled in &quot;</span> +</span><br><span class="line">  horse.skills.join(<span class="string">&quot; &amp; &quot;</span>);</span><br></pre></td></tr></table></figure><p>backticks을 이용하면 위처럼 <code>+</code>를 사용하여 하나하나 붙여줄 필요가 없다.</p><p><code>올바른 코드</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name, size, skills &#125; = horse;</span><br><span class="line"><span class="keyword">let</span> bio = <span class="string">`<span class="subst">$&#123;name&#125;</span> is a <span class="subst">$&#123;size&#125;</span> skilled in <span class="subst">$&#123;skills.join(<span class="string">&quot; &amp; &quot;</span>)&#125;</span>`</span>;</span><br></pre></td></tr></table></figure><p>위에서 언급한 destructuring으로 horse 객체를 풀어주고 backticks를 사용하면 정말 간단하고 가독성도 좋게 변수를 선언할 수 있다.</p><h2 id="Spread-Syntax"><a href="#Spread-Syntax" class="headerlink" title="Spread Syntax"></a>Spread Syntax</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pikachu = &#123; <span class="attr">name</span>: <span class="string">&quot;Pikachu&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> stats = &#123; <span class="attr">hp</span>: <span class="number">40</span>, <span class="attr">attack</span>: <span class="number">60</span>, <span class="attr">defense</span>: <span class="number">45</span> &#125;;</span><br></pre></td></tr></table></figure><p>위의 두 객체를 하나로 합치고 싶다면 어떻게 해야할까.</p><p><code>잘못된 코드</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pikachu[<span class="string">&quot;hp&quot;</span>] = stats.hp;</span><br><span class="line">pikachu[<span class="string">&quot;attack&quot;</span>] = stats.attack;</span><br><span class="line">pikachu[<span class="string">&quot;defense&quot;</span>] = stats.defense;</span><br></pre></td></tr></table></figure><p>위처럼 하나하나 할당하거나, <code>push</code>를 사용해서 하나하나 넣어준다면 stat 객체에 100가지 요소가 들어있다면 말도 안되는 코드가 되어버릴 것이다.</p><p><code>올바른 코드</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lvl0 = &#123; ...pikachu, ...stats &#125;;</span><br></pre></td></tr></table></figure><p>Spread 방식을 사용하면 위처럼 간단하게 합친 새로운 객체를 만들어낼 수 있다.</p><h2 id="loops"><a href="#loops" class="headerlink" title="loops"></a>loops</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> orders = [<span class="number">500</span>, <span class="number">30</span>, <span class="number">99</span>, <span class="number">15</span>, <span class="number">133</span>];</span><br></pre></td></tr></table></figure><p><code>orders</code> 배열을 loop 방식으로 계산해야 할때</p><p><code>잘못된 코드</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> withTax = [];</span><br><span class="line"><span class="keyword">const</span> highValue = [];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; orders.length; i++) &#123;</span><br><span class="line">  <span class="comment">//reduce</span></span><br><span class="line">  total += orders[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//map</span></span><br><span class="line">  withTax.push(orders[i] * <span class="number">1.1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//filter</span></span><br><span class="line">  <span class="keyword">if</span> (orders[i] &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    highValue.push(orders[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>전통적인 <code>for loop</code> 방식으로 코드를 작성하는 방법도 있지만, 자바스크립트에서는 기본적으로 reduce, map, filter 메소드를 지원한다.</p><p><code>올바른 코드</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> total = orders.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur);</span><br><span class="line"><span class="keyword">const</span> withTax = orders.map(<span class="function">(<span class="params">v</span>) =&gt;</span> v * <span class="number">1.1</span>);</span><br><span class="line"><span class="keyword">const</span> highValue = orders.filter(<span class="function">(<span class="params">v</span>) =&gt;</span> v &gt; <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h2 id="async-await"><a href="#async-await" class="headerlink" title="async / await"></a>async / await</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> random = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="built_in">Math</span>.random());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>랜덤 숫자를 콜백 형식으로 지정된 순서로 생성하여 더하는 함수를 만들 때</p><p><code>잘못된 코드</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sumRandomAsyncNums = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> first;</span><br><span class="line">  <span class="keyword">let</span> second;</span><br><span class="line">  <span class="keyword">let</span> third;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> random()</span><br><span class="line">    .then(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">      first = v;</span><br><span class="line">      <span class="keyword">return</span> random();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">      second = v;</span><br><span class="line">      <span class="keyword">return</span> random();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">      third = v;</span><br><span class="line">      <span class="keyword">return</span> first + second + third;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>.then</code>을 체인처럼 엮어서 작성하는 경우가 많다.</p><p><code>올바른 코드</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sumRandomAsyncNums = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> first = <span class="keyword">await</span> random();</span><br><span class="line">  <span class="keyword">const</span> second = <span class="keyword">await</span> random();</span><br><span class="line">  <span class="keyword">const</span> third = <span class="keyword">await</span> random();</span><br><span class="line">  <span class="keyword">return</span> first + second + third;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>async</code>와 <code>await</code>을 적절히 활용하면 순서를 보장하는 코드를 간단하게 작성할 수 있다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>ES6 문법으로 정말 혁신적으로 코드의 길이를 줄이고 효율적인 코드를 작성하는 방법이 많다. 영상에 있는 내용도 일부에 불과하다. 나도 <code>push</code>를 사용해서 값을 집어넣거나 <code>.then</code>을 칭칭 엮어서 코드를 짠 기억이 있다. 지금부터라도 ES6 문법에 맞게 클린 코딩을 지향해야겠다.</p><blockquote><p>ES6 문법에 관한 <a href="https://github.com/lukehoban/es6features">총 정리</a>를 해놓은 고마운 분이 계시니 차근차근 읽어보면 좋을 것 같다.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/Mus_vwhTCq0&quot; frameborder=&quot;0&quot; loading=&quot;lazy&quot; allowfullscreen&gt;&lt;/iframe</summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
  <entry>
    <title>Netlify Custom Domain 설정하기 (with Namecheap)</title>
    <link href="https://zinirun.github.io/2020/08/31/netlify-custom-domain/"/>
    <id>https://zinirun.github.io/2020/08/31/netlify-custom-domain/</id>
    <published>2020-08-31T06:48:27.000Z</published>
    <updated>2020-08-31T07:07:27.911Z</updated>
    
    <content type="html"><![CDATA[<p>어제 내 프로필 사이트를 하나 만들었다. Github Pages를 사용해서 배포했는데 아무리 봐도 주소 <code>zinirun.github.io/zini-profile</code>은 너무나도 길었고 <code>zinirun.github.io</code>는 현재 블로그의 레파지토리로 쓰고 있어서 프로젝트 페이지를 커스텀 도메인으로 설정할 수 있나 찾아봤는데 내가 못 찾는건지, 방법이 없었다.</p><p>그래서 네트리파이로 배포하고 커스텀 도메인을 설정했다.</p><h3 id="Netlify-설정"><a href="#Netlify-설정" class="headerlink" title="Netlify 설정"></a>Netlify 설정</h3><p><img src="/images/2020-08-31-15-52-11.png"></p><p>네트리파이에 배포한 본인의 앱 설정에는 <strong>Domain management</strong>가 있다. 들어가면</p><p><img src="/images/2020-08-31-15-53-16.png"></p><p>이렇게 <strong>Custom Domains</strong>를 설정하는 영역이 있는데 소유한 주소를 입력한다.</p><h3 id="Domain-Nameserver-설정"><a href="#Domain-Nameserver-설정" class="headerlink" title="Domain Nameserver 설정"></a>Domain Nameserver 설정</h3><p>그러면 1단계를 넘어가고 2단계에서 Name Server를 등록하라고 한다. 나는 <a href="https://namecheap.com/">Namecheap</a> 주소를 대여받고 있어서 도메인 설정에 들어갔는데, 다른 주소 대여 서비스도 Custom DNS를 지원할 것이니 잘 찾아보면 Name Server 설정하는 영역이 있을 것이다.</p><p><img src="/images/2020-08-31-15-56-07.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dns1.p05.nsone.net</span><br><span class="line">dns2.p05.nsone.net</span><br><span class="line">dns3.p05.nsone.net</span><br><span class="line">dns4.p05.nsone.net</span><br></pre></td></tr></table></figure><p>이 4개를 모두 등록해주면 된다. 하지만 본인의 도메인에 DNS가 정상적으로 등록되려면 하루정도의 시간이 걸린다. DNS를 정상적으로 등록했다면 네트리파이에서 검증 단계를 모두 마친 후 커스텀 도메인을 사용할 수 있다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;어제 내 프로필 사이트를 하나 만들었다. Github Pages를 사용해서 배포했는데 아무리 봐도 주소 &lt;code&gt;zinirun.github.io/zini-profile&lt;/code&gt;은 너무나도 길었고 &lt;code&gt;zinirun.github.io&lt;/</summary>
      
    
    
    
    <category term="Etc" scheme="https://zinirun.github.io/categories/Etc/"/>
    
    
    <category term="netlify" scheme="https://zinirun.github.io/tags/netlify/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 30 - Day 16 Mouse Move Shadow</title>
    <link href="https://zinirun.github.io/2020/08/31/js-course30-16/"/>
    <id>https://zinirun.github.io/2020/08/31/js-course30-16/</id>
    <published>2020-08-31T05:37:43.000Z</published>
    <updated>2020-08-31T06:25:10.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-16-Mouse-Move-Shadow"><a href="#Day-16-Mouse-Move-Shadow" class="headerlink" title="Day 16 - Mouse Move Shadow"></a>Day 16 - Mouse Move Shadow</h2><div class="video-container"><iframe src="https://www.youtube.com/embed/zaz9gLI-Xac" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p class="codepen" data-height="265" data-theme-id="light" data-default-tab="html,result" data-user="zinirun" data-slug-hash="abNyzbQ" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Day16-MouseMove">  <span>See the Pen <a href="https://codepen.io/zinirun/pen/abNyzbQ">  Day16-MouseMove</a> by Jeon Jin Heo (<a href="https://codepen.io/zinirun">@zinirun</a>)  on <a href="https://codepen.io">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><p><code>mousemove</code> 이벤트에 <code>textshadow</code> css 속성을 조절하는 과제이다.<br>사실 <code>offsetX</code>, <code>offsetY</code> 등의 좌표값에 대한 계산 말고는 특별한 것은 없는 것 같고, 나는 크게 <code>contenteditable</code> 속성과 <code>&#123;&#125;</code> 선언법을 알았다.</p><h2 id="contenteditable-속성"><a href="#contenteditable-속성" class="headerlink" title="contenteditable 속성"></a>contenteditable 속성</h2><p>html 태그에 <code>contenteditable</code>을 속성을 <code>true</code>로 설정하면 <code>input</code> 태그처럼 수정할 수 있다. 원래는 <code>&lt;h1 contenteditable=&quot;true&quot;&gt;</code> 처럼 속성을 줘야 하지만 <code>true</code>는 명시하지 않고 속성명만 적어도 된다. <code>h</code> 태그처럼 텍스트 태그에만 한정되있는게 아니고 <code>div</code> 등에도 걸 수 있다.</p><p>당연히 새로고침하면 원래의 값으로 돌아가니 <a href="https://notion.so/">Notion</a>처럼 값을 지속적으로 유지하고 싶다면 Database를 쓰거나 LocalStorage를 쓰거나 해야한다.</p><h2 id="로-한꺼번에-선언하기"><a href="#로-한꺼번에-선언하기" class="headerlink" title="{}로 한꺼번에 선언하기"></a><code>&#123;&#125;</code>로 한꺼번에 선언하기</h2><p><code>hero</code> 객체에는 <code>offsetWidth</code>, <code>offsetHeight</code> 값이 있는데, 이를 <code>width</code>, <code>height</code>라는 변수로 선언하고 싶다면 일반적으로</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> width = hero.offsetWidth;</span><br><span class="line"><span class="keyword">const</span> height = hero.offsetHeight;</span><br></pre></td></tr></table></figure><p>이렇게 많이 할 것이다. ES6 문법을 사용하면</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">offsetWidth</span>: width, <span class="attr">offsetHeight</span>: height &#125; = hero;</span><br></pre></td></tr></table></figure><p>가독성과 코드 낭비를 한번에 해결할 수 있다.</p><h2 id="css-textshadow"><a href="#css-textshadow" class="headerlink" title="css - textshadow"></a>css - textshadow</h2><p>사실 css 속성은 필요할 때 검색해서 그대로 쓰거나 변형하면 되기에 정말 자주쓰는 속성이 아니면 깊게 들어가지는 않는 편이다.</p><p>아무튼 text-shadow 속성의 문법은</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-shadow: offset-x offset-y blur-radius color | none | initial | inherit</span><br></pre></td></tr></table></figure><p>이렇게 사용한다.</p><ul><li>offset-x: 그림자의 수평 거리</li><li>offset-y: 그림자의 수직 거리</li><li>blur-radius: 흐림 정도(기본 0)</li><li>color: 색상 (기본 브라우저 기본값)</li><li>none: 그림자 효과 없애기</li><li>initial: 기본값으로</li><li>inherit: 부모의 속성값 상속</li></ul><p>여기서 필수적인 항목은 <code>offset-x</code>와 <code>offset-y</code>이다. 절대 안 외워도 된다. 구글에는 CSS로 만들어진 갖가지 속성들이 엄청나게 많으니 마음에 드는 걸 가져다 쓰면 된다.</p><p>이제 이것들을 활용해서 원래의 과제인 <code>shadow</code> 함수를 작성하자.</p><h2 id="Full-Script"><a href="#Full-Script" class="headerlink" title="Full Script"></a>Full Script</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hero = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.hero&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> text = hero.querySelector(<span class="string">&quot;h1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> walk = <span class="number">100</span>; <span class="comment">//100px</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shadow</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// const width = hero.offsetWidth;</span></span><br><span class="line">  <span class="comment">// const height = hero.offsetHeight;</span></span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">offsetWidth</span>: width, <span class="attr">offsetHeight</span>: height &#125; = hero;</span><br><span class="line">  <span class="keyword">let</span> &#123; <span class="attr">offsetX</span>: x, <span class="attr">offsetY</span>: y &#125; = e;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span> !== e.target) &#123;</span><br><span class="line">    x = x + e.target.offsetLeft;</span><br><span class="line">    y = y + e.target.offsetTop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> xWalk = <span class="built_in">Math</span>.round((x / width) * walk - walk / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> yWalk = <span class="built_in">Math</span>.round((y / height) * walk - walk / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//use back ticks</span></span><br><span class="line">  text.style.textShadow = <span class="string">`</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;xWalk&#125;</span>px <span class="subst">$&#123;yWalk&#125;</span>px 0 rgba(255,0,255,0.7),</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;xWalk * <span class="number">-1</span>&#125;</span>px <span class="subst">$&#123;yWalk&#125;</span>px 0 rgba(0,255,255,0.7),</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;yWalk&#125;</span>px <span class="subst">$&#123;xWalk * <span class="number">-1</span>&#125;</span>px 0 rgba(0,255,0,0.7),</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;yWalk * <span class="number">-1</span>&#125;</span>px <span class="subst">$&#123;xWalk&#125;</span>px 0 rgba(0,0,255,0.7)</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">&#125;</span><br><span class="line">hero.addEventListener(<span class="string">&quot;mousemove&quot;</span>, shadow);</span><br></pre></td></tr></table></figure><p>shadow의 픽셀 값을 계산해서 back tick을 사용해서 넣어주는 것 말고는 지금까지 이벤트를 넣은 방법과 동일하다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day-16-Mouse-Move-Shadow&quot;&gt;&lt;a href=&quot;#Day-16-Mouse-Move-Shadow&quot; class=&quot;headerlink&quot; title=&quot;Day 16 - Mouse Move Shadow&quot;&gt;&lt;/a&gt;Day 16 - Mou</summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="javascript30" scheme="https://zinirun.github.io/tags/javascript30/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Binary Search (이진탐색)</title>
    <link href="https://zinirun.github.io/2020/08/30/ps-summary-binary-search/"/>
    <id>https://zinirun.github.io/2020/08/30/ps-summary-binary-search/</id>
    <published>2020-08-29T15:00:51.000Z</published>
    <updated>2020-08-29T15:56:54.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="천만개-일억개를-탐색해야-할-때"><a href="#천만개-일억개를-탐색해야-할-때" class="headerlink" title="천만개, 일억개를 탐색해야 할 때"></a>천만개, 일억개를 탐색해야 할 때</h2><p>천만개가 넘는 리스트에서 특정 값을 찾아야 할 때, 각자가 구현하는 코드는 다양할 것인데, 효율적인 탐색 방법 중 하나가 바로 <strong>이진탐색</strong>이다. 말로만 들으면 어려울 것 같지만 업-다운 게임을 생각하면 쉽다.</p><p>1~60개의 정수 중 하나 40을 맞추려고 할 때</p><ul><li>30? Up!</li><li>45? Down!</li><li>38(37.5를 반올림)? Up!</li><li>42(41.5를 반올림)? Down!</li><li>40? Yes!</li></ul><p>이렇게 절반으로 쪼개가며 큰 지, 작은 지를 판단하고 또 절반으로 나누고를 반복하다가 찾는 수가 나올 때 탐색을 종료하는 것이 이진탐색이다. <strong>중요한 것은 리스트들은 정렬된 상태여야 한다는 것이다.</strong> 큰 지, 작은 지를 판단하는데 리스트가 뒤죽박죽이라면 아무런 의미가 없다.</p><h2 id="구현하는-방법"><a href="#구현하는-방법" class="headerlink" title="구현하는 방법"></a>구현하는 방법</h2><p>이진탐색을 구현하는 방법은 일반적으로 2가지인데, 재귀 함수로 작성하는 방법과 반복문으로 작성하는 방법이 있다. 하지만 파이썬에서는 재귀함수의 최대 재귀 횟수가 정해져 있으므로 반복문을 이용한 이진탐색을 선호하는 편이다. (물론 최대 재귀 횟수를 조정할 수 있다)</p><h3 id="재귀를-이용한-방법"><a href="#재귀를-이용한-방법" class="headerlink" title="재귀를 이용한 방법"></a>재귀를 이용한 방법</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisearch</span>(<span class="params">array,target,start,end</span>):</span></span><br><span class="line">    <span class="keyword">if</span> start&gt;end: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    mid = (start+end)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> array[mid]==target: <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">elif</span> array[mid]&gt;target: <span class="keyword">return</span> bisearch(array,target,start,mid<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> bisearch(array,target,mid+<span class="number">1</span>,end)</span><br></pre></td></tr></table></figure><p>사실상 위에서 말한 업다운의 예시를 그대로 코드에 옮긴 것과 같다. <code>start</code>와 <code>end</code>를 더한 절반인 <code>mid</code>를 기준으로 큰 지, 작은 지, 일치하는 지를 판단하여 다시 기준을 잡고 함수를 재귀한다.</p><h3 id="반복문을-이용한-방법"><a href="#반복문을-이용한-방법" class="headerlink" title="반복문을 이용한 방법"></a>반복문을 이용한 방법</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisearch</span>(<span class="params">array,target,start,end</span>):</span></span><br><span class="line">    <span class="keyword">while</span> start&lt;=end:</span><br><span class="line">        mid=(start+end)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> array[mid]==target: <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> array[mid]&gt;target: end=mid<span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>: start=mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><code>while</code>문을 사용하여 이진탐색을 하는 방법인데, 로직은 당연히 재귀함수를 사용할 때와 같다.</p><p>이제 구현한 이진탐색 코드로 숫자를 탐색해보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n, target = list(map(int,input().split()))</span><br><span class="line">array = list(map(int, input().split()))</span><br><span class="line">result = bisearch(array,target,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">print(result <span class="keyword">if</span> result <span class="keyword">else</span> <span class="string">&#x27;원소가 존재하지 않음&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/2020-08-30-00-29-15.png"></p><p>이렇게 작성한 코드는 주어진 리스트 원소의 수 <code>n</code>, 찾는 대상 <code>target</code>, 정렬된 리스트 <code>array</code>로 이진 탐색을 시행한 후 대상이 있을 때만 결과를 반환한다.</p><p>예시에서는 숫자의 개수가 10개이기 때문에 그냥 for loop를 돌면서 순차 탐색을 하는 것이 때로는 빠를 수도 있다. 그러나 1부터 10000000까지의 숫자 리스트에서 9999999라는 숫자를 찾는다면 효율은 비교할 수 없이 이진탐색이 빠르다.</p><blockquote><p>순차탐색의 시간복잡도는 <code>O(N)</code>이고, 이진탐색의 시간복잡도는 <code>O(logN)</code>이다.</p></blockquote><h2 id="파이썬에서는-bisect가-있다"><a href="#파이썬에서는-bisect가-있다" class="headerlink" title="파이썬에서는 bisect가 있다"></a>파이썬에서는 bisect가 있다</h2><p>특정 라이브러리를 사용하지 말라는 조건이 없다면 파이썬에는 <code>bisect</code>라는 라이브러리가 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line">arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">print(bisect.bisect(arr, <span class="number">2</span>)) <span class="comment"># 결과: 1</span></span><br></pre></td></tr></table></figure><p>여기서 <code>bisect()</code> 메소드는 <code>bisect_right()</code>와 같은데, <code>2</code>라는 숫자를 넣을 때 인덱스가 몇이어야 하는지 반환한다. 이 방법을 이용하면 어느 자리에 넣을지, 이 숫자가 어디에 있는 지도 찾을 수 있다.</p><p><code>bisect</code> 라이브러리에 대한 자세한 설명은 <a href="https://lioliolio.github.io/python-bisect-module/">KIM TAEWOO님</a>의 블로그에 잘 설명되어 있다.</p><blockquote><p>라이브러리를 쓰는 것은 얼마든지 좋지만 적어도 어떻게 돌아가는 지는 알고 써야한다고 생각한다.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;천만개-일억개를-탐색해야-할-때&quot;&gt;&lt;a href=&quot;#천만개-일억개를-탐색해야-할-때&quot; class=&quot;headerlink&quot; title=&quot;천만개, 일억개를 탐색해야 할 때&quot;&gt;&lt;/a&gt;천만개, 일억개를 탐색해야 할 때&lt;/h2&gt;&lt;p&gt;천만개가 넘는 </summary>
      
    
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/tags/algorithm/"/>
    
    <category term="ps" scheme="https://zinirun.github.io/tags/ps/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 30 - Day 15 LocalStorage</title>
    <link href="https://zinirun.github.io/2020/08/29/js-course30-15/"/>
    <id>https://zinirun.github.io/2020/08/29/js-course30-15/</id>
    <published>2020-08-29T05:17:26.000Z</published>
    <updated>2020-08-29T05:46:46.049Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-15-LocalStorage-Contains-emphasized-items"><a href="#Day-15-LocalStorage-Contains-emphasized-items" class="headerlink" title="Day 15 - LocalStorage, Contains emphasized items"></a>Day 15 - LocalStorage, Contains emphasized items</h2><div class="video-container"><iframe src="https://www.youtube.com/embed/YL1F4dCUlLc" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p><img src="/images/2020-08-29-14-46-43.png"></p><p>오랜만에 영상을 먼저 보지 않고 혼자 구현할 수 있었던 과제였다. <code>localStorage</code>의 사용법만 안다면 (매우 간단하다) 리스트를 만들어 관리하는 것은 투두리스트를 많이 만들어봤기에 자신있었다.</p><h2 id="localStorage의-사용"><a href="#localStorage의-사용" class="headerlink" title="localStorage의 사용"></a>localStorage의 사용</h2><p>자바스크립트에서는 기본적으로 로컬 스토리지에, 즉 클라이언트의 로컬 컴퓨터에 어떠한 데이터를 저장, 삭제, 조회할 수 있는 메소드가 있다. 브라우저마다 다르지만, 보통 5MB 정도의 용량을 허용한다고 한다. (사실 5MB 정도면 텍스트 데이터정도를 저장하기에는 충분하다)</p><p>저장, 조회, 삭제에 대한 방법만 알면 충분하다.</p><ul><li>저장: <code>localStorage.setItem(&#39;&lt;item명&gt;&#39;, &lt;저장할 item&gt;)</code></li><li>데이터 조회: <code>localStorage.getItem(&#39;&lt;item명&gt;&#39;)</code></li><li>특정 카테고리 삭제: <code>localStorage.clear(&#39;&lt;item명&gt;&#39;)</code></li><li>로컬 스토리지 전체 삭제: <code>localStorage.clear()</code></li></ul><h2 id="아이템-새로고침-추가-토글-구현"><a href="#아이템-새로고침-추가-토글-구현" class="headerlink" title="아이템 새로고침, 추가, 토글 구현"></a>아이템 새로고침, 추가, 토글 구현</h2><p>로직은 매우 간단한데, <code>&lt;input&gt;</code>에서 추가할 텍스트 데이터를 <code>items</code>라는 배열에 넣고 로컬 스토리지에 저장 후 리스트에 텍스트 데이터를 하나씩 추가하면 된다. 여기서 중요한 것은, 로컬 스토리지에 저장하기 때문에 굳이 하나씩 넣을 필요도 없고, 배열 전체를 받아 <code>innerHTML</code>로 새로고침하는 함수를 하나 만들면 된다.<br>(데이터가 많아지면 비효율적이겠지만 간단한 메뉴 리스트이기에 무관하다)</p><h3 id="새로고침"><a href="#새로고침" class="headerlink" title="새로고침"></a>새로고침</h3><p>우선 배열을 받아 list를 새로고침하는 함수이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">populateList</span>(<span class="params">plates = [], platesList</span>) </span>&#123;</span><br><span class="line">  platesList.innerHTML = plates</span><br><span class="line">    .map(<span class="function">(<span class="params">plate, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;li&gt;</span></span><br><span class="line"><span class="string">          &lt;input type=&quot;checkbox&quot; data-index=<span class="subst">$&#123;i&#125;</span> id=&quot;item<span class="subst">$&#123;i&#125;</span>&quot; <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        plate.done ? <span class="string">&quot;checked&quot;</span> : <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">      &#125;</span> /&gt;</span></span><br><span class="line"><span class="string">          &lt;label for=&quot;item<span class="subst">$&#123;i&#125;</span>&quot;&gt;<span class="subst">$&#123;plate.text&#125;</span>&lt;/label&gt;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;</span></span><br><span class="line"><span class="string">      `</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각 요소를 <code>&lt;li&gt;</code> 태그의 요소로 바꿔 한개씩 <code>join(&#39;&#39;)</code> 시켜주면 리스트 전체를 원하는 <code>innerHTML</code>로 바꿔주는 함수이다.</p><p>이제 리스트를 추가하던, 체크박스를 토글하던 이 함수만 실행하면 새로고침된다.</p><h3 id="리스트-추가"><a href="#리스트-추가" class="headerlink" title="리스트 추가"></a>리스트 추가</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addItem</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="keyword">const</span> text = <span class="built_in">this</span>.querySelector(<span class="string">&#x27;[name=&quot;item&quot;]&#x27;</span>).value;</span><br><span class="line">  <span class="keyword">const</span> item = &#123;</span><br><span class="line">    text,</span><br><span class="line">    done: <span class="literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  items.push(item);</span><br><span class="line">  populateList(items, itemsList);</span><br><span class="line">  <span class="built_in">localStorage</span>.setItem(<span class="string">&quot;items&quot;</span>, <span class="built_in">JSON</span>.stringify(items));</span><br><span class="line">  <span class="built_in">this</span>.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;form&gt;</code>에 이벤트를 걸기 때문에 <code>e.preventDefault</code>로 기본 동작을 막는다. (안 막으면 기본 동작인 새로고침이 일어난다)</p><p>그리고 아이템의 값을 JSON을 이용하여 String으로 바꿔주고 리스트를 새로고침, 로컬스토리지에도 저장하면 된다.</p><p><code>this.reset()</code>을 하지 않으면 기본 동작을 막아놨기 때문에 폼에 입력한 내용들이 날라가지 않고 그대로 남아있게 되기에 꼭 날려주자.</p><h2 id="체크박스-토글"><a href="#체크박스-토글" class="headerlink" title="체크박스 토글"></a>체크박스 토글</h2><p>마지막으로 구현할 것은 체크박스 토글이고, 이 역시 로컬스토리지에 변경 내용이 저장되어야 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleDone</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.target.type != <span class="string">&quot;checkbox&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> index = e.target.dataset.index;</span><br><span class="line">  items[index].done = !items[index].done;</span><br><span class="line">  <span class="built_in">localStorage</span>.setItem(<span class="string">&quot;items&quot;</span>, <span class="built_in">JSON</span>.stringify(items));</span><br><span class="line">  populateList(items, itemsList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>items</code> 배열의 <code>done</code> 값을 반대로 저장하고, 로컬스토리지와 새로고침하는 과정은 <code>addItem()</code> 함수의 로직과 같다.</p><p>이제 이 모든 함수들을 이벤트만 걸어주면 끝이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addItems.addEventListener(<span class="string">&quot;submit&quot;</span>, addItem);</span><br><span class="line">itemsList.addEventListener(<span class="string">&quot;click&quot;</span>, toggleDone);</span><br><span class="line">populateList(items, itemsList);</span><br></pre></td></tr></table></figure><h2 id="추가-구현-전체-삭제"><a href="#추가-구현-전체-삭제" class="headerlink" title="추가 구현 - 전체 삭제"></a>추가 구현 - 전체 삭제</h2><p>전체 삭제도 만들어보면 좋지 않을까 해서 만든 전체 삭제 함수이다. 당연히 로컬 스토리지도 초기화된다.</p><p>먼저 적당한 위치에 버튼을 만들어준다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;clear&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Clear all items&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>배운 방법들을 활용하여 초기화 함수를 작성하고 바로 이벤트를 걸어준다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;[name=&quot;clear&quot;]&#x27;</span>).addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">localStorage</span>.clear(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">  items.length = <span class="number">0</span>;</span><br><span class="line">  populateList(items, itemsList);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>items</code>에 해당하는 데이터를 로컬 스토리지에서 모두 날리고, <code>items</code> 배열을 초기화시키는데 이 배열은 <code>const</code>로 선언되었기 때문에 재선언을 할 수 없으므로 <code>length</code>를 0으로 만들어주는 방법이 있다.</p><blockquote><p>이제 30 코스 중 15개를 완수했다. 하루에 1개씩 배우는 재미가 쏠쏠하고, 뿌듯하다.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day-15-LocalStorage-Contains-emphasized-items&quot;&gt;&lt;a href=&quot;#Day-15-LocalStorage-Contains-emphasized-items&quot; class=&quot;headerlink&quot; title=&quot;Da</summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="javascript30" scheme="https://zinirun.github.io/tags/javascript30/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 30 - Day 14 References VS Copying</title>
    <link href="https://zinirun.github.io/2020/08/29/js-course30-14/"/>
    <id>https://zinirun.github.io/2020/08/29/js-course30-14/</id>
    <published>2020-08-28T16:35:28.000Z</published>
    <updated>2020-08-28T16:49:32.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-14-Javascript-References-VS-Copying"><a href="#Day-14-Javascript-References-VS-Copying" class="headerlink" title="Day 14 - Javascript References VS Copying"></a>Day 14 - Javascript References VS Copying</h2><div class="video-container"><iframe src="https://www.youtube.com/embed/YnfwDQ5XYF4" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>Reference(참조)와 Copy(복사)에 대한 전반적인 개념을 다룬다. 개인적으로 자바스크립트의 속성을 이해하기 위해 정말 필요한 과제였다고 생각한다.</p><h2 id="값-복사-number-String"><a href="#값-복사-number-String" class="headerlink" title="값 복사 (number, String)"></a>값 복사 (number, String)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> age2 = age;</span><br><span class="line"><span class="built_in">console</span>.log(age, age2); <span class="comment">// 100, 100</span></span><br><span class="line">age = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age, age2); <span class="comment">// 200, 100</span></span><br></pre></td></tr></table></figure><p>값은 별도의 방법없이 대입 선언만으로 복사할 수 있다. 예시는 숫자인데 문자열(String)도 마찬가지다.</p><h2 id="배열-복사"><a href="#배열-복사" class="headerlink" title="배열 복사"></a>배열 복사</h2><p>배열은 값을 복사할 때 처럼 <code>=</code>로는 할 수 없다. 그러면 “복사”가 아닌 “참조”가 돼서 복사된 (것처럼 보이는) 배열의 요소가 변경되면 원래의 배열도 바뀌게 된다. 당연히 참조되었기 때문에 이런 일이 발생한다.</p><p>배열을 복사하는 방법은 많다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> players = [<span class="string">&quot;Wes&quot;</span>, <span class="string">&quot;Sarah&quot;</span>, <span class="string">&quot;Ryan&quot;</span>, <span class="string">&quot;Poppy&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> team2 = players.slice();</span><br><span class="line"><span class="keyword">const</span> team3 = [].concat(players);</span><br><span class="line"><span class="keyword">const</span> team4 = [...players];</span><br><span class="line"><span class="keyword">const</span> team5 = <span class="built_in">Array</span>.from(players);</span><br></pre></td></tr></table></figure><p><code>players</code> 배열을 복사하기 위해 사용할 수 있는 4가지 방법이고, 결과는 모두 같다. 나는 <code>...</code>을 사용하는 ES6 Spread 방법이 가장 마음에 든다. 참고로 <code>slice()</code>와 <code>concat()</code>으로 복사가 가능한 이유는 대상이 되는 배열을 가지고 새로운 배열을 반환하기 때문이다.</p><h2 id="객체-Object-복사"><a href="#객체-Object-복사" class="headerlink" title="객체(Object) 복사"></a>객체(Object) 복사</h2><h3 id="One-Level-Copy-Object-assign"><a href="#One-Level-Copy-Object-assign" class="headerlink" title="One Level Copy - Object.assign()"></a>One Level Copy - <code>Object.assign()</code></h3><p>복사의 대상이 되는 배열은</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Zini&quot;</span>,</span><br><span class="line">  age: <span class="number">24</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이 <code>person</code> 객체이다. 당연히 <code>=</code>를 사용하면 복사가 아닌 참조가 되어버린다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> personCopy = <span class="built_in">Object</span>.assign(&#123;&#125;, person, &#123; <span class="attr">number</span>: <span class="number">99</span> &#125;);</span><br></pre></td></tr></table></figure><p><code>Object.assign</code>을 사용해서 <code>person</code> 객체를 다시 객체화시켜 복사하는 방법이 있다.</p><blockquote><p>나중에는 배열에서 spread를 사용한 것처럼 <code>&#123;...person&#125;</code>으로 복사가 가능해질 것 같다. 참고로 Chrome에서는 현재 지원한다고 한다.</p></blockquote><h3 id="One-Level-이상의-Copy-JSON-parse-JSON-stringify"><a href="#One-Level-이상의-Copy-JSON-parse-JSON-stringify" class="headerlink" title="One Level 이상의 Copy - JSON.parse(JSON.stringify())"></a>One Level 이상의 Copy - <code>JSON.parse(JSON.stringify())</code></h3><p>복사할 대상이</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zini = &#123;</span><br><span class="line">  name: <span class="string">&quot;Zini&quot;</span>,</span><br><span class="line">  age: <span class="number">24</span>,</span><br><span class="line">  social: &#123;</span><br><span class="line">    github: <span class="string">&quot;zinirun&quot;</span>,</span><br><span class="line">    instagram: <span class="string">&quot;@normalzini&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이렇게 1레벨이 아닌 2레벨로 구성되어 있다면, 앞의 방법처럼 <code>Object.assign()</code>을 사용할 수 없다. 1레벨만 복사되고 2레벨부터는 참조되기 때문에 2레벨의 요소가 변경되면 원 배열의 값도 바뀐다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ziniCopy = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(zini));</span><br></pre></td></tr></table></figure><p><code>JSON</code>을 사용하여 JSON 객체로 stringify 후 parse하면 레벨에 관계없이 복사할 수 있다. 당연히 1레벨도 복사할 수 있기 때문에 나는 객체를 복사할 때는 항상 JSON을 사용할 것 같다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day-14-Javascript-References-VS-Copying&quot;&gt;&lt;a href=&quot;#Day-14-Javascript-References-VS-Copying&quot; class=&quot;headerlink&quot; title=&quot;Day 14 - Javas</summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="javascript30" scheme="https://zinirun.github.io/tags/javascript30/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
  <entry>
    <title>BOJ - 1715 카드 정렬하기 (정렬)</title>
    <link href="https://zinirun.github.io/2020/08/29/ps-sort-boj-1715/"/>
    <id>https://zinirun.github.io/2020/08/29/ps-sort-boj-1715/</id>
    <published>2020-08-28T15:28:10.000Z</published>
    <updated>2020-08-28T15:42:01.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="국영수"><a href="#국영수" class="headerlink" title="국영수"></a>국영수</h2><p>문제 <a href="https://www.acmicpc.net/problem/1715">Acmicpc</a></p><p><img src="/images/2020-08-29-00-41-59.png"></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">input=sys.stdin.readline</span><br><span class="line">N = int(input())</span><br><span class="line">card_deck = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(N):</span><br><span class="line">    heapq.heappush(card_deck, int(input()))</span><br><span class="line"><span class="keyword">if</span> len(card_deck)==<span class="number">1</span>: print(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    answer=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> len(card_deck) &gt; <span class="number">1</span>:</span><br><span class="line">        k=heapq.heappop(card_deck)+heapq.heappop(card_deck)</span><br><span class="line">        answer+=k</span><br><span class="line">        heapq.heappush(card_deck,k)</span><br><span class="line">    print(answer)</span><br></pre></td></tr></table></figure><p>우선순위 큐를 이용해서 2개를 뺀 후 (우선순위 큐에서 heappop하면 가장 작은 것 2개를 빼낸다) 더한 값을 결과값에 누적해서 더해주고, 다시 우선순위 큐에 집어넣는다.</p><p>우선순위 큐를 사용하지 않는다면 2개를 더한 값을 넣어준 후 다시 <code>sort()</code>를 쓰던지 해서 정렬시켜야 하는데, 당연히 시간초과가 난다.</p><p>어떻게든 우선순위 큐를 안써보려고 해봤지만, 로직대로면 다시 정렬해야 하기에 라이브러리를 사용 안 할수가 없다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n=int(input())</span><br><span class="line">card=sorted([int(input()) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)])</span><br><span class="line">isSet=<span class="literal">False</span></span><br><span class="line">comp_sum=<span class="number">0</span></span><br><span class="line">comp=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> idx,i <span class="keyword">in</span> enumerate(card):</span><br><span class="line">    <span class="keyword">if</span> isSet==<span class="literal">True</span>:</span><br><span class="line">        comp_sum+=(comp_sum+prev+i)</span><br><span class="line">        isSet=<span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> idx==n<span class="number">-1</span>: comp_sum+=(comp_sum+i)</span><br><span class="line">        prev=i</span><br><span class="line">        isSet=<span class="literal">True</span></span><br><span class="line">print(comp_sum)</span><br></pre></td></tr></table></figure><p>위는 틀린 코드인데, 더해서 누적하는 과정은 여차저차 했다고 쳐도 다시 정렬하는 과정이 없기에 당연히 틀린 답이다.</p><blockquote><p>문제를 보고 어떤 로직으로 풀 지, 또 거기에는 어떤 라이브러리가 필요한지 캐치하는 능력을 기르자 (아직 턱없이 부족하다)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;국영수&quot;&gt;&lt;a href=&quot;#국영수&quot; class=&quot;headerlink&quot; title=&quot;국영수&quot;&gt;&lt;/a&gt;국영수&lt;/h2&gt;&lt;p&gt;문제 &lt;a href=&quot;https://www.acmicpc.net/problem/1715&quot;&gt;Acmicpc&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/tags/algorithm/"/>
    
    <category term="ps" scheme="https://zinirun.github.io/tags/ps/"/>
    
  </entry>
  
  <entry>
    <title>Progammers - 실패율 (정렬)</title>
    <link href="https://zinirun.github.io/2020/08/29/ps-sort-programmers-fail-rate/"/>
    <id>https://zinirun.github.io/2020/08/29/ps-sort-programmers-fail-rate/</id>
    <published>2020-08-28T15:27:57.100Z</published>
    <updated>2020-08-28T15:34:59.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="실패율"><a href="#실패율" class="headerlink" title="실패율"></a>실패율</h2><p>문제 <a href="https://programmers.co.kr/learn/courses/30/lessons/42889">프로그래머스</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">N, stages</span>):</span></span><br><span class="line">    fail=[]</span><br><span class="line">    remain=len(stages)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">if</span> remain!=<span class="number">0</span>:</span><br><span class="line">            p=stages.count(i+<span class="number">1</span>)</span><br><span class="line">            fail.append((i+<span class="number">1</span>,p/remain))</span><br><span class="line">            remain-=p</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            fail.append((i+<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> list(map(<span class="keyword">lambda</span> x:x[<span class="number">0</span>],sorted(fail,reverse=<span class="literal">True</span>,key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line">print(solution(<span class="number">5</span>, [<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure><p>주어진 <code>stages</code> 배열을 정수를 증가시키면서 count를 세고 적절히 <code>fail</code> 배열에 집어넣고, 정렬하면 된다.</p><p>정렬된 배열을 리턴하는 부분이 꽤 복잡한데, 실패율(인덱스 1)을 기준으로 내림차순 정렬 후 스테이지 번호(인덱스 0)를 리스트로 반환한다.</p><p>이 문제는 전에 풀었던 문제인데, 코드가 너무 더러운 것 같아 다시 풀었다. 이전 코드는</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">N, stages</span>):</span></span><br><span class="line">    a=[]</span><br><span class="line">    cur=len(stages)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">if</span> cur!=<span class="number">0</span>:</span><br><span class="line">            a.append(stages.count(i+<span class="number">1</span>)/cur)</span><br><span class="line">            cur-=stages.count(i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> list(map(<span class="keyword">lambda</span> x:x+<span class="number">1</span>,sorted(range(len(a)),key=a.__getitem__, reverse=<span class="literal">True</span>)))</span><br></pre></td></tr></table></figure><p>다시 작성한 코드보다 가독성도 별로고, 코드 해석도 어려웠다.</p><blockquote><p>결론: “숏코딩”보다 “클린코딩”하자.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;실패율&quot;&gt;&lt;a href=&quot;#실패율&quot; class=&quot;headerlink&quot; title=&quot;실패율&quot;&gt;&lt;/a&gt;실패율&lt;/h2&gt;&lt;p&gt;문제 &lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/428</summary>
      
    
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/tags/algorithm/"/>
    
    <category term="ps" scheme="https://zinirun.github.io/tags/ps/"/>
    
  </entry>
  
  <entry>
    <title>BOJ - 18310 안테나 (정렬)</title>
    <link href="https://zinirun.github.io/2020/08/27/ps-sort-boj-18310/"/>
    <id>https://zinirun.github.io/2020/08/27/ps-sort-boj-18310/</id>
    <published>2020-08-27T12:53:53.000Z</published>
    <updated>2020-08-28T15:35:36.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="국영수"><a href="#국영수" class="headerlink" title="국영수"></a>국영수</h2><p>문제 <a href="https://www.acmicpc.net/problem/18310">Acmicpc</a></p><p><img src="/images/2020-08-27-21-54-41.png"></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n=int(input())</span><br><span class="line">house=sorted(list(map(int, input().split())))</span><br><span class="line">print(house[(n<span class="number">-1</span>)//<span class="number">2</span>]) <span class="comment"># n-1인 이유는 짝수일때 중간값은 2개인데 작은 값을 출력하라고 했기때문</span></span><br></pre></td></tr></table></figure><p>처음 이 문제를 보고 1부터 n까지 각 요소에 대한 차이의 합을 계산해서 최소가 되는 인덱스를 반환하면 되지 않을까 했다.</p><p>(틀린 코드)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n=int(input())</span><br><span class="line">house=sorted(list(map(int, input().split())))</span><br><span class="line">min_=<span class="number">200001</span></span><br><span class="line">loc=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">    dist=sum(map(<span class="keyword">lambda</span> x:x-i,house))</span><br><span class="line">    <span class="keyword">if</span> dist&lt;min_:</span><br><span class="line">        min_=dist</span><br><span class="line">        loc=i</span><br><span class="line">print(loc)</span><br></pre></td></tr></table></figure><p>당연히 시간 초과가 났다. 처음 작성한 코드는 시간복잡도가 <code>O(N^2)</code>이고 주어진 자연수의 범위가 20만까지이므로 20만의 제곱이 된다.</p><p>문제를 잘못 읽었었다. 나는 1,5,7,9가 주어질 때 1에서 9까지의 모든 정수부를 계산했는데, 다시 보니 주어진 값에서만 안테나를 설치할 위치를 고를 수 있었다.</p><p>주어진 리스트를 오름차순으로 정렬하고 중간 값을 반환하면 최적의 위치가 된다. 짝수일 경우 중간값이 2개가 되는데, 문제를 보면 여러 값일 경우 가장 작은 값을 출력하라고 했기 때문에 중간에 있는 인덱스를 계산할 때 <code>n</code>이 아닌 <code>n-1</code>로 생각하면 된다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;국영수&quot;&gt;&lt;a href=&quot;#국영수&quot; class=&quot;headerlink&quot; title=&quot;국영수&quot;&gt;&lt;/a&gt;국영수&lt;/h2&gt;&lt;p&gt;문제 &lt;a href=&quot;https://www.acmicpc.net/problem/18310&quot;&gt;Acmicpc&lt;/a&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/tags/algorithm/"/>
    
    <category term="ps" scheme="https://zinirun.github.io/tags/ps/"/>
    
  </entry>
  
  <entry>
    <title>BOJ - 10825 국영수 (정렬)</title>
    <link href="https://zinirun.github.io/2020/08/27/ps-sort-boj-10825/"/>
    <id>https://zinirun.github.io/2020/08/27/ps-sort-boj-10825/</id>
    <published>2020-08-27T12:49:23.000Z</published>
    <updated>2020-08-28T15:35:38.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="국영수"><a href="#국영수" class="headerlink" title="국영수"></a>국영수</h2><p>문제 <a href="https://www.acmicpc.net/problem/10825">Acmicpc</a></p><p><img src="/images/2020-08-27-21-51-11.png"></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n=int(input())</span><br><span class="line">score=[]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">    name,k,e,m=input().split()</span><br><span class="line">    score.append((name, int(k), int(e), int(m)))</span><br><span class="line">score.sort(key=<span class="keyword">lambda</span> x:(-x[<span class="number">1</span>],x[<span class="number">2</span>],-x[<span class="number">3</span>],x[<span class="number">0</span>]))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> score:</span><br><span class="line">    print(i[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>정렬의 기준이 중첩되어 있을 때 key(기준)에서 lambda를 사용하는 방법이 핵심이다.</p><p>일반적으로 배열의 1번 인덱스를 기준으로 정렬할 때 <code>lambda x:x[1]</code>, 1번 인덱스로 정렬 후 2번 인덱스로 정렬할 때 <code>lambda x:(x[1], x[2])</code> 처럼 괄호 열고 인덱스만 차례로 넣으면 된다.</p><p>그런데 문제에서는 증가, 감소가 번갈아가며 정렬 기준이 주어지는데 이 때는 내림차순으로 정렬할 요소에 <code>-</code>를 붙이면 반대 정렬이 된다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;국영수&quot;&gt;&lt;a href=&quot;#국영수&quot; class=&quot;headerlink&quot; title=&quot;국영수&quot;&gt;&lt;/a&gt;국영수&lt;/h2&gt;&lt;p&gt;문제 &lt;a href=&quot;https://www.acmicpc.net/problem/10825&quot;&gt;Acmicpc&lt;/a&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/tags/algorithm/"/>
    
    <category term="ps" scheme="https://zinirun.github.io/tags/ps/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 30 - Day 13 Slide in on Scroll</title>
    <link href="https://zinirun.github.io/2020/08/27/js-course30-13/"/>
    <id>https://zinirun.github.io/2020/08/27/js-course30-13/</id>
    <published>2020-08-27T07:34:32.000Z</published>
    <updated>2020-08-27T07:44:41.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-13-Slide-in-on-Scroll"><a href="#Day-13-Slide-in-on-Scroll" class="headerlink" title="Day 13 - Slide in on Scroll"></a>Day 13 - Slide in on Scroll</h2><div class="video-container"><iframe src="https://www.youtube.com/embed/uzRsENVD3W8" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>이미지로 스크롤하면 슬라이드되어서 나오는 애니메이션을 추가하는 예제이다. <a href="https://zinirun.github.io/2020/08/16/js-throttling-debouncing/">디바운스</a>도 사용한다. (예전에 정리해놓길 잘했다, 정말 자주 써먹는다)</p><h3 id="Debounce"><a href="#Debounce" class="headerlink" title="Debounce"></a>Debounce</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait = <span class="number">20</span>, immediate = true</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (!immediate) func.apply(context, args);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> callNow = immediate &amp;&amp; !timeout;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(later, wait);</span><br><span class="line">    <span class="keyword">if</span> (callNow) func.apply(context, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>외부에 공개되어 있는 디바운스 함수 틀 중 하나이고 강의 제작자도 그 중 하나를 썼다고 한다. (개인적으로 Zerocho님의 디바운스 예제가 더 마음에 든다)</p><h3 id="checkSlide-작성"><a href="#checkSlide-작성" class="headerlink" title="checkSlide() 작성"></a>checkSlide() 작성</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkSlide</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  sliderImages.forEach(<span class="function">(<span class="params">sliderImage</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// half way through the image</span></span><br><span class="line">    <span class="keyword">const</span> slideInAt =</span><br><span class="line">      <span class="built_in">window</span>.scrollY + <span class="built_in">window</span>.innerHeight - sliderImage.height / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// bottom of the image</span></span><br><span class="line">    <span class="keyword">const</span> imageBottom = sliderImage.offsetTop + sliderImage.height;</span><br><span class="line">    <span class="keyword">const</span> isHalfShown = slideInAt &gt; sliderImage.offsetTop;</span><br><span class="line">    <span class="keyword">const</span> isNotScrolledPast = <span class="built_in">window</span>.scrollY &lt; imageBottom;</span><br><span class="line">    <span class="keyword">if</span> (isHalfShown &amp;&amp; isNotScrolledPast) &#123;</span><br><span class="line">      sliderImage.classList.add(<span class="string">&quot;active&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sliderImage.classList.remove(<span class="string">&quot;active&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이미지에 슬라이드 트랜지션을 추가할 지 말지 결정하는 핵심적인 코드이다. <code>.active</code>를 추가하면 트랜지션 효과가 나타나고, 제거하면 없어진다.</p><p>스크롤 값을 계산하는 부분이 가장 까다롭다. 우선 크게 계산하는 경우는 2가지인데, 이미지 위의 모서리가 보이는지, 이미지 아래의 모서리가 안보이는지 스크롤할 때 마다 디바운스로 호출하여 검사한다.</p><p>이제 윈도우 객체에 <code>scroll</code> 이벤트만 디바운스를 이용해서 걸어주면 끝이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;scroll&quot;</span>, debounce(checkSlide));</span><br></pre></td></tr></table></figure><p>이 강의의 목적은 스크롤 값을 수학을 이용해서 계산하는 것보다는, 각 객체에 대해 적절한 상황에서 변수를 선언하여 조건을 검사하고 특정 메소드를 호출할 수 있는지라고 한다. (사실 이 말이 맞는게, 스크롤 값 계산이 어렵다면 그냥 구글에 스크롤 슬라이드 이미지 검색하면 널렸다)</p><p>이제 자바스크립트 30코스 절반이 다 되어간다. 바닐라JS로 모든 것을 할 수 있다는 말이 체감되고 있다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day-13-Slide-in-on-Scroll&quot;&gt;&lt;a href=&quot;#Day-13-Slide-in-on-Scroll&quot; class=&quot;headerlink&quot; title=&quot;Day 13 - Slide in on Scroll&quot;&gt;&lt;/a&gt;Day 13 - </summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="javascript30" scheme="https://zinirun.github.io/tags/javascript30/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
  <entry>
    <title>React 첫번째 프로젝트 - TodoList</title>
    <link href="https://zinirun.github.io/2020/08/27/react-first-todolist/"/>
    <id>https://zinirun.github.io/2020/08/27/react-first-todolist/</id>
    <published>2020-08-27T05:55:36.000Z</published>
    <updated>2020-08-27T06:29:35.938Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2020-08-27-15-23-07.png" alt="todolist"><br><img src="https://github.com/zinirun/first-react-todo/raw/master/images/dev-timelapse.gif" alt="timelapse"></p><div style="text-align:center">개발 타임랩스 은근히 재밌다..</div><h2 id="리액트로-만든-첫번째-프로젝트-투두리스트"><a href="#리액트로-만든-첫번째-프로젝트-투두리스트" class="headerlink" title="리액트로 만든 첫번째 프로젝트, 투두리스트"></a>리액트로 만든 첫번째 프로젝트, 투두리스트</h2><p>항상 뭔가를 배우면 그걸로 프로젝트를 하나 만들어봐야(기왕이면 배포까지 해봐야) 직성이 풀리고 그 다음 주제로 넘어가야 직성이 풀린다. 이번에 리액트 컴포넌트를 배우고 (정말 간단한) TodoList를 구현해보았다.</p><h2 id="파일-구성과-로직"><a href="#파일-구성과-로직" class="headerlink" title="파일 구성과 로직"></a>파일 구성과 로직</h2><p>핵심적인 파일은</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">App.js</span><br><span class="line">CreateTodo.js</span><br><span class="line">TodoList.js</span><br></pre></td></tr></table></figure><p>다음과 같이 3개이다.</p><p>투두리스트를 추가, 토글, 삭제하는 함수는 <code>App.js</code>에 작성되어 있다. <code>App.js</code>에서 앱의 전체적인 구조(<code>&lt;CreateTodo&gt;</code> 컴포넌트와 <code>&lt;TodoList&gt;</code> 컴포넌트)를 렌더링한다.</p><h2 id="핵심-코드-작성하기"><a href="#핵심-코드-작성하기" class="headerlink" title="핵심 코드 작성하기"></a>핵심 코드 작성하기</h2><h3 id="useState-useRef-작성"><a href="#useState-useRef-작성" class="headerlink" title="useState(), useRef() 작성"></a>useState(), useRef() 작성</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [inputs, setInputs] = useState(&#123;</span><br><span class="line">  title: <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [todos, setTodos] = useState([</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    title: <span class="string">&quot;리액트 혼내주기&quot;</span>,</span><br><span class="line">    isImportant: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextId = useRef(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>앱에서 사용하는 변수를 <code>useState()</code>를 사용하여 선언한다. 투두리스트는 할 일(title)과 중요 여부(isImportant)로 구성되어 있다.</p><p>id는 1씩 증가시켜야 하는데, 비렌더링 객체로 관리해주기 위해 <code>useRef()</code>를 사용한다.</p><h3 id="할-일-추가-중요-여부-토글-삭제-구현"><a href="#할-일-추가-중요-여부-토글-삭제-구현" class="headerlink" title="할 일 추가, 중요 여부 토글, 삭제 구현"></a>할 일 추가, 중요 여부 토글, 삭제 구현</h3><h4 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate()"></a>onCreate()</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onCreate = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (title.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newTodo = &#123;</span><br><span class="line">      id: nextId.current,</span><br><span class="line">      title,</span><br><span class="line">    &#125;;</span><br><span class="line">    setTodos([...todos, newTodo]);</span><br><span class="line">    setInputs(&#123;</span><br><span class="line">      title: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    nextId.current += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>CreateTodo</code> 객체에서 <code>onCreate()</code> 함수가 호출되면 입력된 <code>title</code> 값을 <code>useState()</code>의 set 메소드로 추가해준다. <code>setTodo</code>에서 spread 방식으로 배열에 요소를 추가해줬는데, <code>concat()</code> 메소드를 써도 상관없다. 할 일이 추가되었다면 <code>setInputs()</code> 메소드로 사용자가 입력한 값을 초기화한다. 그 후 <code>nextId.current</code>를 1 증가시킨다. (뒤에 <code>.current</code>를 붙이는 이유는 일반적인 숫자 객체가 아닌 <code>useRef()</code>로 선언된 객체이기 때문이다)</p><h5 id="1시간동안-잡은-오류"><a href="#1시간동안-잡은-오류" class="headerlink" title="1시간동안 잡은 오류"></a>1시간동안 잡은 오류</h5><p><code>id</code>를 <code>nextId</code>로 정해주기 위해 계속 작성했으나 정상적으로 <code>id</code>가 선언되지 않고 계속 object 객체로 선언되었다. 바로 뒤에 <code>.current</code>를 붙이지 않아 생긴 오류였다. <code>useRef()</code>로 관리되는 객체는 접근시 항상 <code>.current</code>를 붙어야 한다.</p><h3 id="onRemove"><a href="#onRemove" class="headerlink" title="onRemove()"></a>onRemove()</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onRemove = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  setTodos(todos.filter(<span class="function">(<span class="params">todo</span>) =&gt;</span> todo.id !== id));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Todo</code> 객체에서 <code>onRemove()</code> 함수가 호출되면 <code>id</code>를 인자로 받아서 해당 <code>id</code> 값을 가진 요소를 제외한 배열을 필터링해서 <code>setTodo()</code> 메소드로 변수를 다시 지정한다.</p><h3 id="onToggle"><a href="#onToggle" class="headerlink" title="onToggle()"></a>onToggle()</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onToggle = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  setTodos(</span><br><span class="line">    todos.map(<span class="function">(<span class="params">todo</span>) =&gt;</span></span><br><span class="line">      todo.id === id ? &#123; ...todo, <span class="attr">isImportant</span>: !todo.isImportant &#125; : todo</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>중요 여부를 바꿀 수 있는 <code>onToggle()</code> 객체이다. 위에서 작성한 <code>onRemove()</code> 함수와 작동방식은 비슷한데, <code>id</code>를 인자로 받아 해당 <code>id</code> 값을 가진 요소의 <code>isImportant</code>를 true, false로 바꿔준다.</p><h3 id="TodoList-컴포넌트-작성"><a href="#TodoList-컴포넌트-작성" class="headerlink" title="TodoList 컴포넌트 작성"></a>TodoList 컴포넌트 작성</h3><p><code>TodoList</code> 컴포넌트로 <code>todos</code> 데이터가 들어오면 각각을 매핑하여 <code>Todo</code> 객체로 만들어 반환한다. 사실 이 부분에서 컴포넌트를 효율적으로 짜야 하는 이유를 체감했다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoList</span>(<span class="params">&#123; todos, onRemove, onToggle &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;todolist-wrapper&quot;</span>&gt;</span><br><span class="line">      &#123;todos.map(<span class="function">(<span class="params">todo</span>) =&gt;</span> (</span><br><span class="line">        &lt;Todo</span><br><span class="line">          key=&#123;todo.id&#125;</span><br><span class="line">          todo=&#123;todo&#125;</span><br><span class="line">          onRemove=&#123;onRemove&#125;</span><br><span class="line">          onToggle=&#123;onToggle&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="리액트를-깃허브-페이지에-배포하기"><a href="#리액트를-깃허브-페이지에-배포하기" class="headerlink" title="리액트를 깃허브 페이지에 배포하기"></a>리액트를 깃허브 페이지에 배포하기</h2><p>리액트 프로젝트를 다 만들었다면 깃허브 페이지에 배포하는 것은 일도 아니다. 우선 프로젝트 코드를 깃허브 레파지토리에 커밋, 푸시한다.</p><p>이제 프로젝트에 <code>gh-pages</code> 패키지를 설치한다.</p><p>npm을 사용한다면,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i gh-pages --save-dev</span><br></pre></td></tr></table></figure><p>yarn을 사용한다면,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add gh-pages --dev</span><br></pre></td></tr></table></figure><p>를 입력하면 된다. 이제 <code>package.json</code> 파일을 열어보자. 두가지만 하면 된다.</p><p>첫번째로, <code>homepage</code>를 추가한다. 그냥 끄트머리에</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;gh-pages&quot;: &quot;^3.1.0&quot;</span><br><span class="line">  &#125;, // 밑에서부터 참고해서 추가하면 된다</span><br><span class="line">  &quot;homepage&quot;: &quot;http://&lt;깃허브아이디&gt;.github.io/&lt;레파지토리 이름&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 한 줄을 추가한다.</p><p>두번째로 <code>scripts</code> 항목에 <code>deploy</code>와 <code>predeploy</code>를 추가한다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;react-scripts start&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;react-scripts build&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;react-scripts test&quot;,</span><br><span class="line">    &quot;eject&quot;: &quot;react-scripts eject&quot;,</span><br><span class="line">    <span class="comment">//밑에서부터 deploy, predeploy를 추가한다.</span></span><br><span class="line">    &quot;deploy&quot;: &quot;gh-pages -d build&quot;,</span><br><span class="line">    &quot;predeploy&quot;: &quot;yarn run build&quot; //yarn &lt;-&gt; npm</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p><code>predeploy</code>에는 yarn, npm을 기호에 맞게 사용하자.</p><p>이제 설정은 모두 끝났고, 깃허브 페이지로 배포만 하면 정말 끝이다.</p><p>터미널을 열어</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run deploy <span class="comment"># 또는 npm run deploy</span></span><br></pre></td></tr></table></figure><p>를 입력하고 페이지로 접속해보자.</p><blockquote><p>혹시나 깃허브 페이지에 접속하였는데 readme 파일이 뜬다면 깃허브의 레파지토리 설정으로 접속하여 GitHub Pages의 Source를 <code>gh-pages</code> 브랜치로 설정하고 새로고침하면 리액트 프로젝트가 정상적으로 표시된다.</p></blockquote><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>정말 별 볼일 없는 할 일 리스트지만 하나를 배우면 써먹어보는 습관은 자부심을 느끼게 한다. 맨땅에서 코드를 작성해서 오류도 잡아보고 배포까지 해보면 잊을래야 잊을 수가 없다. 리액트는 정말 매력적이고, 나는 아직 멀었다. 더 노력해야겠다.</p><blockquote><p>모든 코드는 <a href="https://github.com/zinirun/first-react-todo">Github</a>에서 확인할 수 있다.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/2020-08-27-15-23-07.png&quot; alt=&quot;todolist&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://github.com/zinirun/first-react-todo/raw/master/images/dev</summary>
      
    
    
    
    <category term="ReactJS" scheme="https://zinirun.github.io/categories/ReactJS/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="react" scheme="https://zinirun.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Flask 앱 Netlify, Heroku 배포 삽질기</title>
    <link href="https://zinirun.github.io/2020/08/26/flask-deploy-netlify-heroku/"/>
    <id>https://zinirun.github.io/2020/08/26/flask-deploy-netlify-heroku/</id>
    <published>2020-08-26T05:38:15.000Z</published>
    <updated>2020-08-26T06:06:49.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="결론은-안된다"><a href="#결론은-안된다" class="headerlink" title="결론은 안된다."></a>결론은 안된다.</h2><p>학교에서 대여해준 NHN Toast Cloud 서버가 8월 말에 사용이 중지된다는 얘기를 듣고 AWS에 입문해볼까 하다가 어차피 토이 프로젝트이니 이 정도는 <a href="https://www.netlify.com/">Netlify</a>나 <a href="https://herokuapp.com/">Heroku</a>에 서비스해도 될 것 같아서 배포를 하려 했는데, 딱 거기서 생각을 멈췄어야 했다. 아직도 머리가 얼얼하다.</p><blockquote><p>결론부터 말하자면 정적 웹(파일 업데이트가 없고 화면 view만 존재하는 웹)이 아니라면 헤로쿠든 네트리파이든 쓰면 안된다!!!</p></blockquote><p><img src="/images/2020-08-26-14-43-29.png"></p><p>정확히 오후 한시부터 밤 열시까지 이 삽질을 했다.</p><h2 id="안된다"><a href="#안된다" class="headerlink" title="안된다."></a>안된다.</h2><p>Flask는 기본적으로 파이썬을 개발용 웹으로 서비스해주기 때문에 <code>gunicorn</code>, <code>wsgi</code>같은 웹팩을 이용해서 사이트를 외부에 노출시켜야 한다.</p><p>플라스크 기반의 블로그가 네트리파이나 헤로쿠에서 잘 돌아가는 이유는, 지금 내가 쓰고 있는 헥소나 지킬과 같은 블로그 툴은 <code>git push</code> 과정으로 배포하는 방식이라 결국 푸시할 때마다 정적 뷰가 생성되기 때문에 잘 사용되는 것이다.</p><p>내가 옮기려는 Flask 앱은 이미지를 업로드하면 그 이미지를 분석해주는 서비스이기 때문에 이미지 “업로드”는 헤로쿠, 네트리파이와 같은 PaaS 클라우드에서는 할 수 없다..</p><p><img src="/images/2020-08-26-14-49-25.png"></p><p>네트리파이 개발자가 client-side가 아닌 server-side 앱은 호스팅이 안된다고 한다.</p><p>정적인 웹은 얼마든지 호스팅할 수 있다. 억울해서 이거라도 적어놓으려 한다.</p><h2 id="안되지만"><a href="#안되지만" class="headerlink" title="안되지만,"></a>안되지만,</h2><p>파일 업로드 등의 로직이 없는 Static Web은 네트리파이, 헤로쿠에서 얼마든지 서비스할 수 있는데, 일단 Flask 앱은 다 만들었다고 가정하고 이를 조금만 바꿔보자.</p><p>네트리파이는 <code>Flask-Freeze</code>를 이용하면 되고, 헤로쿠는 <code>gunicorn</code>선에서 서비스할 수 있다. 네트리파이는 <a href="https://medium.com/@francescaguiducci/how-to-build-a-simple-personal-website-with-python-flask-and-netlify-d800c97c283d">이 글</a>에 잘 정리되어 있으니 따라하면 되고, 헤로쿠만 정리해보겠다.</p><h3 id="헤로쿠에서-Flask-배포하기"><a href="#헤로쿠에서-Flask-배포하기" class="headerlink" title="헤로쿠에서 Flask 배포하기"></a>헤로쿠에서 Flask 배포하기</h3><p>우선 메인 앱(py)을 실행하는 부분이</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>다음과 같이 되어 있는지부터 확인해보자. <code>port</code>를 임의로 건드리면 안된다.</p><p>또한 앱을 라우팅하는 파이썬 파일에는</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br></pre></td></tr></table></figure><p>당연히 <code>app</code>을 <code>Flask</code>화 해야한다.</p><p>그리고 프로젝트 최상위 폴더에 <code>gunicorn</code> 관련 설정 파일을 하나 만드는데 확장자 없는 <code>Procfile</code> 파일을 만들어서</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web: gunicorn &lt;메인 앱 이름&gt;:app</span><br></pre></td></tr></table></figure><p>이렇게 한 줄의 텍스트를 넣고 저장한다. 이 <code>Procfile</code>을 헤로쿠에서 <code>web</code>으로 인식하고 <code>gunicorn</code> 기반으로 웹을 외부에 노출시키게 된다.</p><p>이제 <code>requirements.txt</code>와 <code>runtime.txt</code>만 설정하면 된다. 모두 프로젝트 최상위 폴더에 위치시킨다. 기본적으로 <code>Flask</code>와 웹팩 모듈들을 넣어준다. (파이썬 3.6.1 버전 기준이므로 버전에 맞게 바꿔준다)</p><p><code>requirements.txt</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">click&#x3D;&#x3D;6.7</span><br><span class="line">Flask&#x3D;&#x3D;0.12.2</span><br><span class="line">gunicorn&#x3D;&#x3D;19.7.1</span><br><span class="line">itsdangerous&#x3D;&#x3D;0.24</span><br><span class="line">Jinja2&#x3D;&#x3D;2.9.6</span><br><span class="line">MarkupSafe&gt;1.0</span><br><span class="line">Werkzeug&#x3D;&#x3D;0.12.2</span><br></pre></td></tr></table></figure><p>이제 파이썬 버전만 설정하면 정말 끝이다.</p><p><code>runtime.txt</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python-3.6.1</span><br></pre></td></tr></table></figure><p>이제 헤로쿠에 깃을 연결하고 배포하면 된다. 끝.</p><p><img src="/images/2020-08-26-15-03-10.png"></p><p>난 여기까지는 호스팅이 되는데 파일을 업로드하면 (당연히)</p><p><img src="/images/2020-08-26-15-04-09.png"></p><p>헤로쿠에서 파일 리퀘스트를 거부하는 500 Error가 발생한다.</p><p>이제 뭔가를 할 때는 되는지 안되는지부터 보고 삽질을 하던지 해야겠다.. 아무튼 내가 옮기려 했던 앱은 AWS에서 서비스 할 예정이다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;결론은-안된다&quot;&gt;&lt;a href=&quot;#결론은-안된다&quot; class=&quot;headerlink&quot; title=&quot;결론은 안된다.&quot;&gt;&lt;/a&gt;결론은 안된다.&lt;/h2&gt;&lt;p&gt;학교에서 대여해준 NHN Toast Cloud 서버가 8월 말에 사용이 중지된다는 얘기</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Javascript 30 - Day 12 Key Sequence Detection</title>
    <link href="https://zinirun.github.io/2020/08/26/js-course30-12/"/>
    <id>https://zinirun.github.io/2020/08/26/js-course30-12/</id>
    <published>2020-08-26T05:22:24.000Z</published>
    <updated>2020-08-26T05:36:57.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-12-Key-Sequence-Detection"><a href="#Day-12-Key-Sequence-Detection" class="headerlink" title="Day 12 - Key Sequence Detection"></a>Day 12 - Key Sequence Detection</h2><div class="video-container"><iframe src="https://www.youtube.com/embed/A5eVOIqGLU" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>윈도우에 키보드 이벤트를 걸고 특정 비밀 문자열을 만들어서 그 문자열을 입력하면 <code>cornify</code> 효과가 나타나는 과제이다.</p><p><img src="/images/2020-08-26-14-24-19.png"></p><p>귀여워서 계속 쳐봤다. 이게 대체 무슨 라이브러리일까 싶어서 <a href="https://www.cornify.com/">cornify</a> 사이트를 가보니 어떤 컨셉인지는 대충 알 것 같다..</p><h2 id="Full-script"><a href="#Full-script" class="headerlink" title="Full script"></a>Full script</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pressed = [];</span><br><span class="line"><span class="keyword">const</span> secretCode = <span class="string">&quot;zinirun&quot;</span>;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;keyup&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.key);</span><br><span class="line">  pressed.push(e.key);</span><br><span class="line">  <span class="keyword">if</span> (pressed.length &gt; secretCode.length) &#123;</span><br><span class="line">    pressed.splice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pressed.join(<span class="string">&quot;&quot;</span>) === secretCode) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;DING DING!&quot;</span>);</span><br><span class="line">    cornify_add();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(pressed);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이번 Day 12 과제는 지금까지의 과제를 잘 이해했다면 쉽게 구현할 수 있었다. <code>pressed</code>라는 키를 저장해둘 배열을 만들어 입력된 키 값을 넣어주면 되는데, <code>secretCode</code>의 길이에 맞게 잘라준다. (자르는 과정없이 모든 키를 배열에 푸시한다면 비밀 문자열의 입력 여부를 파악할 수 없으니까)</p><p><code>pressed</code> 배열을 자르는 코드는 <code>splice</code> 메소드를 이용하는데, 제작자와는 다르게 코드를 짰다. 원래는 다음과 같다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pressed.splice(-secretCode.length - <span class="number">1</span>, pressed.length - secretCode.length);</span><br></pre></td></tr></table></figure><p>다소 코드가 이해가 어려워서 내 방식대로 짰는데, 결과는 똑같다. <code>splice</code> 메소드는 첫번째 인자의 인덱스부터 두번째 인자의 개수까지 배열 요소를 삭제한다. 그러니까 내가 작성한 <code>pressed.splice</code>는 특정 조건일 때 인덱스 0을 삭제하고 앞으로 밀어주는 것이다.</p><p>이제 <code>pressed</code> 배열을 <code>secretCode</code>와 비교만 해주면 된다. 배열 요소를 한 문자열로 만들기 위해 <code>join(&#39;&#39;)</code>을 사용한다. 파이썬의 <code>&#39;&#39;.join()</code>과 같은 메소드인 것 같다. 그리고 <code>secretCode</code>와 대조하는데, 정답지의 코드는</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pressed.join(<span class="string">&quot;&quot;</span>).includes(secretCode)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;DING DING!&quot;</span>);</span><br><span class="line">  cornify_add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 <code>includes</code>를 이용하여 비교하는데, 결국 <code>===</code>를 사용해서 일치 여부를 판단하는 것이 더 낫다고 생각해서(어차피 <code>pressed</code> 배열은 <code>secretCode</code>의 길이만큼만 저장되고 포함되는지 여부가 궁금한게 아니고 일치하는지 여부가 궁금한거니까) 나는 <code>===</code>를 사용했다. 어떻게 하든 결과는 같다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day-12-Key-Sequence-Detection&quot;&gt;&lt;a href=&quot;#Day-12-Key-Sequence-Detection&quot; class=&quot;headerlink&quot; title=&quot;Day 12 - Key Sequence Detection&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="javascript30" scheme="https://zinirun.github.io/tags/javascript30/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 30 - Day 11 Custom Video Player</title>
    <link href="https://zinirun.github.io/2020/08/26/js-course30-11/"/>
    <id>https://zinirun.github.io/2020/08/26/js-course30-11/</id>
    <published>2020-08-25T15:59:36.000Z</published>
    <updated>2020-08-25T17:04:46.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-11-Custom-Video-Player"><a href="#Day-11-Custom-Video-Player" class="headerlink" title="Day 11 - Custom Video Player"></a>Day 11 - Custom Video Player</h2><div class="video-container"><iframe src="https://www.youtube.com/embed/yx-HYerClEA" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>비디오 플레이어를 직접 구현해보는 과제이다. 구현이 엄청 복잡할 줄 알았는데, <code>video</code> 태그에 대한 메소드들만 적당히 다룰 줄 안다면 구현하기 어렵지는 않을 것 같다.</p><p><img src="/images/2020-08-26-01-18-04.png"></p><p>여느 사이트에서나 볼 수 있는 비디오 플레이어를 플레이 버튼, 볼륨 조절, 배속 조절, 스킵, 재생 진행바까지 구현하는 것이 목표이다.</p><h3 id="재생"><a href="#재생" class="headerlink" title="재생"></a>재생</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">togglePlay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> method = video.paused ? <span class="string">&quot;play&quot;</span> : <span class="string">&quot;pause&quot;</span>;</span><br><span class="line">  video[method]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>처음에 보면 대체 무슨 말인가 할 수도 있다.</p><p>이 코드는 정확히 밑의 코드와 같다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">togglePlay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (video.paused) &#123;</span><br><span class="line">    video.play();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    video.pause();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사실 난 가독성은 밑의 코드가 더 나은 것 같다.</p><h4 id="이벤트-걸기"><a href="#이벤트-걸기" class="headerlink" title="이벤트 걸기"></a>이벤트 걸기</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">video.addEventListener(<span class="string">&quot;click&quot;</span>, togglePlay);</span><br><span class="line">toggle.addEventListener(<span class="string">&quot;click&quot;</span>, togglePlay);</span><br></pre></td></tr></table></figure><p>비디오를 클릭하나 재생버튼을 클릭하나 실행하는 함수는 같아야 한다.</p><h3 id="재생-버튼-변경"><a href="#재생-버튼-변경" class="headerlink" title="재생 버튼 변경"></a>재생 버튼 변경</h3><p>이제 재생 여부가 바뀔 때마다 삼각형 플레이 버튼과 일시정지 버튼을 서로 바꿔준다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> icon = <span class="built_in">this</span>.paused ? <span class="string">&quot;►&quot;</span> : <span class="string">&quot;❚ ❚&quot;</span>;</span><br><span class="line">  toggle.textContent = icon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="이벤트-걸기-1"><a href="#이벤트-걸기-1" class="headerlink" title="이벤트 걸기"></a>이벤트 걸기</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">video.addEventListener(<span class="string">&quot;play&quot;</span>, updateButton);</span><br><span class="line">video.addEventListener(<span class="string">&quot;pause&quot;</span>, updateButton);</span><br></pre></td></tr></table></figure><p>video 객체에는 <code>play</code>, <code>pause</code> 이벤트가 있다.(있더라)</p><h3 id="스킵"><a href="#스킵" class="headerlink" title="스킵"></a>스킵</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skip</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  video.currentTime += <span class="built_in">parseFloat</span>(<span class="built_in">this</span>.dataset.skip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>video.currentTime</code>으로 현재 재생 시간을 조절할 수 있다. <code>dataset</code>은 여전히 많이 사용되는 것 같으니 다시 상기하자.</p><h4 id="이벤트-걸기-2"><a href="#이벤트-걸기-2" class="headerlink" title="이벤트 걸기"></a>이벤트 걸기</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skipButtons.forEach(<span class="function">(<span class="params">button</span>) =&gt;</span> button.addEventListener(<span class="string">&quot;click&quot;</span>, skip));</span><br></pre></td></tr></table></figure><p><code>forEach</code> 구문은 이제 물구나무 서서도 작성할 줄 알아야 한다.</p><h3 id="볼륨-배속-조절"><a href="#볼륨-배속-조절" class="headerlink" title="볼륨, 배속 조절"></a>볼륨, 배속 조절</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRangeUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  video[<span class="built_in">this</span>.name] = <span class="built_in">this</span>.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>볼륨, 배속 조절은 모두 <code>input type=&quot;range&quot;</code>로 만들어졌기 때문에 DOM 객체의 name과 value를 가져와서 한 함수로 각각을 모두 조절할 수 있다.</p><h4 id="이벤트-걸기-3"><a href="#이벤트-걸기-3" class="headerlink" title="이벤트 걸기"></a>이벤트 걸기</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ranges.forEach(<span class="function">(<span class="params">range</span>) =&gt;</span> range.addEventListener(<span class="string">&quot;change&quot;</span>, handleRangeUpdate));</span><br><span class="line">ranges.forEach(<span class="function">(<span class="params">range</span>) =&gt;</span></span><br><span class="line">  range.addEventListener(<span class="string">&quot;mousemove&quot;</span>, handleRangeUpdate)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>ranges</code> 객체는 볼륨, 배속 조절 2가지 태그를 모두 포함한다. <code>mousemove</code>에도 이벤트를 거는 이유는 드래그 상태로 움직일 때 실시간으로 바꿔야 하니까.</p><h3 id="재생-진행바-시간-조절"><a href="#재생-진행바-시간-조절" class="headerlink" title="재생 진행바 (시간 조절)"></a>재생 진행바 (시간 조절)</h3><p>우선 재생 진행바를 클릭할 때 해당 위치로 재생 시간을 조절하기 위해 <code>scrub</code> 함수를 작성한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrub</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> scrubTime = (e.offsetX / progress.offsetWidth) * video.duration;</span><br><span class="line">  video.currentTime = scrubTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이벤트를 받는 DOM 객체의 x 좌표와 가로 크기, 비디오 재생 시간으로 재생 시간을 설정한다. 이 함수는 마우스 드래그, 클릭 이벤트에 모두 적용되어야 한다.</p><h4 id="이벤트-걸기-4"><a href="#이벤트-걸기-4" class="headerlink" title="이벤트 걸기"></a>이벤트 걸기</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mousedown = <span class="literal">false</span>;</span><br><span class="line">progress.addEventListener(<span class="string">&quot;click&quot;</span>, scrub);</span><br><span class="line">progress.addEventListener(<span class="string">&quot;mousemove&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> mousedown &amp;&amp; scrub(e));</span><br><span class="line">progress.addEventListener(<span class="string">&quot;mousedown&quot;</span>, <span class="function">() =&gt;</span> (mousedown = <span class="literal">true</span>));</span><br><span class="line">progress.addEventListener(<span class="string">&quot;mouseup&quot;</span>, <span class="function">() =&gt;</span> (mousedown = <span class="literal">false</span>));</span><br></pre></td></tr></table></figure><p>여기서 <code>mousedown &amp;&amp; scrub(e)</code>은 <code>mousemove</code> 이벤트일 때 <code>mousedown</code>이면 <code>scrub</code> 함수를 실행한다. 신박하다.</p><h3 id="재생-진행바-업데이트"><a href="#재생-진행바-업데이트" class="headerlink" title="재생 진행바 (업데이트)"></a>재생 진행바 (업데이트)</h3><p>이제 재생이 진행될 때 진행바도 같이 올라가면 끝이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleProgress</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> percent = (video.currentTime / video.duration) * <span class="number">100</span>;</span><br><span class="line">  progressBar.style.flexBasis = <span class="string">`<span class="subst">$&#123;percent&#125;</span>%`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="이벤트-걸기-5"><a href="#이벤트-걸기-5" class="headerlink" title="이벤트 걸기"></a>이벤트 걸기</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">video.addEventListener(<span class="string">&quot;timeupdate&quot;</span>, handleProgress);</span><br></pre></td></tr></table></figure><p>현재 재생 시간이 바뀔 때 마다 발생하는 <code>timeupdate</code>라는 이벤트도 있다.(있더라)</p><h2 id="응용"><a href="#응용" class="headerlink" title="응용"></a>응용</h2><h3 id="전체화면-만들기"><a href="#전체화면-만들기" class="headerlink" title="전체화면 만들기"></a>전체화면 만들기</h3><p><img src="/images/2020-08-26-02-04-41.png"></p><p>전체화면 만들기도 마지막에 해보라고 해서 만들어봤다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fullButton = player.querySelector(<span class="string">&quot;#fullscreen&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleFullScreen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (video.requestFullScreen) &#123;</span><br><span class="line">    video.requestFullScreen();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (video.webkitRequestFullScreen) &#123;</span><br><span class="line">    video.webkitRequestFullScreen();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (video.mozRequestFullScreen) &#123;</span><br><span class="line">    video.mozRequestFullScreen();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fullButton.addEventListener(<span class="string">&quot;click&quot;</span>, toggleFullScreen);</span><br></pre></td></tr></table></figure><p>구글링하니까 <code>requestFullScreen</code> 이라는 메소드가 있었고, 이벤트 거는건 어렵지 않았다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day-11-Custom-Video-Player&quot;&gt;&lt;a href=&quot;#Day-11-Custom-Video-Player&quot; class=&quot;headerlink&quot; title=&quot;Day 11 - Custom Video Player&quot;&gt;&lt;/a&gt;Day 11</summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="javascript30" scheme="https://zinirun.github.io/tags/javascript30/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - 정렬 (선택/삽입/퀵/계수/Python sort lambda)</title>
    <link href="https://zinirun.github.io/2020/08/24/ps-summary-sort-1/"/>
    <id>https://zinirun.github.io/2020/08/24/ps-summary-sort-1/</id>
    <published>2020-08-24T13:16:03.000Z</published>
    <updated>2020-08-24T14:43:04.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="정렬-알고리즘"><a href="#정렬-알고리즘" class="headerlink" title="정렬 알고리즘"></a>정렬 알고리즘</h1><p>정렬이란 데이터를 특정한 기준에 따라 순서대로 나열하는 것이다. 이진탐색의 전처리 과정이기도 하고, PS(Problem Solving)에서 빠지지 않는 유형의 알고리즘이다. 나는 선택 정렬은 검색 없이도 구현할 수 있었지만 삽입, 퀵, 계수 정렬은 직접 코딩하기엔 애매한 지식을 갖고 있었다. (항상 구글링해서 써먹었다) 난 알고리즘 대회 입상자가 목표가 아니라, 어느정도의 PS 실력을 갖춰 기업 코딩 테스트에 통과하는 것을 목표로 하기 때문에 각 정렬에 대한 기본적인 코드 작성, 평균 시간복잡도 정도만 인지하고 문제 풀이에 집중했다.</p><h2 id="선택-정렬"><a href="#선택-정렬" class="headerlink" title="선택 정렬"></a>선택 정렬</h2><blockquote><p>시간복잡도 - <code>O(N^2)</code></p></blockquote><p>가장 원시적인 방법으로, 매번 가장 작은 것을 선택한다는 의미에서 선택 정렬 알고리즘이라고 한다. 가장 작은 것을 선택해서 앞으로 보내는 과정을 모든 요소에 대해 반복하면 전체 데이터의 정렬이 이루어진다. 가장 무식한 방법이라고 하지만 PS를 하다보면 특정 리스트에서 가장 작은 데이터를 찾는 일이 흔하므로 선택 정렬 코드에 익숙해져야 한다.</p><h3 id="선택정렬-1"><a href="#선택정렬-1" class="headerlink" title="선택정렬 1"></a>선택정렬 1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">    min_index=i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(array)):</span><br><span class="line">        <span class="keyword">if</span> array[j]&lt;array[min_index]:</span><br><span class="line">            min_index=j</span><br><span class="line">    array[i], array[min_index] = array[min_index], array[i]</span><br><span class="line"></span><br><span class="line">print(array)</span><br></pre></td></tr></table></figure><h3 id="선택정렬-2"><a href="#선택정렬-2" class="headerlink" title="선택정렬 2"></a>선택정렬 2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(array)):</span><br><span class="line">        <span class="keyword">if</span> array[i]&gt;array[j]:</span><br><span class="line">            array[i], array[j] = array[j], array[i]</span><br><span class="line"></span><br><span class="line">print(array)</span><br></pre></td></tr></table></figure><h2 id="삽입-정렬"><a href="#삽입-정렬" class="headerlink" title="삽입 정렬"></a>삽입 정렬</h2><blockquote><p>시간복잡도 - 최선(정렬된 상태): <code>O(N)</code>, 최악: <code>O(N^2)</code></p></blockquote><p>삽입 정렬은 특정한 데이터를 적절한 위치에 삽입한다는 의미에서 삽입정렬이라고 한다. 특정한 데이터가 적절한 위치에 들어가기 전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다. 정렬된 리스트에서 적절한 위치를 찾은 뒤에, 그 위치에 삽입된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(array)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> array[j] &lt; array[j<span class="number">-1</span>]:</span><br><span class="line">            array[j], array[j<span class="number">-1</span>]=array[j<span class="number">-1</span>], array[j]</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(array)</span><br></pre></td></tr></table></figure><p>일반적인 경우(위 처럼)에 인덱스 0인 요소를 기준으로 잡아 1부터의 요소부터 적절한 위치를 판단한다.</p><h2 id="퀵-정렬"><a href="#퀵-정렬" class="headerlink" title="퀵 정렬"></a>퀵 정렬</h2><blockquote><p>시간복잡도 - 평균: <code>O(NlogN)</code>, 최악: <code>O(N^2)</code></p></blockquote><div class="video-container"><iframe src="https://www.youtube.com/embed/Hoixgm4-P4M" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>퀵 정렬은 가장 많이 사용되는 알고리즘이다. 병합정렬과 속도는 비슷하다. 퀵 정렬에는 피벗(pivot)이 사용된다. 큰 숫자, 작은 숫자를 교환할 때 교환하기 위한 기준이 바로 피벗이다. 사실 퀵 정렬을 글로만 이해하기는 쉽지 않고, 나는 위 영상을 참고했다.</p><h3 id="퀵-정렬-1-호어-분할-방식-정석"><a href="#퀵-정렬-1-호어-분할-방식-정석" class="headerlink" title="퀵 정렬 1 - 호어 분할 방식 (정석)"></a>퀵 정렬 1 - 호어 분할 방식 (정석)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">array, start, end</span>):</span></span><br><span class="line">    <span class="keyword">if</span> start&gt;=end: <span class="keyword">return</span></span><br><span class="line">    pivot=start</span><br><span class="line">    left=start+<span class="number">1</span></span><br><span class="line">    right=end</span><br><span class="line">    <span class="keyword">while</span> left&lt;=right:</span><br><span class="line">        <span class="keyword">while</span> left&lt;=end <span class="keyword">and</span> array[left]&lt;=array[pivot]: left+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right&gt;start <span class="keyword">and</span> array[right]&gt;=array[pivot]: right-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left&gt;right: array[right],array[pivot]=array[pivot],array[right]</span><br><span class="line">        <span class="keyword">else</span>: array[left],array[right]=array[right],array[left]</span><br><span class="line">    quick_sort(array,start,right<span class="number">-1</span>)</span><br><span class="line">    quick_sort(array,right+<span class="number">1</span>,end)</span><br><span class="line"></span><br><span class="line">quick_sort(array,<span class="number">0</span>,len(array)<span class="number">-1</span>)</span><br><span class="line">print(array)</span><br></pre></td></tr></table></figure><p>recursive 함수를 사용하는데 피벗을 기준으로 왼쪽(피봇보다 작은 데이터), 오른쪽(피봇보다 큰 데이터)로 나눠 재귀를 반복해서 하나의 정렬된 리스트로 만들어낸다.</p><h3 id="퀵-정렬-2-파이썬스러운-방식"><a href="#퀵-정렬-2-파이썬스러운-방식" class="headerlink" title="퀵 정렬 2 - 파이썬스러운 방식"></a>퀵 정렬 2 - 파이썬스러운 방식</h3><p>파이썬스럽게 바꾼 퀵 정렬 코드도 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort2</span>(<span class="params">array</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(array)&lt;=<span class="number">1</span>: <span class="keyword">return</span> array</span><br><span class="line">    pivot=array[<span class="number">0</span>]</span><br><span class="line">    tail=array[<span class="number">1</span>:] <span class="comment"># list excludes the pivot</span></span><br><span class="line">    left_=[x <span class="keyword">for</span> x <span class="keyword">in</span> tail <span class="keyword">if</span> x&lt;=pivot] <span class="comment"># left divided part</span></span><br><span class="line">    right_=[x <span class="keyword">for</span> x <span class="keyword">in</span> tail <span class="keyword">if</span> x&gt;pivot] <span class="comment"># right divided part</span></span><br><span class="line">    <span class="keyword">return</span> quick_sort2(left_)+[pivot]+quick_sort2(right_)</span><br><span class="line"></span><br><span class="line">print(quick_sort2(array))</span><br></pre></td></tr></table></figure><p>이 코드는 [퀵 정렬 1]보다는 시간 면에서 조금 비효율적이지만 더 직관적이고 기억하기 쉽다는 장점이 있다.</p><h2 id="계수정렬"><a href="#계수정렬" class="headerlink" title="계수정렬"></a>계수정렬</h2><blockquote><p>시간복잡도 - <code>O(N+K)</code></p></blockquote><p>계수 정렬 알고리즘은 특정 조건이 부합할 때만 사용할 수 있지만 매우 빠른 알고리즘이다. 간단하게 무작위로 배치된 정수 0~100까지의 데이터가 주어지면 101까지의 0으로 초기화한 배열을 만들고 정렬해야할 리스트를 순회하며 카운트하여 새로 만든 카운트용 배열의 숫자를 1씩 증가시킨다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">count=[<span class="number">0</span>]*(max(array)+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">    count[i]+=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(count)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(count[i]):</span><br><span class="line">        print(i, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><p>데이터의 범위가 한정되어 있다면 효과적으로 사용할 수 있으며 모든 알고리즘 중에서 가장 빠른 수준으로 동작한다. (비슷한 정렬 알고리즘으로 기수 정렬이 있다) 그러나 시간복잡도 면에서는 효율적이지만 같은 배열 크기 만큼의 카운트 배열을 하나 더 만들어야 하므로 공간복잡도 면에서는 비효율성을 초래할 수도 있으니 상황에 맞게 사용하자.</p><h2 id="파이썬-기본-정렬-알고리즘-sort"><a href="#파이썬-기본-정렬-알고리즘-sort" class="headerlink" title="파이썬 기본 정렬 알고리즘 sort()"></a>파이썬 기본 정렬 알고리즘 <code>sort()</code></h2><blockquote><p>시간복잡도 - <code>O(NlogN)</code></p></blockquote><p>파이썬의 기본 정렬 라이브러리인 <code>sort()</code>는 병합 정렬을 기반으로 만들어졌고, 시간복잡도는 <code>O(NlogN)</code>을 보장한다.</p><p>기본적인 사용법은 <code>sort(배열)</code>이며 배열 요소가 2개 이상인 경우 다음과 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">5</span>, <span class="number">1</span>), (<span class="number">5</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">b=sorted(a)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">c=sorted(a, key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">d=sorted(a, key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">e=sorted(a, key=<span class="keyword">lambda</span> x:(x[<span class="number">0</span>],x[<span class="number">1</span>]))</span><br><span class="line">print(e)</span><br></pre></td></tr></table></figure><p><code>lambda</code>를 이용하면 배열 요소의 특정 인덱스를 기준으로 정렬 기준을 정할 수 있다. 마지막 <code>e</code>는 인덱스 0을 기준으로 정렬하고, 인덱스 1인 기준으로 정렬하는 <code>lambda</code> 사용의 예시이다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;정렬-알고리즘&quot;&gt;&lt;a href=&quot;#정렬-알고리즘&quot; class=&quot;headerlink&quot; title=&quot;정렬 알고리즘&quot;&gt;&lt;/a&gt;정렬 알고리즘&lt;/h1&gt;&lt;p&gt;정렬이란 데이터를 특정한 기준에 따라 순서대로 나열하는 것이다. 이진탐색의 전처리 과정이기</summary>
      
    
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/tags/algorithm/"/>
    
    <category term="ps" scheme="https://zinirun.github.io/tags/ps/"/>
    
  </entry>
  
</feed>
