<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zinirun</title>
  
  <subtitle>tech blog by Zini</subtitle>
  <link href="https://zinirun.github.io/feed.xml" rel="self"/>
  
  <link href="https://zinirun.github.io/"/>
  <updated>2020-12-02T06:57:25.577Z</updated>
  <id>https://zinirun.github.io/</id>
  
  <author>
    <name>zini</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node.js - 바람직한 비밀번호 암호화 (crypto)</title>
    <link href="https://zinirun.github.io/2020/12/02/node-crypto-password/"/>
    <id>https://zinirun.github.io/2020/12/02/node-crypto-password/</id>
    <published>2020-12-02T06:26:19.000Z</published>
    <updated>2020-12-02T06:57:25.577Z</updated>
    
    <content type="html"><![CDATA[<p>비밀번호를 있는 그대로 데이터베이스에 저장하는 개발자는 테러리스트와 같다. 로컬 환경에서 테스트할 목적이라면 모르겠지만, 외부에 배포되는 순간 회원가입 로직이 있다면 무조건 암호화할 의무가 있다. 물론 데이터베이스가 안 뚫리는 것이 가장 이상적이지만, 생명보험을 들어놓는 것과 같다.</p><h3 id="단방향-암호화와-양방향-암호화"><a href="#단방향-암호화와-양방향-암호화" class="headerlink" title="단방향 암호화와 양방향 암호화"></a>단방향 암호화와 양방향 암호화</h3><p>간단하게 설명하자면 단방향은 암호화할 수는 있어도 복호화해서 원래의 비밀번호를 알 수 없고, 양방향은 복호화해서 원래의 비밀번호를 알 수 있다. 대부분의 사이트는 비밀번호를 찾을 때 원래의 비밀번호를 알려주는 것이 아닌 재설정한다. 그렇다. 굳이 복호화할 이유가 없다.</p><p>단방향 암호화는 Hash 알고리즘을 사용한다. 임의의 문자열을 고정된 길이의 다른 문자열로 변경하는 것이다. 비밀번호가 123, 123456으로 길이가 달라도 Hash 알고리즘에서 길이를 5로 설정했다면 비밀번호는 abfe1, bf3sj처럼 5글자로 변경된다.</p><h3 id="Crypto-vs-Bcrypt"><a href="#Crypto-vs-Bcrypt" class="headerlink" title="Crypto vs Bcrypt"></a>Crypto vs Bcrypt</h3><p>Crypto 관련 글을 검색하다가 Bcrypt라는 모듈도 있다는 것을 알게 되었다. 그러나 Bcrypt는 Blowfish 알고리즘을 사용하기 때문에 해싱에 엄청난 비용이 든다고 한다. 만약 해커가 브루트 포스같은 공격을 해대면 뚫리지는 않을지라도 서버에 엄청난 부하가 가해진다.</p><p>Crypto 모듈이 Node 기본 모듈로 들어간 이유가 다 있다고 생각하고 순수하게 Crypto만을 사용해서 바람직한 암호화를 하기로 했다.</p><h3 id="해서는-안될-암호화"><a href="#해서는-안될-암호화" class="headerlink" title="해서는 안될 암호화"></a>해서는 안될 암호화</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> base64crypto = <span class="function"><span class="params">password</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(crypto.createHash(<span class="string">&#x27;sha512&#x27;</span>).update(password).digest(<span class="string">&#x27;base64&#x27;</span>))</span><br><span class="line">base64crypto(<span class="string">&#x27;1234&#x27;</span>)</span><br><span class="line">base64crypto(<span class="string">&#x27;1234&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위에서 작성한 <code>base64crypto</code> 함수는 sha-512 알고리즘으로 해싱한 암호화된 문자열을 뱉어주지만 서로 다른 유저가 ‘1234’, ‘1234’ 비밀번호로 회원가입을 했다고 가정하면, 둘의 암호화된 비밀번호가 같아진다. 해커는 이를 통해 비밀번호를 유추할 수 있다. (이를 찾은 문자열의 목록을 레인보우 테이블이라고 한다)</p><h3 id="Salt-암호화"><a href="#Salt-암호화" class="headerlink" title="Salt 암호화"></a>Salt 암호화</h3><p>보안에 완벽이라고 단언할 암호화는 없지만 현재로서는 가장 안전하다고 여겨지는 Salting과 Key Stretching을 이용하여 강력한 암호화를 할 수 있다.</p><p>Salting은 말 그대로 Salt, 소금을 뿌리는 것이다. 기존의 문자열에 salt를 붙여 새로운 문자열을 반환한다.</p><p>Key Stretching은 기존 문자열의 다이제스트를 생성하고 생성된 다이제스트로 다시 다이제스트를 생성한다. 키 스트레칭을 999번한 비밀번호와 1000번한 비밀번호는 생김새가 완전히 다르다.</p><p>우선 암호화가 필요한 테이블에 salt 컬럼을 추가하자. 비밀번호와 별도로 같이 저장될 랜덤 문자열이고, 로그인 시 <code>password</code> 컬럼과 <code>salt</code> 컬럼을 통해서 유저가 입력한 암호를 다시 암호화하는 로직이다.</p><h4 id="회원가입에-적용하기"><a href="#회원가입에-적용하기" class="headerlink" title="회원가입에 적용하기"></a>회원가입에 적용하기</h4><p>꽤 괜찮다고 생각되는 함수를 작성해보았다.</p><h5 id="createSalt"><a href="#createSalt" class="headerlink" title="createSalt"></a>createSalt</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createSalt = <span class="function">() =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        crypto.randomBytes(<span class="number">64</span>, <span class="function">(<span class="params">err, buf</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">            resolve(buf.toString(<span class="string">&#x27;base64&#x27;</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>우선 Crypto 모듈의 randomBytes 메소드를 통해 Salt를 반환하는 함수를 작성한다.</p><h5 id="createHashedPassword"><a href="#createHashedPassword" class="headerlink" title="createHashedPassword"></a>createHashedPassword</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createHashedPassword = <span class="function">(<span class="params">plainPassword</span>) =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="keyword">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> salt = <span class="keyword">await</span> createSalt();</span><br><span class="line">        crypto.pbkdf2(plainPassword, salt, <span class="number">9999</span>, <span class="number">64</span>, <span class="string">&#x27;sha512&#x27;</span>, <span class="function">(<span class="params">err, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">            resolve(&#123; <span class="attr">password</span>: key.toString(<span class="string">&#x27;base64&#x27;</span>), salt &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>이제 암호화가 안된 비밀번호를 인자로 받아 위에서 작성한 <code>createSalt</code> 함수로 salt를 생성하고 sha-512로 해싱한 암호화된 비밀번호가 생성된다. 이 함수는 <code>password</code>와 <code>salt</code> 모두를 반환하고 데이터베이스에 둘 다 넣어주면 된다. 키 스트레칭은 9999로 해놓았는데 딱 맞아 떨어지는 숫자말고 적당히 큰 수를 넣어줘도 상관없다.</p><p>예를 들어,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; password, salt &#125; = <span class="keyword">await</span> createHashedPassword(req.body.user.password);</span><br></pre></td></tr></table></figure><p>이런식으로 암호화된 비밀번호와 salt를 생성해서 가져온 후,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> models.user</span><br><span class="line">            .create(&#123;</span><br><span class="line">                ...req.body.user,</span><br><span class="line">                password,</span><br><span class="line">                salt,</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><p>이렇게 DB에 넣어주면 된다.</p><p>회원가입 로직은 이렇게 구현하면 끝이다.</p><h5 id="makePasswordHashed"><a href="#makePasswordHashed" class="headerlink" title="makePasswordHashed"></a>makePasswordHashed</h5><p>이제 로그인 로직이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makePasswordHashed = <span class="function">(<span class="params">userId, plainPassword</span>) =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="keyword">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">        <span class="comment">// salt를 가져오는 부분은 각자의 DB에 따라 수정</span></span><br><span class="line">        <span class="keyword">const</span> salt = <span class="keyword">await</span> models.user</span><br><span class="line">            .findOne(&#123;</span><br><span class="line">                attributes: [<span class="string">&#x27;salt&#x27;</span>],</span><br><span class="line">                raw: <span class="literal">true</span>,</span><br><span class="line">                where: &#123;</span><br><span class="line">                    userId,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">result</span>) =&gt;</span> result.salt);</span><br><span class="line">        crypto.pbkdf2(plainPassword, salt, <span class="number">9999</span>, <span class="number">64</span>, <span class="string">&#x27;sha512&#x27;</span>, <span class="function">(<span class="params">err, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">            resolve(key.toString(<span class="string">&#x27;base64&#x27;</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>비밀번호와 유저 ID를 인자로 받아 패스워드를 암호화한다. 단방향 암호화 방식이기 때문에 유저가 보낸 Plain Password를 위에서 한 방식대로 그대로 암호화해서 비교하면 된다.</p><p>여기서 다른 것은 회원가입에서는 salt를 랜덤 문자열로 만들고, 로그인에서는 회원가입에서 만들어진 salt를 가져와서 해싱하는 것이다. 암호화 방식이 똑같기 때문에 키 스트레칭이나 해싱 알고리즘이 서로 다르면 안된다.</p><p>함수를 사용하는 예를 들면,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; userId, <span class="attr">password</span>: plainPassword &#125; = req.body.user;</span><br><span class="line"><span class="keyword">const</span> password = <span class="keyword">await</span> makePasswordHashed(userId, plainPassword);</span><br></pre></td></tr></table></figure><p>나는 이런식으로 사용한다. 그러면 <code>password</code>에는 비교할 암호화된 문자열이 만들어질 것이고, 각자 사용하는 데이터베이스에서 유저의 ID와 password를 비교해주면 된다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;비밀번호를 있는 그대로 데이터베이스에 저장하는 개발자는 테러리스트와 같다. 로컬 환경에서 테스트할 목적이라면 모르겠지만, 외부에 배포되는 순간 회원가입 로직이 있다면 무조건 암호화할 의무가 있다. 물론 데이터베이스가 안 뚫리는 것이 가장 이상적이</summary>
      
    
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/categories/nodejs/"/>
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/tags/nodejs/"/>
    
    <category term="crypto" scheme="https://zinirun.github.io/tags/crypto/"/>
    
  </entry>
  
  <entry>
    <title>Typescript를 시작하는 이유</title>
    <link href="https://zinirun.github.io/2020/11/23/typescript-study-1/"/>
    <id>https://zinirun.github.io/2020/11/23/typescript-study-1/</id>
    <published>2020-11-23T12:22:44.000Z</published>
    <updated>2020-11-23T12:38:45.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Typescript-공부를-시작하는-이유"><a href="#Typescript-공부를-시작하는-이유" class="headerlink" title="Typescript 공부를 시작하는 이유"></a>Typescript 공부를 시작하는 이유</h2><p>Javascript를 몇 년을 써오면서 큰 불편함은 느끼지 못했다. 그래서 Typescript는 Javascript의 가려운 부분을 긁어준다는 말을 들어도 굳이 해야하나 싶었다.</p><p>하지만 요즘 학교에서 발주한 대형 프로젝트(기술 스택은 크게 <code>Node.js</code>, <code>GraphQL</code>, <code>React</code>, <code>Apollo</code>를 사용한다)를 진행중에 타입스크립트 도입의 필요성을 느꼈다.  서버 사이드로나 클라이언트 사이드로나 자바스크립트를 사용하다 보니 모듈화된 함수가 인자로 어떤 타입을 받는지, 반환하는 값은 어떤 종류인지 찾으려고 파일들을 왔다갔다하다가, 결국 주석으로 input과 output의 값을 명시하는 작업을 하고 있다.</p><p>주석으로 명시하더라도 사람은 늘 실수를 하고, 특히나 GraphQL에서의 타입 준수는 정말 중요하기 때문에 항상 실행해보고 나서 에러를 발견하기도 한다.</p><p>그렇게 나는 타입스크립트 공부를 시작하기로 했다. <a href="https://typescript-kr.github.io/">Typescript Handbook KR</a>에 정말 잘 정리되어 있으니, 교과서로 쓰기에도 충분할 것 같다.</p><p>사실 배운 내용에 대해서 포스팅하려고 했는데, 핸드북(위 링크)에 정말 잘 나와있어서 이론을 적기 보다는 공부하다가 겪은 고난(?) 위주의 글을 적어볼 생각이다.</p><p>지금은 기본적인 자료형과, 함수 선언, 인터페이스, 타입을 1시간도 채안되서 공부했는데, 새로운 언어를 배우는 것이 아니라서 자바스크립트를 어느정도 다룰 줄 안다면 정말 빠르게 배울 수 있다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Typescript-공부를-시작하는-이유&quot;&gt;&lt;a href=&quot;#Typescript-공부를-시작하는-이유&quot; class=&quot;headerlink&quot; title=&quot;Typescript 공부를 시작하는 이유&quot;&gt;&lt;/a&gt;Typescript 공부를 시작하는 </summary>
      
    
    
    
    <category term="typescript" scheme="https://zinirun.github.io/categories/typescript/"/>
    
    
    <category term="typescript" scheme="https://zinirun.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>React Apollo Client에서 데이터가 섞이는 오류 해결(GraphQL)</title>
    <link href="https://zinirun.github.io/2020/11/10/react-apollo-graphql-data-mixed/"/>
    <id>https://zinirun.github.io/2020/11/10/react-apollo-graphql-data-mixed/</id>
    <published>2020-11-10T12:36:00.000Z</published>
    <updated>2020-11-10T12:44:17.181Z</updated>
    
    <content type="html"><![CDATA[<p>한 화면에서 다수의 컴포넌트가 모두 같은 GraphQL Query를 실행할 때 데이터가 섞이는 오류가 있었다. 처음에는 벡엔드 (<code>Node.js + GraphQL Server</code>)와 동기적으로 데이터를 주고 받을 수 없어서 그런 것 같았는데, 코드 상의 문제는 없었다.</p><p>구글링끝에 답을 찾았다. Apollo Client의 캐싱 오류였고, 클라이언트측 쿼리(gql)에 <code>__typename @skip(if: true)</code>를 붙여주면 된다.</p><p>어디에 붙이냐면, 예를 들어</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">query getRoutine($id: ID!) &#123;</span><br><span class="line">        getRoutine(id: $id) &#123;</span><br><span class="line">            day</span><br><span class="line">            dayName</span><br><span class="line">            tasks &#123;</span><br><span class="line">                id</span><br><span class="line">                name</span><br><span class="line">                time</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>나는 다음과 같은 쿼리를 동시에 요청할 때 데이터가 섞였는데,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">query getRoutine($id: ID!) &#123;</span><br><span class="line">        getRoutine(id: $id) &#123;</span><br><span class="line">            __typename @skip(<span class="keyword">if</span>: <span class="literal">true</span>)</span><br><span class="line">            day</span><br><span class="line">            dayName</span><br><span class="line">            tasks &#123;</span><br><span class="line">                id</span><br><span class="line">                __typename @skip(<span class="keyword">if</span>: <span class="literal">true</span>)</span><br><span class="line">                name</span><br><span class="line">                time</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>위를 참고하여 <code>id</code>를 조회한다면 id 밑에 넣던지, <code>id</code>를 조회하지 않는다면 그냥 제일 위에 넣으면 된다.</p><blockquote><p>출처 <a href="https://stackoverflow.com/questions/53272112/apollo-is-mixing-results-from-a-graphql-query-in-react">stackoverflow</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;한 화면에서 다수의 컴포넌트가 모두 같은 GraphQL Query를 실행할 때 데이터가 섞이는 오류가 있었다. 처음에는 벡엔드 (&lt;code&gt;Node.js + GraphQL Server&lt;/code&gt;)와 동기적으로 데이터를 주고 받을 수 없어서 그런</summary>
      
    
    
    
    <category term="ReactJS" scheme="https://zinirun.github.io/categories/ReactJS/"/>
    
    
    <category term="graphql" scheme="https://zinirun.github.io/tags/graphql/"/>
    
    <category term="react" scheme="https://zinirun.github.io/tags/react/"/>
    
    <category term="apollo" scheme="https://zinirun.github.io/tags/apollo/"/>
    
  </entry>
  
  <entry>
    <title>React CORS 이슈 해결 (XMLHttpRequest.handleError)</title>
    <link href="https://zinirun.github.io/2020/11/03/react-cors-proxy/"/>
    <id>https://zinirun.github.io/2020/11/03/react-cors-proxy/</id>
    <published>2020-11-03T08:19:12.000Z</published>
    <updated>2020-11-03T08:26:34.237Z</updated>
    
    <content type="html"><![CDATA[<p>현재 프론트엔드(React), 벡엔드(Node)를 분리하여 프로젝트를 진행중에 있다. 그래서 당연히 포트가 다르다. 나는 노드측에서 CORS 설정을 해두었기에 프론트엔드 단에서는 별 다른 설정이 필요없다고 생각했다.</p><p>그러나 노드의 응답을 리액트에서 받지 못하는 것 같았고, XMLHttpRequest 에러가 발생했다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">at createError (createError.js)</span><br><span class="line">at XMLHttpRequest.handleError (xhr.js)</span><br></pre></td></tr></table></figure><p>확인 후 알아낸 것은, React에서도 cors에 대한 설정이 필요하다는 것이다. 프록시 설정으로 간단하게 해결할 수 있다.</p><p>React의 <code>package.json</code>에</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;lazy-dolphin&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;private&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;proxy&quot;</span>: <span class="string">&quot;http://localhost:4000&quot;</span>, <span class="comment">// Proxy 추가</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br></pre></td></tr></table></figure><p><code>proxy</code>에 노드의 주소를 추가하면 된다. 프록시를 설정하면 REST 요청을 보낼 때 <code>http://localhost:4000/signup</code>이 아닌 <code>/signup</code>으로 요청해도 알아서 프록시 서버로 데이터를 주고 받으니까 편리하다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;현재 프론트엔드(React), 벡엔드(Node)를 분리하여 프로젝트를 진행중에 있다. 그래서 당연히 포트가 다르다. 나는 노드측에서 CORS 설정을 해두었기에 프론트엔드 단에서는 별 다른 설정이 필요없다고 생각했다.&lt;/p&gt;
&lt;p&gt;그러나 노드의 응</summary>
      
    
    
    
    <category term="ReactJS" scheme="https://zinirun.github.io/categories/ReactJS/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="react" scheme="https://zinirun.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>CORS에 대하여</title>
    <link href="https://zinirun.github.io/2020/10/28/node-cors/"/>
    <id>https://zinirun.github.io/2020/10/28/node-cors/</id>
    <published>2020-10-28T04:08:06.000Z</published>
    <updated>2020-10-28T04:27:38.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS(Cross Origin Resource Sharing)는 도메인/포트가 다른 서버의 자원을 요청하는 메커니즘이다. 일반적인 환경에서는 동일 출처 정책(same-origin policy)때문에 CORS 상황이 발생하면 브라우저에서 데이터 요청을 보안 목적으로 차단한다.</p><blockquote><p>동일 출처 정책(same-origin policy)은 어떤 출처에서 불러온 문서나 스크립트가 다른 출처에서 가져온 리소스와 상호작용하는 것을 제한하는 중요한 보안 방식입니다. 동일 출처 정책은 잠재적으로 해로울 수 있는 문서를 분리함으로써 공격받을 수 있는 경로를 줄여줍니다. - <a href="https://developer.mozilla.org/ko/docs/Web/Security/Same-origin_policy">MDN Web Docs</a></p></blockquote><h2 id="노드에서-해결하기"><a href="#노드에서-해결하기" class="headerlink" title="노드에서 해결하기"></a>노드에서 해결하기</h2><p>노드 서버 환경에서는 CORS 미들웨어를 사용하여 간단하게 CORS를 조정할 수 있다.</p><p>먼저 cors npm을 설치한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add cors <span class="comment"># npm install cors --save</span></span><br></pre></td></tr></table></figure><p>이제 express의 미들웨어로 cors를 등록하면 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(cors()); <span class="comment">// CORS Middleware 추가</span></span><br></pre></td></tr></table></figure><p>위와 같이 CORS 미들웨어를 적용하면 모든 Cross Domain 요청에 대해 허가하게 된다. 로컬 테스트 환경이라면 괜찮겠지만, 배포 환경에서는 보안적으로 취약해지게 된다.</p><p>그러면 CORS 요청에 대한 허가 도메인을 정해주고, 그 옵션으로 cors를 추가하면 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> corsOption = &#123;</span><br><span class="line">    origin: <span class="string">&#x27;https://zini.run&#x27;</span>, <span class="comment">// 허가 도메인</span></span><br><span class="line">    credentials: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(cors(corsOption));</span><br></pre></td></tr></table></figure><p>크로스 도메인에 대한 정보만 적절하게 조정한다면 CORS 보안 문제는 일어나지 않을 것이다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CORS&quot;&gt;&lt;a href=&quot;#CORS&quot; class=&quot;headerlink&quot; title=&quot;CORS&quot;&gt;&lt;/a&gt;CORS&lt;/h2&gt;&lt;p&gt;CORS(Cross Origin Resource Sharing)는 도메인/포트가 다른 서버의 자원을 요청하는 메</summary>
      
    
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/categories/nodejs/"/>
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/tags/nodejs/"/>
    
    <category term="cors" scheme="https://zinirun.github.io/tags/cors/"/>
    
  </entry>
  
  <entry>
    <title>Redis, Node.js에서 시작하기</title>
    <link href="https://zinirun.github.io/2020/10/28/node-redis-start/"/>
    <id>https://zinirun.github.io/2020/10/28/node-redis-start/</id>
    <published>2020-10-27T16:06:03.000Z</published>
    <updated>2020-10-27T16:25:44.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-시작하기"><a href="#Redis-시작하기" class="headerlink" title="Redis 시작하기"></a>Redis 시작하기</h2><p>노드에서 Redis 기반의 캐싱을 해보고 싶어서 기본적으로 노드 환경에서 Redis에 연결하고, 데이터를 써보고 읽는 것부터 해보기로 했다.</p><p>우선 Redis의 데이터 타입에는 Strings, Lists, Sets, Hashes가 있다. 각각 읽거나 쓰는 방법이 다르지만 정말 간단하다.</p><h2 id="Redis-환경-구축하기"><a href="#Redis-환경-구축하기" class="headerlink" title="Redis 환경 구축하기"></a>Redis 환경 구축하기</h2><p>Windows는 공식적으로 지원하지 않는다고 한다. Microsoft에서 관리하는 윈도우용 redis가 있지만 깔끔한 환경을 바로 세팅하기 위해서 Docker 기반의 Redis를 사용하기로 했다.</p><p>먼저 호스트 PC에서 Docker Terminal를 실행한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name redis-db -d -p 6379:6379 redis</span><br></pre></td></tr></table></figure><p>이제 redis 이미지를 pull하고 컨테이너로 실행한다. <code>docker ps</code>로 실행된 것을 확인해보자.</p><p><img src="/images/2020-10-28-01-14-22.png"></p><p>이제 컨테이너에 접속한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it redis-db /bin/bash</span><br></pre></td></tr></table></figure><p>redis 컨테이너로 접속했다. 이제 터미널에 <code>redis-cli</code>를 입력하면 redis를 사용할 수 있다.</p><h2 id="Node-js와-Redis-연동하기"><a href="#Node-js와-Redis-연동하기" class="headerlink" title="Node.js와 Redis 연동하기"></a>Node.js와 Redis 연동하기</h2><p>먼저 Redis npm을 먼저 설치한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add redis <span class="comment"># npm install redis</span></span><br></pre></td></tr></table></figure><p>이제 js 파일을 작성해보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> redis = <span class="built_in">require</span>(<span class="string">&quot;redis&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> client = redis.createClient();</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">&quot;error&quot;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">&quot;ready&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Redis is ready&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="connection-to-127-0-0-1-6379-failed-connect-ECONNREFUSED"><a href="#connection-to-127-0-0-1-6379-failed-connect-ECONNREFUSED" class="headerlink" title="connection to 127.0.0.1:6379 failed - connect ECONNREFUSED"></a><code>connection to 127.0.0.1:6379 failed - connect ECONNREFUSED</code></h3><p>사실 여기서 애를 많이 먹었다. 호스트의 Docker로 실행한 컨테이너의 IP로 접속을 못 하는 것 같았는데, 알고보니 Docker Machine의 IP로 접속해야 했다. 일반적인 접속 방법은 위와 같지만 호스트 환경의 도커에서 실습하는 경우 IP를 직접 설정해줘야 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> redisHost = <span class="string">&quot;192.168.99.100&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> client = redis.createClient(<span class="number">6379</span>, redisHost);</span><br></pre></td></tr></table></figure><p>이제 잘 접속된다.</p><h2 id="Redis에-값-쓰고-불러오기"><a href="#Redis에-값-쓰고-불러오기" class="headerlink" title="Redis에 값 쓰고 불러오기"></a>Redis에 값 쓰고 불러오기</h2><p><code>client</code>에 redis의 클라이언트를 정의해놨으므로 이제 <code>client</code>에서 redis 명령어를 그대로 사용할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fruit &#123;</span><br><span class="line">    lemon: <span class="number">5000</span>,</span><br><span class="line">    green: <span class="number">2000</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 Hash 값을 redis에 저장해보자. Redis에서 Hash를 저장하는 명령어인 <code>hmset</code>을 그대로 사용한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client.hmset(<span class="string">&quot;fruit&quot;</span>, &#123;</span><br><span class="line">  lemon: <span class="number">5000</span>,</span><br><span class="line">  green: <span class="number">2000</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이제 이 값을 가져와보자. Hash 데이터의 전체 값을 가져올 수 있는 <code>hgetall</code> 명령어를 사용하면 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client.hgetall(<span class="string">&quot;fruit&quot;</span>, <span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="/images/2020-10-28-01-23-37.png"></p><p>실행하면, 값이 잘 출력된다.</p><p>명령어마다 어떤 콜백이 나오는지 모르면 <a href="https://www.npmjs.com/package/redis">npmjs</a> 공식 문서가 잘 되어 있으니, 참조하면 된다.</p><p>(정말) 간단하게 Redis를 Node에서 다뤄봤는데, 이제 세션 스토어나 캐싱을 해볼 생각이다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis-시작하기&quot;&gt;&lt;a href=&quot;#Redis-시작하기&quot; class=&quot;headerlink&quot; title=&quot;Redis 시작하기&quot;&gt;&lt;/a&gt;Redis 시작하기&lt;/h2&gt;&lt;p&gt;노드에서 Redis 기반의 캐싱을 해보고 싶어서 기본적으로 노드 환경</summary>
      
    
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/categories/nodejs/"/>
    
    <category term="redis" scheme="https://zinirun.github.io/categories/nodejs/redis/"/>
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/tags/nodejs/"/>
    
    <category term="docker" scheme="https://zinirun.github.io/tags/docker/"/>
    
    <category term="redis" scheme="https://zinirun.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL 시뮬레이터, graphql-crud-demo 제작기</title>
    <link href="https://zinirun.github.io/2020/10/27/graphql-crud-demo/"/>
    <id>https://zinirun.github.io/2020/10/27/graphql-crud-demo/</id>
    <published>2020-10-27T07:52:22.000Z</published>
    <updated>2020-10-27T08:04:19.575Z</updated>
    
    <content type="html"><![CDATA[<p>시험 기간에 머리 식힐 겸(?) 만들어 본 간단한 GraphQL 시뮬레이터를 만들었다. GraphQL 자체가 간결해서 그런지 순 제작시간은 5시간정도 걸린 것 같다.</p><p>그럴듯한 Readme 마크다운도 만들었는데, 설명은 이것으로 대체한다. 세부적인 CRUD API 구축 방법은 <a href="https://zinirun.github.io/2020/10/27/graphql-crud-sample/">이전 포스팅 - GraphQL로 CRUD 만들기</a>에서 볼 수 있다.</p><blockquote><p><a href="https://gql-crud.herokuapp.com/">여기</a>에서 샘플을 볼 수 있다. 헤로쿠로 호스팅해서 초반 로딩 속도는 조금 걸린다.</p></blockquote><h1 id="graphql-crud-demo"><a href="#graphql-crud-demo" class="headerlink" title="graphql-crud-demo"></a>graphql-crud-demo</h1><p>GraphQL CRUD Operations in Node.js, Axios, VanillaJS</p><img src="https://github.com/zinirun/graphql-crud-demo/blob/main/img/readme.png?raw=true" alt="gql-crud-page-sample" /><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/zinirun/graphql-crud-demo</span><br><span class="line">$ <span class="built_in">cd</span> ./graphql-crud-demo</span><br><span class="line">$ npm install <span class="comment"># yarn install</span></span><br></pre></td></tr></table></figure><h2 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h2><h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutation addProduct($input: ProductInput) &#123;</span><br><span class="line">    addProduct(input: $input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; getProduct(id : ?) &#123; id price name description&#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutation updateProduct($id: ID!, $input: ProductInput!)&#123;</span><br><span class="line">    updateProduct(id: $id, <span class="attr">input</span>: $input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutation deleteProduct&#123;</span><br><span class="line">    deleteProduct(id: $&#123;id&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Also-supports"><a href="#Also-supports" class="headerlink" title="Also supports"></a>Also supports</h3><ul><li>Get all items</li><li>Debouncing Search (customized timer)</li><li>Set data-set default</li></ul><h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><ul><li>GraphQL Server<ul><li><code>/src/schema.js</code> - Build-Schema defined</li><li><code>/src/rootValue.js</code> - Mutations and queries implemented</li><li><code>/src/products.js</code> - Shared data accessed from gql</li><li><code>/src/defaultProducts.js</code> - Default data-set</li></ul></li><li>Express<ul><li><code>/app.js</code> - Express instance defined</li><li><code>/server.js</code> - Server started from <code>/app.js</code></li></ul></li><li>Client<ul><li><code>/static/mod.js</code> - DOM Initialized, all events added</li><li><code>/static/crud.js</code> - Events implemented</li><li><code>/static/graphiql.js</code> - Iframe for GraphiQL(GUI)</li></ul></li></ul><p>Hard-coded dataset <code>/src/defaultProducts.js</code> can be replaced by with Redis, etc…</p><blockquote><p>사실 만들고 아무 생각 없이 Netlify로 만들다가 왜 안되나 했는데 저번에 그렇게 삽질했던 “Netlify는 정적 호스팅을 위한 서비스”라는게 떠올라서 부랴부랴 헤로쿠로 배포했다. 리액트를 조금 더 배워 React + Apollo + GraphQL + Redis 서비스를 배포해 봐야겠다.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;시험 기간에 머리 식힐 겸(?) 만들어 본 간단한 GraphQL 시뮬레이터를 만들었다. GraphQL 자체가 간결해서 그런지 순 제작시간은 5시간정도 걸린 것 같다.&lt;/p&gt;
&lt;p&gt;그럴듯한 Readme 마크다운도 만들었는데, 설명은 이것으로 대체한</summary>
      
    
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/categories/nodejs/"/>
    
    <category term="graphql" scheme="https://zinirun.github.io/categories/nodejs/graphql/"/>
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/tags/nodejs/"/>
    
    <category term="graphql" scheme="https://zinirun.github.io/tags/graphql/"/>
    
  </entry>
  
  <entry>
    <title>Node.js - GraphQL로 CRUD 만들기</title>
    <link href="https://zinirun.github.io/2020/10/27/graphql-crud-sample/"/>
    <id>https://zinirun.github.io/2020/10/27/graphql-crud-sample/</id>
    <published>2020-10-27T07:16:15.000Z</published>
    <updated>2020-10-27T07:51:33.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="REST-API-VS-GraphQL"><a href="#REST-API-VS-GraphQL" class="headerlink" title="REST API VS GraphQL"></a>REST API VS GraphQL</h2><p>REST API로만 벡엔드 서버 API를 구현한 나로서는 굳이 GraphQL이란 것을 알아야할까 싶었다. 이 생각은 GraphQL로 간단한 프로젝트를 만들어 보며 완전히 바뀌게 되었다.</p><div class="video-container"><iframe src="https://www.youtube.com/embed/EkWI6Ru8lFQ" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>11분동안 정말 재밌게 설명해주신 유튜버가 있어 REST와 GraphQL에 대한 긴 설명은 이것으로 대체한다.</p><p>뭘 써야할 지 모르겠다면 GraphQL, Rest API 모두 만들어서 필요한 작업마다 다르게 써먹으면 된다. 일반적으로 파일 전송같은 경우 RESTful이 더 유리하다고 하고, CRUD 작업이 대부분이라면 GraphQL이 훨씬 편하다.</p><h2 id="Node-js에서-GraphQL-구축하기"><a href="#Node-js에서-GraphQL-구축하기" class="headerlink" title="Node.js에서 GraphQL 구축하기"></a>Node.js에서 GraphQL 구축하기</h2><p>우선 express에서 GraphQL을 사용하기 위해 관련 패키지를 설치한다. (물론 express 세팅은 끝난 가정하이다)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add graphql</span><br><span class="line">$ yarn add express-graphql</span><br></pre></td></tr></table></figure><p>간단하게 GraphQL은 스키마 + 리졸버로 구성된다. 스키마 안에 변수나 함수를 정의하고, 리졸버에서 함수를 구현하면 된다.</p><p>우선 스키마를 정의하자. 나는 모듈화를 위해 파일을 용도에 맞게 쪼개서 쓰기로 했다.</p><h3 id="스키마-만들기"><a href="#스키마-만들기" class="headerlink" title="스키마 만들기"></a>스키마 만들기</h3><p><code>schema.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; buildSchema &#125; = <span class="built_in">require</span>(<span class="string">&#x27;graphql&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = buildSchema(<span class="string">`</span></span><br><span class="line"><span class="string">    input ProductInput &#123;</span></span><br><span class="line"><span class="string">    name: String,</span></span><br><span class="line"><span class="string">    price: Int,</span></span><br><span class="line"><span class="string">    description: String</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    type Product &#123;</span></span><br><span class="line"><span class="string">        id: ID!,</span></span><br><span class="line"><span class="string">        name: String,</span></span><br><span class="line"><span class="string">        price: Int,</span></span><br><span class="line"><span class="string">        description: String</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    type Query &#123;</span></span><br><span class="line"><span class="string">        getProduct(id: ID!): Product</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    type Mutation &#123;</span></span><br><span class="line"><span class="string">        addProduct(input: ProductInput): Int</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure><p>먼저 <code>type Query</code>와 <code>type Mutation</code>을 보자. 일반적으로 GET 작업은 Query로, POST 작업은 Mutation으로 정의한다.</p><h4 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h4><p><code>getProduct</code>라는 함수는 <code>ID</code> 유형의 <code>id</code> 변수를 인자로 받고, <code>Product</code> 객체를 반환한다는 의미이다. (여기서 <code>ID</code>는 MySQL에서의 일반적인 PK로 생각하면 된다)</p><p>이제 반환할 <code>Product</code> 객체에 뭐가 들었는지 <code>type Product</code>로 정의해주면 된다. 나만의 자료형을 만든다고 생각하면 쉽다.</p><p>참고로 <code>!</code>가 붙은 변수는 무조건 해당 인자는 받아야 한다는 <code>required</code>의 의미와 비슷한 표시이다.</p><h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><p><code>addProduct</code>는 말그대로 POST 메소드로 상품을 등록하는 함수이다. 입력값이 <code>ProductInput</code>으로 되어 있는데, <code>Product</code> type을 만들 때와 비슷하게 클라이언트의 입력 값을 미리 정의해둔 것이다. (일반적으로 뒤에 <code>Input</code>을 붙인다고 한다)</p><h3 id="Resolver-만들기"><a href="#Resolver-만들기" class="headerlink" title="Resolver 만들기"></a>Resolver 만들기</h3><p>이제 <code>getProduct</code>와 <code>addProduct</code>의 함수를 구현하면 거의 끝이다.</p><p><code>rootValue.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> products = <span class="built_in">require</span>(<span class="string">&#x27;./products&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> defaultProducts = <span class="built_in">require</span>(<span class="string">&#x27;./defaultProducts&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    getProduct: <span class="function">(<span class="params">&#123; id &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> products.find(<span class="function">(<span class="params">product</span>) =&gt;</span> product.id === <span class="built_in">parseInt</span>(id));</span><br><span class="line">    &#125;,</span><br><span class="line">    addProduct: <span class="function">(<span class="params">&#123; input &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        input.id = products.length === <span class="number">0</span> ? <span class="number">1</span> : products[products.length - <span class="number">1</span>].id + <span class="number">1</span>;</span><br><span class="line">        products.push(input);</span><br><span class="line">        <span class="keyword">return</span> input.id;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>나는 <code>products</code>라는 데이터 배열을 모듈화하여 사용하였다. 스키마에서 선언한 인자를 그대로 받아 적절한 함수를 짜고, 미리 정해놓은 리턴 자료형대로 반환하면 된다.</p><h3 id="Express로-라우팅하기"><a href="#Express로-라우팅하기" class="headerlink" title="Express로 라우팅하기"></a>Express로 라우팅하기</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.app.use(</span><br><span class="line">            <span class="string">&#x27;/graphql&#x27;</span>,</span><br><span class="line">            graphqlHTTP(&#123;</span><br><span class="line">                schema,</span><br><span class="line">                rootValue,</span><br><span class="line">                graphiql: <span class="literal">true</span>, <span class="comment">// support GUI</span></span><br><span class="line">            &#125;),</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>이제 <code>/graphql</code>이라는 경로로 GraphQL API를 라우팅하면 모든 구축이 끝난다. 스키마는 <code>schema</code>로, 리졸버는 <code>rootValue</code>라는 값으로 받는다. (그렇기 때문에 난 파일 이름을 똑같이 만들었다) <code>graphiql</code>은 URL에서 <code>/graphql</code>로 접속했을 때 쿼리와 뮤테이션을 써볼 수 있는 GUI 환경을 제공한다. 당연히 보안을 위해 배포시에는 <code>graphiql</code>을 <code>false</code>로 세팅해야 한다.</p><h2 id="클라이언트에서-데이터-주고-받기"><a href="#클라이언트에서-데이터-주고-받기" class="headerlink" title="클라이언트에서 데이터 주고 받기"></a>클라이언트에서 데이터 주고 받기</h2><p>이제 쿼리와 뮤테이션을 각각 GET, POST 요청으로 데이터를 주고 받을 수 있다. <code>fetch</code>, <code>axios</code> 등 방법은 많은데 <code>fetch</code>는 브라우저 호환에 문제가 있다고 하여 <code>axios</code>를 사용하기로 했다.</p><h3 id="GET-요청"><a href="#GET-요청" class="headerlink" title="GET 요청"></a>GET 요청</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> apiUri = <span class="string">&#x27;http://localhost:3000/graphql&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProduct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    axios</span><br><span class="line">        .get(apiUri, &#123;</span><br><span class="line">            params: &#123;</span><br><span class="line">                query: <span class="string">`&#123;getProduct(id : <span class="subst">$&#123;pid.value&#125;</span>) &#123;id price name description&#125;&#125;`</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(result)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스키마에서 짜놓은 형식대로 쿼리를 GET으로 넘기면 된다. axios 자체적으로 promise를 지원하기 때문에 then, catch를 사용하면 에러 핸들링이 수월하다. 이제 <code>result</code>를 가지고 데이터를 가공하여 클라이언트에게 제공할 수 있다.</p><h3 id="POST-요청"><a href="#POST-요청" class="headerlink" title="POST 요청"></a>POST 요청</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postProduct</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    axios</span><br><span class="line">        .post(apiUri, &#123;</span><br><span class="line">            query: <span class="string">&#x27;mutation addProduct($input: ProductInput) &#123; addProduct(input: $input)&#125;&#x27;</span>,</span><br><span class="line">            variables: &#123;</span><br><span class="line">                input: &#123;</span><br><span class="line">                    price: <span class="built_in">parseInt</span>(<span class="built_in">this</span>.price.value),</span><br><span class="line">                    name: <span class="built_in">String</span>(<span class="built_in">this</span>.name.value),</span><br><span class="line">                    description: <span class="built_in">String</span>(<span class="built_in">this</span>.description.value),</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            operationName: <span class="literal">null</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(result);</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GET과 방식은 거의 똑같은데, POST 메소드이므로 <code>params</code>가 아닌 <code>query</code>를 넘긴다. <code>$</code>를 사용하여 변수를 <code>variables</code>로 빼서 사용할 수도 있고, 백틱을 사용해서 하드코딩해도 상관은 없다.</p><h2 id="매력적인-GraphQL"><a href="#매력적인-GraphQL" class="headerlink" title="매력적인 GraphQL"></a>매력적인 GraphQL</h2><p>사실 기존의 서버 API를 바꾸는 것은 많은 시간과 노력이 든다. 하지만 REST API와 GraphQL를 한번에 사용할 수도 있으므로 클라이언트(프론트엔드) 부분만 살짝 손대주면 나중을 생각할 때 훨씬 간결한 CRUD 환경을 구축할 수 있다. 현재도 폭발적인 인기를 받아 많은 발전이 이뤄지고 있다고 한다.</p><p>GraphQL의 CRUD 작업을 시뮬레이션할 수 있는 서비스 <code>graphql-crud-demo</code> 를 개발했는데, 다음 글에 포스팅해보겠다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;REST-API-VS-GraphQL&quot;&gt;&lt;a href=&quot;#REST-API-VS-GraphQL&quot; class=&quot;headerlink&quot; title=&quot;REST API VS GraphQL&quot;&gt;&lt;/a&gt;REST API VS GraphQL&lt;/h2&gt;&lt;p&gt;RE</summary>
      
    
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/categories/nodejs/"/>
    
    <category term="graphql" scheme="https://zinirun.github.io/categories/nodejs/graphql/"/>
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/tags/nodejs/"/>
    
    <category term="graphql" scheme="https://zinirun.github.io/tags/graphql/"/>
    
  </entry>
  
  <entry>
    <title>클러스터 인덱스 vs 넌클러스터 인덱스</title>
    <link href="https://zinirun.github.io/2020/10/23/database-index/"/>
    <id>https://zinirun.github.io/2020/10/23/database-index/</id>
    <published>2020-10-23T00:11:37.000Z</published>
    <updated>2020-10-23T01:17:39.511Z</updated>
    
    <content type="html"><![CDATA[<p>학과 공부와 시험을 준비하다가 클러스터 인덱스와 넌클러스터 인덱스를 정리해 본다.</p><h2 id="개념"><a href="#개념" class="headerlink" title="개념"></a>개념</h2><p>영어 사전을 생각해보자. 기본적으로 A~Z 알파벳 순으로 책 자체가 정렬되어 있다. 이건 <strong>클러스터 인덱스</strong>이다. 사전 마지막에는 “색인”이 있는데, 필요한 단어를 찾고, 거기에 적힌 페이지로 간다. 이게 <strong>넌클러스터 인덱스</strong>이다.</p><h3 id="클러스터-인덱스"><a href="#클러스터-인덱스" class="headerlink" title="클러스터 인덱스"></a>클러스터 인덱스</h3><ul><li>테이블 당 1개만 허용</li><li>기본 키 설정시 자동으로 만들어짐</li><li>테이블 자체가 인덱스 (클러스터 인덱스를 기준으로 테이블을 정렬하기 때문에 인덱스 페이지가 없다)</li><li>데이터 입력, 수정, 삭제 시 항상 정렬을 유지함</li><li>기본적으로 접근 성능이 좋음</li></ul><h3 id="넌클러스터-인덱스"><a href="#넌클러스터-인덱스" class="headerlink" title="넌클러스터 인덱스"></a>넌클러스터 인덱스</h3><ul><li>테이블 당 최대 240개 생성 가능</li><li>인덱스 페이지를 별도로 저장</li><li>테이블 자체는 정렬되지 않고, 인덱스 페이지에만 정렬</li><li>성능 증가는 정말 “Case By Case”</li></ul><p>부가적으로 설명하자면, <strong>클러스터 인덱스</strong>는 항상 정렬을 유지하기 때문에 기본적으로 성능이 보장된다. AUTO_INCREMENT 같은 id에 클러스터 인덱스가 있어도 조회 성능이 향상된다. 하지만 테이블을 정렬 상태로 유지해야하므로 데이터를 입력, 수정, 삭제하는 경우에 즉각 정렬이 일어나기 때문에 느려진다. Trade Off라고 생각하면 된다. 따라서 DML 작업이 자주 일어나는 테이블에 클러스터 인덱스는 정말 신중하게 결정해야 한다.</p><p><strong>넌클러스터 인덱스</strong>는 DML 작업이 일어나도 괜찮다. 별도의 인덱스 페이지가 있기 때문에 테이블 전체를 정렬하는 것보다 훨씬 낫다. 하지만 어디에 넌클러스터 인덱스를 걸어야 할 지는 정말 신중해야 한다. 바보같이 걸면 성능도 바보가 된다. 인덱스가 없는 것보다 느려질 수도 있다.</p><h2 id="활용"><a href="#활용" class="headerlink" title="활용"></a>활용</h2><h3 id="클러스터-인덱스-1"><a href="#클러스터-인덱스-1" class="headerlink" title="클러스터 인덱스"></a>클러스터 인덱스</h3><p>쿼리를 기준으로 예를 들면,</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>(hire_date), <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> hire_date &gt;= <span class="string">&#x27;1997-01-01&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">year</span>(hire_date); </span><br></pre></td></tr></table></figure><p>조건절에 <code>hire_date</code>가 있고, 범위 탐색이다. 이 경우 <code>hire_date</code>에 클러스터 인덱스를 보여하면 성능이 엄청나게 향상된다. 여기서 WHERE 절만 빼보자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>(hire_date), <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">year</span>(hire_date); </span><br></pre></td></tr></table></figure><p>여기서 마찬가지로 <code>hire_date</code>에 클러스터 인덱스를 건다면? 성능 향상에 도움이 안되거나, 데이터가 많아지는 경우 오히려 느려진다. 스캔 방식을 생각해야 한다. 클러스터 인덱스가 없는 경우 기본적으로 Heap 테이블 스캔이 이루어진다. 클러스터 인덱스가 있는 경우에는 클러스터 인덱스 스캔이 이루어진다. 하지만 조건절이 없으므로 무식하게 다 읽는건 Heap 테이블 스캔이 빠르다.</p><h3 id="넌클러스터-인덱스-1"><a href="#넌클러스터-인덱스-1" class="headerlink" title="넌클러스터 인덱스"></a>넌클러스터 인덱스</h3><p>위의 예시와 같은 쿼리이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>(hire_date), <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> hire_date &gt;= <span class="string">&#x27;1997-01-01&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">year</span>(hire_date); </span><br></pre></td></tr></table></figure><p>여기서 <code>hire_date</code>에 넌클러스터 인덱스를 건다면? 놀랍게도 클러스터 인덱스를 걸었을 때보다 더 빠르다. 이 경우 때문에 구글링을 2시간은 한 것 같다. 내가 내린 결론은, 넌클러스터 인덱스가 탐색 범위에 포함되었기 때문에 옵티마이저에서는 인덱스 스캔이 아닌 <strong>Non-Clustered Index Seek</strong> 방식을 선택한다. Index Scan은 인덱스의 모든 행을 인덱스 순서로 읽는 반면에, Index Seek은 필터 기준에 따라 일치하는 행이나 한정된 행만 찾으려고 리프 노드를 거치기 때문에 논리적 읽기 수가 훨씬 감소한다.(고 한다)</p><p>하지만 포인트 쿼리인지 범위 쿼리인지, 범위 쿼리라면 조건절의 탐색 범위는 얼마나인지에 따라서 경우가 달라진다. 결국 실무에서 클러스터링 최적화를 위해서는 테스트를 거친 후 적용해야 하고, 클러스터 인덱스를 걸 때는 인덱스를 거는 행동만으로 데이터 정렬에 비용이 소요되므로 신중하게 결정해야 한다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;학과 공부와 시험을 준비하다가 클러스터 인덱스와 넌클러스터 인덱스를 정리해 본다.&lt;/p&gt;
&lt;h2 id=&quot;개념&quot;&gt;&lt;a href=&quot;#개념&quot; class=&quot;headerlink&quot; title=&quot;개념&quot;&gt;&lt;/a&gt;개념&lt;/h2&gt;&lt;p&gt;영어 사전을 생각해보자. 기본적</summary>
      
    
    
    
    <category term="database" scheme="https://zinirun.github.io/categories/database/"/>
    
    
    <category term="database" scheme="https://zinirun.github.io/tags/database/"/>
    
    <category term="index" scheme="https://zinirun.github.io/tags/index/"/>
    
    <category term="clustered index" scheme="https://zinirun.github.io/tags/clustered-index/"/>
    
    <category term="nonclustered index" scheme="https://zinirun.github.io/tags/nonclustered-index/"/>
    
    <category term="sql" scheme="https://zinirun.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>Node.js - 좀 더 바람직하게 Express 서버 여는 법</title>
    <link href="https://zinirun.github.io/2020/10/16/node-better-express-app/"/>
    <id>https://zinirun.github.io/2020/10/16/node-better-express-app/</id>
    <published>2020-10-16T14:24:09.000Z</published>
    <updated>2020-10-16T15:07:00.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="바람직한-코드"><a href="#바람직한-코드" class="headerlink" title="바람직한 코드"></a>바람직한 코드</h2><p>이전부터 Node.js로 작고 큰 프로젝트들을 해왔지만 뚜렷한 코드 작성의 방향없이 생각나는 대로 집어 쓰는 경우가 많았다. “되기만 하면 된다”는 생각을 버려야 한다. 난 요즘 코드를 작성할 때 내가 만든 프로그램이 오픈소스가 되었을 때 사람들에게 당당하게 보여줄 수 있는 코드를 쓰려 노력하고 있다.</p><p>노드로 서버를 구축하면 항상 쓰는 Express 작성 방식부터가 엉망이었다. 처음에 책에서 하란 대로 하는데 되니까 그저 서버가 돌아가는 것에 만족하고 사용해왔다가, 여러 강의와 오픈 소스들을 살펴보니 Express 서버(app) 자체를 Class화하여 효율적으로 관리할 수 있는 방법이 있었다.</p><h2 id="이전의-주먹구구식-Express"><a href="#이전의-주먹구구식-Express" class="headerlink" title="이전의 주먹구구식 Express"></a>이전의 주먹구구식 Express</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>).createServer(app);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>),</span><br><span class="line">  bodyParser = <span class="built_in">require</span>(<span class="string">&quot;body-parser&quot;</span>),</span><br><span class="line">  cookieParser = <span class="built_in">require</span>(<span class="string">&quot;cookie-parser&quot;</span>),</span><br><span class="line">  <span class="keyword">static</span> = <span class="built_in">require</span>(<span class="string">&quot;serve-static&quot;</span>),</span><br><span class="line">  errorHandler = <span class="built_in">require</span>(<span class="string">&quot;errorhandler&quot;</span>),</span><br><span class="line">  expressErrorHandler = <span class="built_in">require</span>(<span class="string">&quot;express-error-handler&quot;</span>),</span><br><span class="line">  expressSession = <span class="built_in">require</span>(<span class="string">&quot;express-session&quot;</span>),</span><br><span class="line">  ejs = <span class="built_in">require</span>(<span class="string">&quot;ejs&quot;</span>),</span><br><span class="line">  fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>),</span><br><span class="line">  url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>),</span><br><span class="line">  cors = <span class="built_in">require</span>(<span class="string">&quot;cors&quot;</span>);</span><br><span class="line"></span><br><span class="line">app.set(<span class="string">&quot;port&quot;</span>, process.env.PORT || <span class="number">3000</span>);</span><br><span class="line">app.use(express.json());</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(</span><br><span class="line">  bodyParser.urlencoded(&#123;</span><br><span class="line">    extended: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line">app.use(<span class="string">&quot;/public&quot;</span>, express.static(__dirname + <span class="string">&quot;/public&quot;</span>));</span><br><span class="line">app.use(cookieParser());</span><br><span class="line">app.use(</span><br><span class="line">  expressSession(&#123;</span><br><span class="line">    secret: <span class="string">&quot;my key&quot;</span>,</span><br><span class="line">    resave: <span class="literal">true</span>,</span><br><span class="line">    saveUninitialized: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line">app.use(cors());</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 404 에러 페이지 처리</span></span><br><span class="line"><span class="keyword">var</span> errorHandler = expressErrorHandler(&#123;</span><br><span class="line">  <span class="keyword">static</span>: &#123;</span><br><span class="line">    <span class="number">404</span>: <span class="string">&quot;./public/404.html&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(expressErrorHandler.httpError(<span class="number">404</span>));</span><br><span class="line">app.use(errorHandler);</span><br><span class="line"></span><br><span class="line">http.listen(app.get(<span class="string">&quot;port&quot;</span>), <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;server started - port: &quot;</span> + app.get(<span class="string">&quot;port&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>가관이지만, 사실 이 형편없는 코드만으로도 서버는 정상적으로 돌아간다. 하지만 내가 노드를 쓰는 사람을 뽑는 채용 담당자라면 미들웨어가 이렇게 엉켜있고 재선언할 리 없는 변수나 라이브러리를 <code>var</code>로 남발하는 등의 엉성한 코드를 쓰는 사람에게 프로젝트를 믿고 맡길 수는 없을 것 같다.</p><h2 id="보다-나은-Express"><a href="#보다-나은-Express" class="headerlink" title="보다 나은 Express"></a>보다 나은 Express</h2><p>먼저 <code>app.js</code>를 <code>server.js</code>, <code>app.js</code>로 분할한다. (이름은 상관없다)</p><p>Express 관련 코드를 <code>app</code>에 담고, 그 <code>app</code>을 <code>http</code>와 <code>https</code>로 오픈할 <code>server</code> 소스로 나누어 작성한다.</p><p>먼저 <code>app.js</code>를 보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&quot;body-parser&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">&quot;cookie-parser&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> expressSession = <span class="built_in">require</span>(<span class="string">&quot;express-session&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&quot;cors&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">&quot;morgan&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.app = express();</span><br><span class="line">    <span class="built_in">this</span>.setViewEngine();</span><br><span class="line">    <span class="built_in">this</span>.setMiddleWare();</span><br><span class="line">    <span class="built_in">this</span>.setStatic();</span><br><span class="line">    <span class="built_in">this</span>.setLocals();</span><br><span class="line">    <span class="built_in">this</span>.getRouting();</span><br><span class="line">    <span class="built_in">this</span>.errorHandler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setMiddleWare() &#123;</span><br><span class="line">    <span class="comment">// HTTP -&gt; HTTPS Redirection</span></span><br><span class="line">    <span class="built_in">this</span>.app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (req.secure) &#123;</span><br><span class="line">        next();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> to = <span class="string">`https://<span class="subst">$&#123;req.hostname&#125;</span><span class="subst">$&#123;req.url&#125;</span>`</span>;</span><br><span class="line">        res.redirect(to);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.app.use(logger(<span class="string">&quot;dev&quot;</span>));</span><br><span class="line">    <span class="built_in">this</span>.app.use(bodyParser.json());</span><br><span class="line">    <span class="built_in">this</span>.app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line">    <span class="built_in">this</span>.app.use(cookieParser());</span><br><span class="line">    <span class="built_in">this</span>.app.use(</span><br><span class="line">      expressSession(&#123;</span><br><span class="line">        secret: <span class="string">&quot;my key&quot;</span>,</span><br><span class="line">        resave: <span class="literal">true</span>,</span><br><span class="line">        saveUninitialized: <span class="literal">true</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">this</span>.app.use(cors());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setViewEngine() &#123;</span><br><span class="line">    <span class="built_in">this</span>.app.set(<span class="string">&quot;view engine&quot;</span>, <span class="string">&quot;ejs&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.app.set(<span class="string">&quot;views&quot;</span>, <span class="string">&quot;./public&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.app.engine(<span class="string">&quot;html&quot;</span>, <span class="built_in">require</span>(<span class="string">&quot;ejs&quot;</span>).renderFile);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setStatic() &#123;</span><br><span class="line">    <span class="built_in">this</span>.app.use(<span class="string">&quot;/public&quot;</span>, express.static(__dirname + <span class="string">&quot;/public&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setLocals() &#123;</span><br><span class="line">    <span class="built_in">this</span>.app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.app.locals.isLogin = <span class="literal">true</span>;</span><br><span class="line">      next();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getRouting() &#123;</span><br><span class="line">    <span class="built_in">this</span>.app.use(<span class="built_in">require</span>(<span class="string">&quot;./controllers&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  errorHandler() &#123;</span><br><span class="line">    <span class="built_in">this</span>.app.use(<span class="function">(<span class="params">req, res, _</span>) =&gt;</span> &#123;</span><br><span class="line">      res.status(<span class="number">404</span>).render(<span class="string">&quot;404.html&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.app.use(<span class="function">(<span class="params">err, req, res, _</span>) =&gt;</span> &#123;</span><br><span class="line">      res.status(<span class="number">500</span>).render(<span class="string">&quot;500.html&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> App().app;</span><br></pre></td></tr></table></figure><p>코드만 봐도 Express에서 미들웨어를 설정하는지, 뷰엔진을 설정하는지, 라우터를 설정하는지, 에러핸들링을 하는지 알 수 있다. 만약에 미들웨어를 추가할 일이 생겼다면 <code>setMiddleware()</code>를 보고 여기가 미들웨어 넣는 자리구나하고 넣으면 된다.</p><p>이 Express app을 Class로 관리하면 또 다른 장점이 있는데, 서버 앱을 하나의 인스턴스로 관리할 수 있다. 비동기식 실행과 스레딩의 장점으로 노드를 CDN 서버 등으로 많이 활용하는데 접속된 인스턴스가 몇 개인지 관리하거나 접속 인스턴스의 갯수 제한을 두는 등의 작업을 편하게 할 수 있다.</p><p>이제 이 app을 기반으로 서버를 열면 된다. <code>server.js</code>를 보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">&quot;./app.js&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">&quot;https&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> options = <span class="built_in">require</span>(<span class="string">&quot;./config/pem_config&quot;</span>).options;</span><br><span class="line"><span class="keyword">const</span> httpPort = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">const</span> httpsPort = <span class="number">443</span>;</span><br><span class="line"></span><br><span class="line">https.createServer(options, app).listen(httpsPort, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`HTTPS: Express listening on port <span class="subst">$&#123;httpsPort&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(httpPort, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`HTTP: Express listening on port <span class="subst">$&#123;httpPort&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>작성해놓은 app을 불러와서 <code>http</code>와 <code>https</code> 모두로 열어주면 된다. 당연히 <code>https</code>는 발급한 SSL 인증서 정보를 같이 넣어주어야 한다. SSL 인증서로 https 서버를 구축하는 방법은 <a href="https://zinirun.github.io/2020/10/07/nodejs-https-server/">여기</a>에 포스팅해두었다. 학습용으로 만드는 토이 프로젝트가 아닌 이상 배포시에는 https를 당연히 지원해야 한다. 그래서 위에 <code>app.js</code>에는 http 접속을 https로 리다이렉트하는 미들웨어가 작성되어 있다.</p><p>이 방법이 완벽한 방법은 아닐 수 있다. 분명 더 세세하게 분리되어 있거나, 다른 좋은 방법으로 express 서버를 관리하는 방법도 많을 것이다. 중요한 것은 질 나쁜 코드를 작성하는 것을 끊임없이 지양하는 것에 있다고 생각한다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;바람직한-코드&quot;&gt;&lt;a href=&quot;#바람직한-코드&quot; class=&quot;headerlink&quot; title=&quot;바람직한 코드&quot;&gt;&lt;/a&gt;바람직한 코드&lt;/h2&gt;&lt;p&gt;이전부터 Node.js로 작고 큰 프로젝트들을 해왔지만 뚜렷한 코드 작성의 방향없이 생각나</summary>
      
    
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/categories/nodejs/"/>
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/tags/nodejs/"/>
    
    <category term="express" scheme="https://zinirun.github.io/tags/express/"/>
    
    <category term="https" scheme="https://zinirun.github.io/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>SQLD 38회 결과 (국가공인 SQL 개발자 자격증)</title>
    <link href="https://zinirun.github.io/2020/10/12/sqld-38-result/"/>
    <id>https://zinirun.github.io/2020/10/12/sqld-38-result/</id>
    <published>2020-10-12T00:08:42.000Z</published>
    <updated>2020-10-12T00:15:59.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="합격"><a href="#합격" class="headerlink" title="합격"></a>합격</h2><p><img src="/images/2020-10-12-09-10-48.png"></p><p>SQLD 사이트가 결과 발표 날에 마비되어 뒤늦게 확인했다. 결과는 합격! 순공시간 하루 정도에 좋은 결과를 얻었다. 자격증보다 프로젝트 하나가 낫다고 생각하지만 공부하는 머리도 돌릴겸 재미로 자격증 하나씩 따는건 재미있다. 오라클 자격증도 따보고 싶은데 터무니없이 비싸기도 하고 그 시간에 하둡이나 카프카를 공부해보고 싶기도 하다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;합격&quot;&gt;&lt;a href=&quot;#합격&quot; class=&quot;headerlink&quot; title=&quot;합격&quot;&gt;&lt;/a&gt;합격&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/2020-10-12-09-10-48.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;SQLD 사이트가 결과 발표 날에 </summary>
      
    
    
    
    <category term="Etc" scheme="https://zinirun.github.io/categories/Etc/"/>
    
    
    <category term="sqld" scheme="https://zinirun.github.io/tags/sqld/"/>
    
  </entry>
  
  <entry>
    <title>Node.js - MySQL timezone 삽질기</title>
    <link href="https://zinirun.github.io/2020/10/11/nodejs-mysql-timezone/"/>
    <id>https://zinirun.github.io/2020/10/11/nodejs-mysql-timezone/</id>
    <published>2020-10-11T08:54:18.000Z</published>
    <updated>2020-10-11T14:01:36.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="제-컴에선-되는데요"><a href="#제-컴에선-되는데요" class="headerlink" title="제 컴에선 되는데요"></a>제 컴에선 되는데요</h2><p>개발자들간의 대화에서 자주 나오는 변명이다. 지금 고군분투하고 있는 졸업작품에서 뼈저리게 느껴지는 말이다. 테스트 환경(로컬)과 운영 환경이 정말 다르다. localhost에선 잘만 되던 것이 도커로 서버에 배포하면 기대와 정말 다르다. 이번 문제는 도커로 배포된 MySQL 컨테이너의 시간대가 <code>UTC</code>로 설정되어 있어서 발생했다.</p><h2 id="삽질의-시작"><a href="#삽질의-시작" class="headerlink" title="삽질의 시작"></a>삽질의 시작</h2><p>백엔드(Node)에서 DB에 대한 config를 수정해야겠다 싶어서 구글링하다가 <a href="https://lemontia.tistory.com/873">비슷한 문제에 대한 해결방법</a>을 찾았다. Sequalize를 사용하지는 않지만 MySQL 설정에 대한 방법은 동일하겠다 싶었다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  connectionLimit: <span class="number">30</span>,</span><br><span class="line">  host: process.env.DATABASE_HOST,</span><br><span class="line">  user: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">  password,</span><br><span class="line">  database,</span><br><span class="line">  dateStrings: <span class="string">&quot;date&quot;</span>,</span><br><span class="line">  charset: <span class="string">&quot;utf8mb4&quot;</span>,</span><br><span class="line">  debug: <span class="literal">false</span>,</span><br><span class="line">  insecureAuth: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이 config를</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  connectionLimit: <span class="number">30</span>,</span><br><span class="line">  host: process.env.DATABASE_HOST,</span><br><span class="line">  user: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">  password,</span><br><span class="line">  database,</span><br><span class="line">  timezone: <span class="string">&quot;Asia/Seoul&quot;</span>,</span><br><span class="line">  dateStrings: <span class="literal">true</span>,</span><br><span class="line">  typeCast: <span class="literal">true</span>,</span><br><span class="line">  charset: <span class="string">&quot;utf8mb4&quot;</span>,</span><br><span class="line">  debug: <span class="literal">false</span>,</span><br><span class="line">  insecureAuth: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이렇게 바꿨다. 배포해보니 결과는 똑같았다.</p><p><img src="/images/2020-10-11-22-55-06.png"></p><p>9시간 전으로 타임스탬프가 찍힌다.. <code>timezone: &#39;+09:00&#39;</code>으로 설정해도 먹히지 않았다. 대체 왜 이러는걸까 생각하다가 도커로 배포한 MySQL에서 직접 <code>select current_timestamp()</code>를 찍어봐야겠다 생각했다.</p><p>그러니 문제의 timezone과 동일한 시간이 출력되어서 데이터베이스의 timezone만 바꾸면 되겠다고 생각했다. (여기서 해결한 줄 알았다)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">time_zone</span> = <span class="string">&#x27;Asia/Seoul&#x27;</span>;</span><br></pre></td></tr></table></figure><p>이제 현재시간도 정상적으로 찍힌다.</p><p>그런데 배포했는데 또 안된다. 9시간 전으로 (UTC 시간으로) 찍힌다.</p><h2 id="해결-방법"><a href="#해결-방법" class="headerlink" title="해결 방법"></a>해결 방법</h2><p>데이터베이스에서 timezone을 설정하는 방법은 맞았다. 하지만 데이터베이스 컨테이너 내 모든 DB의 Global 값을 설정해야 모든 테이블에 대해 timezone이 정상적으로 적용되는 것이었다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> <span class="keyword">time_zone</span> = <span class="string">&#x27;Asia/Seoul&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/2020-10-11-22-59-39.png"></p><p>이제 정상적으로 찍힌다. 사실 이 설정들을 바꾸는 건 어렵지 않은데, 아무리 배포 자동화가 되어 있어도 깃에 푸시하고 서버에 접속해서 스크립트를 실행하면 몇 초만에 끝나는 것도 아니라서 꽤 번거로웠다. 로컬 환경에서 배포 환경 기준으로 테스트할 수 있는 방법이 있으면 좋겠다..</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;제-컴에선-되는데요&quot;&gt;&lt;a href=&quot;#제-컴에선-되는데요&quot; class=&quot;headerlink&quot; title=&quot;제 컴에선 되는데요&quot;&gt;&lt;/a&gt;제 컴에선 되는데요&lt;/h2&gt;&lt;p&gt;개발자들간의 대화에서 자주 나오는 변명이다. 지금 고군분투하고 있는 </summary>
      
    
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/categories/nodejs/"/>
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/tags/nodejs/"/>
    
    <category term="docker" scheme="https://zinirun.github.io/tags/docker/"/>
    
    <category term="mysql" scheme="https://zinirun.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Node.js - HTTPS 서버 구축하기</title>
    <link href="https://zinirun.github.io/2020/10/07/nodejs-https-server/"/>
    <id>https://zinirun.github.io/2020/10/07/nodejs-https-server/</id>
    <published>2020-10-07T06:10:35.000Z</published>
    <updated>2020-10-09T08:39:06.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="왜-굳이-HTTPS"><a href="#왜-굳이-HTTPS" class="headerlink" title="왜 굳이 HTTPS?"></a>왜 굳이 HTTPS?</h2><p>우리가 들어가는 대부분의 사이트는 HTTPS 프로토콜을 지원한다. HTTP 프로토콜은 프로토타입에서만 사용하고 끝내야 한다. 가장 큰 차이점은 SSL 인증서의 유무이다. SSL 인증서는 사용자가 사이트에 제공하는 정보를 암호화한다. HTTP와 HTTPS의 자세한 차이는 <a href="http://blog.wishket.com/http-vs-https-%EC%B0%A8%EC%9D%B4-%EC%95%8C%EB%A9%B4-%EC%82%AC%EC%9D%B4%ED%8A%B8%EC%9D%98-%EB%A0%88%EB%B2%A8%EC%9D%B4-%EB%B3%B4%EC%9D%B8%EB%8B%A4/">여기</a>에 잘 나와있다. 이번에는 노드에서 어떻게 HTTPS 서버를 구축하는지 정리해보려 한다.</p><h2 id="HTTPS-서버-구축하기"><a href="#HTTPS-서버-구축하기" class="headerlink" title="HTTPS 서버 구축하기"></a>HTTPS 서버 구축하기</h2><h3 id="인증서-선택하기-무료-유료"><a href="#인증서-선택하기-무료-유료" class="headerlink" title="인증서 선택하기 (무료/유료)"></a>인증서 선택하기 (무료/유료)</h3><p>기본적으로 SSL 인증서는 유료이다. 하지만 https를 지향하는 기업에서 “https는 필수가 되어야 한다”는 목소리를 모아 <a href="https://letsencrypt.org/ko/">Let’s Encrypt</a>라는 무료 인증기관을 만들었다.</p><p>그러나 기본적으로 3달 주기로 인증서를 업데이트해줘야 하기 때문에 현재 도메인 서비스를 받고 있는 <a href="namecheap.com">Namecheap</a>에서 꽤 저렴한 SSL 인증서 제품을 팔고 있어서 이를 사서 쓰기로 했다. 1년에 4달러 정도인데, 이는 특정 한 도메인에만 사용할 수 있다. wildcard(*) 서브 도메인을 모두 인증서로 걸고 싶다면 Wildcard 제품을 별도로 구입해야 한다. (이건 비싸다)</p><h3 id="OpenSSL로-키-생성하기"><a href="#OpenSSL로-키-생성하기" class="headerlink" title="OpenSSL로 키 생성하기"></a>OpenSSL로 키 생성하기</h3><p><a href="http://slproweb.com/products/Win32OpenSSL.html">여기</a>에서 OpenSSL 설치 파일을 받아 설치한다. 이후 커맨드 창(터미널)을 관리자 권한으로 실행한다.</p><p>먼저 key를 생성한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -des3 -out key.pem 2048</span><br></pre></td></tr></table></figure><p>다음으로 csr을 생성한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key key.pem -out csr.pem</span><br></pre></td></tr></table></figure><p>나는 csr을 생성할 때 순서대로 이렇게 입력했고, 참고하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Country Name (국가코드) : KR</span><br><span class="line">State or Province Name (시&#x2F;도) : Seoul</span><br><span class="line">Locality Name (구&#x2F;군) : (Enter로 넘어감)</span><br><span class="line">Organization Name (회사명) : NemoBros</span><br><span class="line">Organizational Unit Name (부서명) : Dev Team</span><br><span class="line">Common Name (인증 받을 도메인 주소) : zini.work</span><br><span class="line">Email Address : email@email.com</span><br><span class="line"></span><br><span class="line">Please enter the following &#39;extra&#39; attributes</span><br><span class="line">to be sent with your certificate request</span><br><span class="line">A challenge password : (Enter로 넘어감)</span><br><span class="line">An optional company name : (Enter로 넘어감)</span><br></pre></td></tr></table></figure><p>이제 이 CSR 파일을 열어서 각자의 도메인 사이트에서 인증서 제품을 구입한 후 CSR 파일의 주석을 제외한 암호화 코드 부분을 넣으면 정상적으로 인증서 파일이 발급된다. 그리고 사이트가 본인의 것이 맞는지 검사하는 절차가 3가지정도 있는데, 마음대로 선택해서 인증을 진행한다.</p><p>(Let’s Encrypt 무료 인증서를 이용하면 스킵해도 된다.)</p><h3 id="Node-js-HTTPS-서버-구축"><a href="#Node-js-HTTPS-서버-구축" class="headerlink" title="Node.js HTTPS 서버 구축"></a>Node.js HTTPS 서버 구축</h3><p>이제 Node.js에서 인증서를 걸어서 https 서버를 구축해보자. http 서버만 정상적으로 구축했다면 어렵지 않다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> options = <span class="built_in">require</span>(<span class="string">&#x27;./config/pem_config&#x27;</span>).options;</span><br><span class="line"><span class="keyword">const</span> httpPort = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">const</span> httpsPort = <span class="number">443</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTPS 서버</span></span><br><span class="line">https.createServer(options, app).listen(httpsPort, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`HTTPS: Express listening on port <span class="subst">$&#123;httpsPort&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP 서버</span></span><br><span class="line">app.listen(httpPort, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`HTTP: Express listening on port <span class="subst">$&#123;httpPort&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>HTTPS 서버를 구축하는데 HTTP 서버까지 오픈하는 이유는 나중에 설명하겠다.</p><p>다음으로 <code>options</code>에 연결된 파일을 만드는데, pem키에 대한 config를 하드코딩 하는 것보다는 option 파일로 미리 빼서 사용하는 것이 보안적으로나 가독성으로나 낫다. 내 <code>./config/pem_config</code>는 이렇게 작성되어 있는데,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> keys_dir = <span class="string">&quot;config/secure/&quot;</span>; <span class="comment">// 키 파일이 위치</span></span><br><span class="line"><span class="keyword">const</span> ca = fs.readFileSync(keys_dir + <span class="string">&quot;ca.ca-bundle&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> key = fs.readFileSync(keys_dir + <span class="string">&quot;key.pem&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> cert = fs.readFileSync(keys_dir + <span class="string">&quot;cert.crt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.options = &#123;</span><br><span class="line">  key,</span><br><span class="line">  cert,</span><br><span class="line">  ca,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이렇게 Let’s Encrypt로 발급한 인증서를 넣던지, 나처럼 기관에서 유료 인증서를 발급받고 다운로드받은 파일을 넣던지 하면 된다. 참고로 <code>keys_dir</code>는 키 파일이 위치한 폴더 경로인데, <code>fs</code>의 <code>readFile</code> 경로는 절대경로가 아님에 주의해서 작성하자.</p><h3 id="HTTPS-리다이렉션"><a href="#HTTPS-리다이렉션" class="headerlink" title="HTTPS 리다이렉션"></a>HTTPS 리다이렉션</h3><p>이제 서버를 열면 HTTPS (443 포트), HTTP (80 포트) 모두에서 접속할 수 있다. 하지만 HTTPS 서버를 구축했는데 사용자가 임의로 HTTP로 프로토콜을 변경해서 들어오면 말짱도루묵이 될 것이다. 이제 HTTP 요청을 HTTPS로 리다이렉션하는 미들웨어만 작성하면 모든 작업이 끝난다.</p><p>나는 express를 class화하여 서버 인스턴스를 열고 있는데, 그렇지 않은 경우에는 앞에 <code>this.</code>만 지우면 된다. 모든 미들웨어의 최상단에 작성해야 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.secure) &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> to = <span class="string">`https://<span class="subst">$&#123;req.hostname&#125;</span><span class="subst">$&#123;req.url&#125;</span>`</span>;</span><br><span class="line">    res.redirect(to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>req.secure</code>은 https 요청인지 아닌지를 반환하기에 이를 이용하여 https 리다이렉션을 구현할 수 있다. (구현하는 방법은 이것 말고도 많다)</p><p>우여곡절의 HTTPS 서버 구축이 끝났다. 사이트에 자물쇠 모양이 뜨는 것만으로도 인증서 4천원은 아까워하지 않기로 했다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;왜-굳이-HTTPS&quot;&gt;&lt;a href=&quot;#왜-굳이-HTTPS&quot; class=&quot;headerlink&quot; title=&quot;왜 굳이 HTTPS?&quot;&gt;&lt;/a&gt;왜 굳이 HTTPS?&lt;/h2&gt;&lt;p&gt;우리가 들어가는 대부분의 사이트는 HTTPS 프로토콜을 지원한다.</summary>
      
    
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/categories/nodejs/"/>
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/tags/nodejs/"/>
    
    <category term="express" scheme="https://zinirun.github.io/tags/express/"/>
    
    <category term="https" scheme="https://zinirun.github.io/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 심화 공부와 졸업작품 리팩토링 계획</title>
    <link href="https://zinirun.github.io/2020/10/04/capstone-design-review-2/"/>
    <id>https://zinirun.github.io/2020/10/04/capstone-design-review-2/</id>
    <published>2020-10-04T06:58:35.000Z</published>
    <updated>2020-10-04T07:38:22.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="추석-기념-Node-js-심화-공부"><a href="#추석-기념-Node-js-심화-공부" class="headerlink" title="추석 기념(?) Node.js 심화 공부"></a>추석 기념(?) Node.js 심화 공부</h2><p>코로나때문에 추석에 고향을 가지 않았다. 보다 알찬 추석을 위해 그동안 하고 싶었던 졸업작품 리팩토링이 떠올랐다. 무턱대고 하기에는 확신이 없어서, Node.js와 Express 관련 강의를 처음부터 끝까지 동영상을 100개정도 본 것 같다. 아는 것도 많았지만 반성할 점 투성이었다. 지금까지 졸업 작품의 코드가 되게 바보같다는 생각을 했다.</p><h2 id="졸업작품-셀프-코드리뷰-그리고-반성"><a href="#졸업작품-셀프-코드리뷰-그리고-반성" class="headerlink" title="졸업작품 셀프 코드리뷰 그리고 반성"></a>졸업작품 셀프 코드리뷰 그리고 반성</h2><h3 id="REST-API-미준수"><a href="#REST-API-미준수" class="headerlink" title="REST API 미준수"></a>REST API 미준수</h3><p>우선 REST API를 제대로 준수하지 않았다. 예를 들어 회원가입을 굳이 GET 요청은 <code>/register</code>로, POST 요청은 <code>/reg_submit</code>으로 하는 등, CRUD 요청을 한 URL에서 라우터의 속성만 바꿔서 작성하면 될 것을 뒤에 <code>submit</code>이라는 말을 붙여 불필요하게 만들었다는 것이다.</p><h3 id="주먹구구식-app-js"><a href="#주먹구구식-app-js" class="headerlink" title="주먹구구식 app.js"></a>주먹구구식 app.js</h3><p><img src="/images/2020-10-04-16-10-36.png"></p><p>모든 라우터와 익스프레스 설정이 포함된 <code>app.js</code>도 엉망이다. <code>server.js</code>로 분리하여 서버에 대한 설정(미들웨어 등)을 하고 각 대분류에 대한 컨트롤러 파일을 따로 만들었다면 유지보수가 훨씬 수월한 코드가 만들어졌을텐데, 지금의 코드는 주먹구구식이었다. 그리고 서버에 대한 코드를 class화 한다면 인스턴스 관점에서의 서버 접속 관리를 할 수 있다. 구조에 대한 전체적인 수정이 필요하다..</p><h3 id="바보같은-미들웨어-처리"><a href="#바보같은-미들웨어-처리" class="headerlink" title="바보같은 미들웨어 처리"></a>바보같은 미들웨어 처리</h3><p>지금 만드는 서비스는 기본적으로 로그인이 되어 있어야 동작한다. 그래서 모든 라우터에는</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (req.session.user) &#123;</span><br><span class="line">  <span class="comment">// 로그인이 되어 있을 때</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 로그인으로 넘기기</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 로그인 확인 로직이 기본적으로 처음에 들어간다. 사실 <code>checkLogined</code> 함수를 따로 만들어서 미들웨어로 <code>next()</code> 처리만 해주면 똑같은 코드를 복사해서 쓰는 어리석은 짓은 하지 않아도 됐었다.</p><h3 id="레이아웃이-없는-뷰"><a href="#레이아웃이-없는-뷰" class="headerlink" title="레이아웃이 없는 뷰"></a>레이아웃이 없는 뷰</h3><p>프론트엔드 단에서는 <code>ejs</code> 템플릿 엔진을 사용하고 있는데 별도의 레이아웃을 사용하지 않아서 내비게이션 바같은 상단에 고정에 들어가는 항목들이 모든 html 파일에 포함되어 있다. 당연히 내비게이션 바의 코드를 수정하려면 모든 html을 수정해야 한다. 레이아웃 뷰를 도입했다면 이런 비효율적인 행위를 하지 않아도 됐었다.</p><h2 id="리팩토링-계획"><a href="#리팩토링-계획" class="headerlink" title="리팩토링 계획"></a>리팩토링 계획</h2><p>생각보다 리팩토링할 내용이 너무 많다. 위에서 나온 4가지 큰 문제를 수정할 계획인데, 일단 서버 사이드의 코드부터 뜯어 고치고 프론트 사이드에 레이아웃을 적용할 생각이다.</p><ol><li>app.js, server.js 분리, class화</li><li>미들웨어 처리</li><li>라우터에 MVC 패턴 도입, REST API 준수</li><li>짜잘한 코드 수정 (함수 세분화)</li><li>레이아웃 뷰 사용하기</li></ol><p>위 순서대로 차근차근 리팩토링을 할 계획이다. 이번 졸업작품에서 제대로 된 코드를 작성한다면 다음 프로젝트에서는 이런 번거로운 리팩토링은 하지 않아도 될 기대를 한다. 물론 완벽한 리팩토링이란 것은 없지만, 현재의 코드에 안주하는 개발자는 발전 가능성이 없다는 것을 잘 알고 있기에 더 완벽한 코드를 지향하려 한다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;추석-기념-Node-js-심화-공부&quot;&gt;&lt;a href=&quot;#추석-기념-Node-js-심화-공부&quot; class=&quot;headerlink&quot; title=&quot;추석 기념(?) Node.js 심화 공부&quot;&gt;&lt;/a&gt;추석 기념(?) Node.js 심화 공부&lt;/h2</summary>
      
    
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/categories/nodejs/"/>
    
    
    <category term="capstone design" scheme="https://zinirun.github.io/tags/capstone-design/"/>
    
    <category term="homes" scheme="https://zinirun.github.io/tags/homes/"/>
    
    <category term="nodejs" scheme="https://zinirun.github.io/tags/nodejs/"/>
    
    <category term="express" scheme="https://zinirun.github.io/tags/express/"/>
    
    <category term="refactoring" scheme="https://zinirun.github.io/tags/refactoring/"/>
    
  </entry>
  
  <entry>
    <title>search-algorithm-1</title>
    <link href="https://zinirun.github.io/2020/10/01/search-algorithm-1/"/>
    <id>https://zinirun.github.io/2020/10/01/search-algorithm-1/</id>
    <published>2020-10-01T10:17:00.000Z</published>
    <updated>2020-10-21T05:19:35.634Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://m.blog.naver.com/ndb796/220578642298">좋은 자료</a>가 있어서 공유한다.</p><p>​1. Greedy Best-First Search<br>2. A* Search<br>3. Memory-Bounded Heuristic Search</p><p>이 중에서 가장 유용해서 실제로 매우 많이 사용되고, 중요한 것이 바로 A* Search입니다.</p><p>솔직히 말씀드리자면 공부할 시간이 없으신 분들은 A* Search만 알고 넘어가도 괜찮을 것 같습니다.</p><p>또한 한가지 더 알고 계시면 좋은 점은 바로 이 모든 Heuristic Search 알고리즘은 ‘길 찾기 알고리즘’으로 많이 사용된다는 것입니다.</p><p>다음 지도를 이번 강좌에서도 사용하겠습니다.</p><ol><li>Greedy Best-First Search</li></ol><p>Greedy는 ‘탐욕스러운’이라는 의미를 가지고 있습니다.</p><p>어떻게 보면 단순하다는 의미를 내포하고 있다고 봐도 됩니다.</p><p>여기서는 평가 함수를 오직 휴리스틱 함수로만 구성합니다.</p><p>즉, F(n) = H(n)입니다.</p><p>여기서 이 H(n)를 어떻게 설정하냐에 따라서 알고리즘의 질이 바뀌는데요.</p><p>흔히 길찾기에서는 이 H(n)를 현재 노드와 목표 노드 사이의 직선 거리로 확인합니다.</p><p>즉, 이 Heuristic Search 알고리즘들과 기존의 Blind Search의</p><p>다른 점은 바로 목표 노드의 위치를 알 고 있다는 사실입니다.</p><p>이 목표 노드의 위치를 알고 있다는 사실은 바로 경험적 근거가 되겠지요?</p><p>그 경험적 근거를 바로 문자 그대로 Heuristic(경험적인)으로 받아들이시면 됩니다.</p><p>그리고 쉽게 이 Heuristic Search 알고리즘의 예시들은 ‘길찾기’라고 생각하고 학습하시면 됩니다.</p><p>또한 실제로 아주 많은 장애물을 효과적으로 건너가서 길을 찾는 프로그램들이</p><p>사용하는 알고리즘이 바로 Heuristic Search 알고리즘이기 때문입니다.</p><p>직선 거리 Straight-Line-Distance(SLD)가 휴리스틱을 결정한다고 하였으면</p><p>실제로 Arad라는 도시에서 Bucharest라는 도시로 이동하는 과정을 보겠습니다.</p><p>위 사진은 각각의 도시에서 Bucharest로 이르는 직선 거리를 보여줍니다.</p><p>이를 통해서 Tree-Based Search를 하면 다음과 같습니다.</p><p>아주 직관적인 그림이기 때문에 이해하시기 쉬울 것입니다.</p><p>다만 여기서 고려할 점은 Arad에서 Sibiu 노드를 확장했을 때 Child Node로 Arad가 또 있는 것을 볼 수 있습니다.</p><p>만약에 여기서 다시 Arad로 들어가는 경우가 생긴다면 아주 충격적인 결과가 벌어지겠죠. 무한 반복입니다.</p><p>그렇기 때문에 Node를 Expand할 때 자신의 조상 노드들을 확인해서 이미 나온 Node라면 Discarding 해주면 됩니다.</p><p>● Evaluation</p><p>Complete : No<br>Optimal : No<br>Time &amp; Space Complexity : O(b^m)</p><p>But, 휴리스틱 함수를 잘만 짤 수 있다면 이 복잡도를 줄여나갈 수 있습니다.</p><p>또한 Graph Search에 근거한다면 Search Space가 유한한 경우에 한정하여</p><p>Complete하다는 결과를 낼 수 있습니다. 또한 최적은 아니더라도 Solution을 찾을 수 있겠죠.</p><ol><li>A* Search</li></ol><p>Best-First Search 중에서 가장 잘 알려진 Search 방법인 이 A* Search는 H(n)뿐 아니라 G(n)도 사용합니다.</p><p>즉, F(n) = G(n) + H(n)이라고 할 수 있습니다. 다만 여기서 G(n)가 의미하는 바는 바로 Start Node에서</p><p>현재까지 걸린 Path Cost가 되겠습니다. 또한 H(n)는 현재 State에서 Goal State까지의 가장 빠른 길입니다.</p><p>따라서 이 F(n)는 n을 통한 Solution 중 가장 적은 비용을 추정하는 방법이라고 할 수 있습니다.</p><p>결과적으로 이 A* Search는 Optimal하고 Complete합니다.</p><p>이 알고리즘 자체는 Uniform-Cost Search와 큰 차이가 없습니다.</p><p>다만 A*에서는 G대신 G + H를 사용할 뿐이지요.</p><p>따라서 가장 중요한 것은 당연히 H(n) 함수입니다.</p><p>정확히 어떤 휴리스틱을 사용할 것이냐가 관건이죠.</p><p>Goal State를 아주 최적의 해를 통해서 만족시키는 것이 목표이다.</p><p>결론으로,</p><p>f(n)은 n을 통한 solution 중 가장 적은 비용을 추정하는 방법이다. 결과적으로 A* 알고리즘은 Optimal하고 Complete하다고 볼 수 있다. 최적의 경로를 찾기 위해 필요한 것은 당연히 h(n)이다. h(n)이 0이라면 무한 루프에 빠지는 경우가 생길 수 있다.<br>h(n)을 사용하여 정확히 어떤 휴리스틱을 사용할 것인지 정하고 탐색을 진행하는 것이 알고리즘의 최적의 경로를 찾아낼 수 있는 방법이다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://m.blog.naver.com/ndb796/220578642298&quot;&gt;좋은 자료&lt;/a&gt;가 있어서 공유한다.&lt;/p&gt;
&lt;p&gt;​1. Greedy Best-First Search&lt;br&gt;2. A* Search&lt;br&gt;3. Mem</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>졸업작품을 하면서 - 첫번째 회고</title>
    <link href="https://zinirun.github.io/2020/09/28/capstone-design-review-1/"/>
    <id>https://zinirun.github.io/2020/09/28/capstone-design-review-1/</id>
    <published>2020-09-28T00:36:40.000Z</published>
    <updated>2020-09-28T06:03:12.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="졸업작품-팀-프로젝트-Homes의-4주차까지"><a href="#졸업작품-팀-프로젝트-Homes의-4주차까지" class="headerlink" title="졸업작품 팀 프로젝트, Homes의 4주차까지"></a>졸업작품 팀 프로젝트, Homes의 4주차까지</h1><p>첫 졸업작품에 대한 이야기를 적어보려 한다. 끝나고 한번에 적을까 했는데, 소중한 기억들이 사라질까 싶어 생각이 날 때 마다 회고를 써볼까 한다. 프로젝트는 올해 12월까지 진행하고, 지금 4분의 1정도 왔다.</p><h2 id="다르게-살아온-4명과-프로젝트를-한다는-것"><a href="#다르게-살아온-4명과-프로젝트를-한다는-것" class="headerlink" title="다르게 살아온 4명과 프로젝트를 한다는 것"></a>다르게 살아온 4명과 프로젝트를 한다는 것</h2><p>우리 학교는 보통 4학년 1학기, 2학기에 캡스톤 디자인(졸업작품) 과목이 있다. 나는 3학년 2학기이지만 마지막 학기에는 실무에서 일하고 싶어서 미리 듣기로 했다.</p><p>2명과 협업은 해봤지만 4명과 한 학기동안 한 목표를 가지고 프로젝트를 하는 것은 처음이다. 나와 같은 16학번 3명과 15학번 1명으로 뭉쳤고, 당연히 각자가 가진 개발 지식이나 경험이 다르다.</p><p>팀 이름은 팀원들이 각각 서울, 강원도 홍천, 대구, 포항에서 온 꼭짓점을 이으면 사각형이 되고, 네모난 세상을 둥글게 바꾸자는 의미에서 “네모난 형제들”로 지었다.</p><h2 id="역할-분담하기"><a href="#역할-분담하기" class="headerlink" title="역할 분담하기"></a>역할 분담하기</h2><p><img src="http://file3.instiz.net/data/cached_img/upload/2018/03/27/22/714ab1cb590abab490b0c15ad6d6e169.jpg"></p><p>우리는 침팬지에 뒤쳐질 수는 없었다. 각자 할 수 있는 위치에서 적절한 역할 분담이 필요했다.</p><p>우선 팀원들의 개발 지식을 간략하게 소개하자면,</p><ul><li>나: 프론트엔드, 벡엔드, 서버 인프라에 대한 프로젝트 경력이 있음</li><li>팀원 A: 웹 공부를 시작한지 얼마 되지 않음</li><li>팀원 B: 생*코딩에서 노드 클론 코딩 경험, 프론트, 서버에 대한 지식은 전무</li><li>팀원 C: 웹에 대한 지식 전무, SQLD 공부로 데이터베이스나 SQL문은 짤 수 있음</li></ul><p>모두가 참여할 수 있는 역할 분담의 방향을 잡다가, 하이브리드 앱으로 결정했다. 웹은 3명이 어떻게 하다보면 할 수 있겠다 싶었다. 나는 프로젝트 총괄, <code>팀원 A</code>는 프론트엔드, <code>팀원 B</code>는 벡엔드, 데이터베이스는 <code>팀원 C</code>에게 맡기면 될 것 같았다. 팀 리더는 하이브리드 앱을 만들어 봤고 장기간의 프로젝트에 자신이 있는 내가 하기로 했다.</p><h2 id="프로젝트-구상하기"><a href="#프로젝트-구상하기" class="headerlink" title="프로젝트 구상하기"></a>프로젝트 구상하기</h2><p>이제 뭘 만들까 고민했다. 구체적인 목표만 있다면 어떻게든 구현하는 것은 문제가 되지 않다고 지금까지 생각해왔기에 각자가 생각해 본 아이디어를 제시했다. “오 이거 괜찮다”고 생각한 아이디어는 대부분 시장에 나와 있다.</p><p>내 주변에서 느낄 수 있는 불편함이 뭐가 있을까 생각하다가 세 들어서 사는 나같은 대학생들이 평소에 느끼는 불편함이 떠올랐다. 거의 대학가의 모든 주택이 그런데, 유지보수가 엉망이다. 모두가 공감했고 어떻게 해소할 수 있을까 고민하다가 지금 진행하는 프로젝트 Homes가 탄생했다.</p><h3 id="애자일-방법론"><a href="#애자일-방법론" class="headerlink" title="애자일 방법론"></a>애자일 방법론</h3><p>구체적인 목표를 정해서 단계별로 하기 보다는 프로젝트의 작은 요소들을 하나하나 모아서 트러블 슈팅하기 위해 애자일 방법론을 추구하기로 했다. 전반적인 프로젝트 목표는 정해져 있지만 처음 생각한 아이디어이므로 중간에 끼워넣거나 빼는 기능들이 많을 것이라고 생각했다.</p><h2 id="협업-환경-만들기"><a href="#협업-환경-만들기" class="headerlink" title="협업 환경 만들기"></a>협업 환경 만들기</h2><p><img src="/images/2020-09-28-10-34-00.png"></p><p>절대 카톡같은 메신저로 협업하는 어리석은 짓은 하지 않기로 했다. 저번 외주를 하면서 느낀 것 중 가장 큰 것이 버전 관리였기 때문이다. 나중에 톡에서 코드를 보면 “이게 뭐더라”고 할 것이 분명하다. 나름 체계적인 협업 환경을 만들려고 노력했다.</p><p>그래서 Github를 코드 저장과 버전 관리에, Notion을 공지사항, 전파사항, 회의 내용 작성에, Google Docs을 발표 문서, PPT 작성에 사용하기로 했다. 깃허브에 익숙하지 않은 사람이 많았고, 노션은 나만 사용해봐서 팀원들에게 내가 아는 선에서 사용법과 기능을 알려주었다.</p><p><img src="/images/2020-09-28-10-53-44.png"></p><p>우여곡절 끝에 협업 환경이 갖춰졌다.</p><h2 id="기술-스택-정하기"><a href="#기술-스택-정하기" class="headerlink" title="기술 스택 정하기"></a>기술 스택 정하기</h2><p>하이브리드 앱은 기본적으로 웹을 기반으로 만들어지기 때문에 벡엔드와 서버 인프라만 구상하면 된다. 프론트엔드는 React, Vue같은 프레임워크 없이 Vanilla Javascript로만 구현하기로 했다.</p><p>백엔드는 나와 <code>팀원 B</code>가 사용해본 Node.js를 쓰기로 했다. 자바스크립트 기반이므로 프론트엔드 담당인 <code>팀원 A</code>도 나중에 공부하다가 합류할 수도 있겠다 싶었다. 서버는 학교에서 NHN Toast 인스턴스를 신청하면 대여해주었고, 마침 나는 학교에서 Toast 서버 스터디를 마쳤기에 AWS 프리티어 인스턴스를 고민하던 나로서는 다행이었다. 모든 서비스를 Docker로 서비스하기로 했다.</p><p>어플리케이션으로 매핑하는 프레임워크는 React Native를 쓰기로 했다. 저번 외주에서와 마찬가지로 React Native와 Expo 툴을 사용하면 웹 앱 만들기가 정말 수월하고 테스트도 쉽다. 어플리케이션에서 푸시 알림 기능은 Firebase Push를 사용하기로 했다.</p><h2 id="배포-테스트-자동화하기"><a href="#배포-테스트-자동화하기" class="headerlink" title="배포(테스트) 자동화하기"></a>배포(테스트) 자동화하기</h2><p>로컬 환경과 실제 배포된 환경은 분명히 다르다. 어플리케이션으로 매핑하는 것은 나중에 하더라도 그 기반이 되는 웹은 안드로이드던 iOS던 완벽에 가까워야 한다. 터미널에서 깃 클론하고, 도커 이미지 만들고, 컨테이너 연결하고 실행하고 이 모든 명령어들을 테스트할 때 마다 타이핑하다가는 어차피 올 터널 증후군이 더 일찍 올 수도 있다.</p><p>이전에도 사용한 배포 자동화 쉘 스크립트를 좀 더 체계적으로 변형하여 사용하기로 했다. <a href="https://zinirun.github.io/2020/09/18/docker-automation-shellscript/">이전 포스트</a>에 관련 내용을 포스팅했다. 이제 개발하고 서버에 배포해서 테스트하고 싶으면 터미널에 <code>./get_git.sh</code>와 <code>./build_n_run.sh</code>만 치면 된다.</p><blockquote><p>이제 팀원들은 본격적으로 코드, 데이터베이스 작성에만 집중할 수 있다.</p></blockquote><h2 id="변수-이름-짓기부터-다른-우리"><a href="#변수-이름-짓기부터-다른-우리" class="headerlink" title="변수 이름 짓기부터 다른 우리"></a>변수 이름 짓기부터 다른 우리</h2><p><img src="/images/2020-09-28-11-17-26.png"></p><p>개발자는 많은 난관에 봉착하는데, 그 중 가장 심각한 난관이 “변수 네이밍”이다. 협업에서 변수 네이밍은 절대적으로 통일되어야 한다. 내 코드를 남이 봐도 이해할 수 있어야 하기 때문이다.</p><h3 id="이름은-길어도-좋다"><a href="#이름은-길어도-좋다" class="headerlink" title="이름은 길어도 좋다"></a>이름은 길어도 좋다</h3><p>우리는 크게 건물주(host), 관리인(manager), 세입자(tenant) 3가지 범주로 나누어 코드를 작성하고 있는데, 한 팀원이 manager를 mgr로, management를 mgmt로 네이밍했다. 변수 작성 방법을 통일하자고 얘기한 찰나에 <code>host_aden.html</code> 파일을 보고 이게 대체 무슨 파일인가 싶어서 물어봤는데 건물주가 자신의 건물을 보는 상세 페이지라고 한다. 그래서 <code>aden</code>이 뭔지 물었더니 구글에 기능 이름을 검색해서 줄인 이름인데 까먹었다고 한다. 앞으로는 변수나 파일 이름을 길게 해도 좋으니 <code>mgr_mgmt</code> 보다는 <code>manager_management</code>로 작성하자고 모두에게 알렸다.</p><h3 id="camelCase-snake-case"><a href="#camelCase-snake-case" class="headerlink" title="camelCase, snake_case"></a>camelCase, snake_case</h3><p><img src="/images/2020-09-28-11-28-20.png"></p><p>사실 카멜 케이스던 스네이크 케이스던 어떤 방법을 사용해도 좋지만 적어도 통일은 필요했다. 이게 혼용되면 가독성에서나 코드 리뷰에서나 최악의 코드가 만들어질 수 있다. <code>팀원 C</code>의 Database 테이블을 생성하는 SQL을 보고, 이 경우도 강조해야겠다 싶어서 다시 모두에게 공지했다. 두 번의 실수는 없기를 바랄 뿐이었다.</p><h3 id="var는-쓰지마"><a href="#var는-쓰지마" class="headerlink" title="var는 쓰지마"></a>var는 쓰지마</h3><p>자바스크립트에서 정말 임시적으로 사용할 것이 아니라면 <code>var</code>로 변수를 선언할 일은 희박하다. 90%의 변수는 <code>const</code>를 써도 되고, 굳이 바뀔 변수라면 <code>let</code>을 사용하면 된다. 같은 이름으로 변수를 재할당하는 실수를 방지하기 위해 팀원들에게 <code>var</code>를 쓸 일은 최대한 줄여달라고 당부했다.</p><h2 id="첫번째-회고를-마치며"><a href="#첫번째-회고를-마치며" class="headerlink" title="첫번째 회고를 마치며,"></a>첫번째 회고를 마치며,</h2><p>4주차까지 프로젝트가 진행되고 있고 전반적인 협업 개발 환경에서 각자의 임무에 어느정도 적응하고 나름 멋진 협업을 하고 있다. 대학교 졸업 작품을 뭐 이렇게까지 하냐는 말도 들었는데, 졸업 작품이라서 더 체계적이고 정확한 방법을 지향하는 것이다. 4년동안 쌓아온 경험을 교수님의 지도 아래 마음껏 표현할 수 있는 중요한 기회를 주먹구구식으로 하기는 싫었다. 그래도 깐깐한 리더의 말에 동감하고 노력해주는 팀원들에게 매주 얘기하지만, 정말 고마울 뿐이다. 최고의 팀 작품이 탄생할 것이라고 믿는다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;졸업작품-팀-프로젝트-Homes의-4주차까지&quot;&gt;&lt;a href=&quot;#졸업작품-팀-프로젝트-Homes의-4주차까지&quot; class=&quot;headerlink&quot; title=&quot;졸업작품 팀 프로젝트, Homes의 4주차까지&quot;&gt;&lt;/a&gt;졸업작품 팀 프로젝트, </summary>
      
    
    
    
    <category term="project" scheme="https://zinirun.github.io/categories/project/"/>
    
    <category term="homes" scheme="https://zinirun.github.io/categories/project/homes/"/>
    
    
    <category term="capstone design" scheme="https://zinirun.github.io/tags/capstone-design/"/>
    
    <category term="homes" scheme="https://zinirun.github.io/tags/homes/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile과 배포 자동화 스크립트 만들기</title>
    <link href="https://zinirun.github.io/2020/09/18/docker-automation-shellscript/"/>
    <id>https://zinirun.github.io/2020/09/18/docker-automation-shellscript/</id>
    <published>2020-09-18T12:51:03.000Z</published>
    <updated>2020-09-18T13:30:48.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="그럴듯한-자동화"><a href="#그럴듯한-자동화" class="headerlink" title="그럴듯한 자동화"></a>그럴듯한 자동화</h2><p>프로젝트를 하다 보면, 깃에서 파일을 수정하고 Docker 이미지를 다시 만들고, 빌드한 이미지로 컨테이너를 실행하여 재배포해야할 때가 많다. 팀 프로젝트를 하면서 원래 있던 자동화 스크립트를 짜집기해서 쓰려다가 이번에 변수를 선언해서 제대로 만들어 놓는게 좋겠다 싶었다.</p><p>실무에서는 Jira, Jenkins 등으로 체계적인 자동화와 버전 관리가 되어있겠지만 팀원이 4명인 프로젝트에서는 이정도면 되겠다고 생각했다.</p><p>현재 프로젝트에 필요한 컨테이너는 DB 컨테이너와 노드 컨테이너이고, docker 안에서 연결되어야 한다. 학교에서 인스턴스를 하나만 주어서, 한 폴더 안에 데이터베이스와 서버 파일이 모두 들어가 있어야 했다. 나는 <code>database-app</code>으로 데이터베이스 파일을 분리했다.</p><h2 id="Database-배포-자동화하기"><a href="#Database-배포-자동화하기" class="headerlink" title="Database 배포 자동화하기"></a>Database 배포 자동화하기</h2><h3 id="MySQL-Dockerfile-만들기"><a href="#MySQL-Dockerfile-만들기" class="headerlink" title="MySQL Dockerfile 만들기"></a>MySQL Dockerfile 만들기</h3><p>같은 디렉토리에 데이터베이스 구축 sql 파일을 넣고, <code>Dockerfile</code>을 작성한다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mysql:<span class="number">5.7</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> &lt;AUTHOR&gt; &lt;github.com/GITHUB-NAME&gt;</span></span><br><span class="line"><span class="keyword">ENV</span> MYSQL_DATABASE=&lt;DB-NAME&gt; \</span><br><span class="line">    MYSQL_ROOT_PASSWORD=&lt;DB-PASSWORD&gt;</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./&lt;SQL-FILENAME&gt;.sql /docker-entrypoint-initdb.d/</span></span><br></pre></td></tr></table></figure><h3 id="Shell-Script-만들어서-자동화하기"><a href="#Shell-Script-만들어서-자동화하기" class="headerlink" title="Shell Script 만들어서 자동화하기"></a>Shell Script 만들어서 자동화하기</h3><p>이제 같은 폴더에 스크립트 파일을 작성한다.</p><p><code>build_n_run.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Build N Run DB Container</span></span><br><span class="line"><span class="comment"># 2020. 09. 18 Zini</span></span><br><span class="line"></span><br><span class="line">docker_username=<span class="string">&quot;&quot;</span></span><br><span class="line">db_image_name=<span class="string">&quot;&quot;</span></span><br><span class="line">db_container_name=<span class="string">&quot;&quot;</span></span><br><span class="line">db_password=<span class="string">&quot;&quot;</span></span><br><span class="line">version=<span class="string">&quot;&quot;</span></span><br><span class="line">port=3306 <span class="comment"># Default MySQL Port: 3306</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;## Automation docker-database build and run ##&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove container</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=&gt; Remove previous container...&quot;</span></span><br><span class="line">docker rm -f <span class="variable">$&#123;db_container_name&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove image</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=&gt; Remove previous image...&quot;</span></span><br><span class="line">docker rmi -f <span class="variable">$&#123;docker_username&#125;</span>/<span class="variable">$&#123;db_image_name&#125;</span>:<span class="variable">$&#123;version&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># new-build/re-build docker image</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=&gt; Build new image...&quot;</span></span><br><span class="line">docker build --tag <span class="variable">$&#123;docker_username&#125;</span>/<span class="variable">$&#123;db_image_name&#125;</span>:<span class="variable">$&#123;version&#125;</span> .</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run container</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=&gt; Run container...&quot;</span></span><br><span class="line">docker run -d -p <span class="variable">$&#123;port&#125;</span>:<span class="variable">$&#123;port&#125;</span> -e MYSQL_ROOT_PASSWORD=<span class="variable">$&#123;db_password&#125;</span> --name <span class="variable">$&#123;db_container_name&#125;</span> <span class="variable">$&#123;docker_username&#125;</span>/<span class="variable">$&#123;db_image_name&#125;</span>:<span class="variable">$&#123;version&#125;</span> --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br></pre></td></tr></table></figure><p>이전에 컨테이너와 이미지가 있다면 삭제하고 재빌드 후 컨테이너를 실행한다. 이제 이 스크립트로 위에 변수만 바꿔주면서 써먹을 수 있다.</p><h2 id="Node-배포-자동화하기"><a href="#Node-배포-자동화하기" class="headerlink" title="Node 배포 자동화하기"></a>Node 배포 자동화하기</h2><h3 id="Node-js-Dockerfile-만들기"><a href="#Node-js-Dockerfile-만들기" class="headerlink" title="Node.js Dockerfile 만들기"></a>Node.js Dockerfile 만들기</h3><p>이제 프로젝트 최상위 폴더에 서버(노드)에 대한 <code>Dockerfile</code>을 작성한다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">10</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install -g yarn; npm install forever -g;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json /src/package.json</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">  <span class="built_in">cd</span> /src; yarn install;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /src</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /src</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> yarn start</span></span><br></pre></td></tr></table></figure><p><code>forever</code>와 <code>yarn</code> 패키지를 먼저 설치하고 패키지를 세팅한다. 예전에는 <code>npm</code>을 썼지만 속도, 성능 면에서 <code>yarn</code>을 사용하려 하고 있다.</p><p><code>package.json</code>의 일부를 보면,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Homes&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.1&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;Homes App&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;app.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;forever app.js&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;&quot;</span><br><span class="line">  &#125;, ...</span><br></pre></td></tr></table></figure><p>이렇게 <code>start</code>에 <code>forever app.js</code>를 설정해뒀다.</p><h3 id="Shell-Script-만들기"><a href="#Shell-Script-만들기" class="headerlink" title="Shell Script 만들기"></a>Shell Script 만들기</h3><p>같은 최상위 폴더에 <code>build_n_run.sh</code>을 작성한다. 이 스크립트는 미리 만들어둔 데이터베이스 컨테이너와 연결되어 있는 노드 컨테이너 배포를 자동화한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Build N Run Container with DB Container</span></span><br><span class="line"><span class="comment"># 2020. 09. 18 Zini</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### You MUST RUN Database Container First ###</span></span><br><span class="line"></span><br><span class="line">docker_username=<span class="string">&quot;&quot;</span></span><br><span class="line">container_name=<span class="string">&quot;&quot;</span></span><br><span class="line">image_name=<span class="string">&quot;&quot;</span></span><br><span class="line">db_container_name=<span class="string">&quot;&quot;</span></span><br><span class="line">version=<span class="string">&quot;&quot;</span></span><br><span class="line">host_port=3000</span><br><span class="line">virtual_port=3000</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;## Automation docker build and run ##&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove container</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=&gt; Remove previous container...&quot;</span></span><br><span class="line">docker rm -f <span class="variable">$&#123;container_name&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove image</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=&gt; Remove previous image...&quot;</span></span><br><span class="line">docker rmi -f <span class="variable">$&#123;docker_username&#125;</span>/<span class="variable">$&#123;image_name&#125;</span>:<span class="variable">$&#123;version&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># new-build/re-build docker image</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=&gt; Build new image...&quot;</span></span><br><span class="line">docker build --tag <span class="variable">$&#123;docker_username&#125;</span>/<span class="variable">$&#123;image_name&#125;</span>:<span class="variable">$&#123;version&#125;</span> .</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run container connected to existing database container</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=&gt; Run container...&quot;</span></span><br><span class="line">docker run -t -d --name <span class="variable">$&#123;container_name&#125;</span> -p <span class="variable">$&#123;host_port&#125;</span>:<span class="variable">$&#123;virtual_port&#125;</span> --link <span class="variable">$&#123;db_container_name&#125;</span>:db -e DATABASE_HOST=db <span class="variable">$&#123;docker_username&#125;</span>/<span class="variable">$&#123;image_name&#125;</span>:<span class="variable">$&#123;version&#125;</span></span><br></pre></td></tr></table></figure><p>데이터베이스 컨테이너와 연결할 필요가 없을 경우 마지막 <code>docker run</code> 부분만 조금 수정하면 된다. 데이터베이스 컨테이너 자동화와 거의 같은데, 연결하는 부분만 조금 다르다.</p><h2 id="그럴듯한-자동화를-마치며"><a href="#그럴듯한-자동화를-마치며" class="headerlink" title="그럴듯한 자동화를 마치며"></a>그럴듯한 자동화를 마치며</h2><p>직접 작성한 스크립트 파일을 실행하기 위해서는 리눅스에서 실행 권한을 주고 실행해야 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x build_n_run.sh</span><br></pre></td></tr></table></figure><p>두 개의 파일에 모두 실행 권한을 주고 실행하면 된다.</p><p>사실 이 과정도 너무 귀찮아서, git 업데이트와 실행 권한 설정을 모두 하는 쉘 스크립트를 또 작성했다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rm -rf &lt;app-name&gt;</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zinirun/&lt;app-name&gt;</span><br><span class="line">chmod +x &lt;app-name&gt;/database-app/build_n_run.sh</span><br><span class="line">chmod +x &lt;app-name&gt;/build_n_run.sh</span><br></pre></td></tr></table></figure><p><em>이제 업데이트할 때도 명령어 칠 생각에 두려워하지 않아도 된다.</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;그럴듯한-자동화&quot;&gt;&lt;a href=&quot;#그럴듯한-자동화&quot; class=&quot;headerlink&quot; title=&quot;그럴듯한 자동화&quot;&gt;&lt;/a&gt;그럴듯한 자동화&lt;/h2&gt;&lt;p&gt;프로젝트를 하다 보면, 깃에서 파일을 수정하고 Docker 이미지를 다시 만들고, </summary>
      
    
    
    
    <category term="cloud" scheme="https://zinirun.github.io/categories/cloud/"/>
    
    <category term="docker" scheme="https://zinirun.github.io/categories/cloud/docker/"/>
    
    
    <category term="docker" scheme="https://zinirun.github.io/tags/docker/"/>
    
    <category term="cloud" scheme="https://zinirun.github.io/tags/cloud/"/>
    
    <category term="linux" scheme="https://zinirun.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>BOJ - 18352 특정 거리의 도시 찾기 (BFS)</title>
    <link href="https://zinirun.github.io/2020/09/18/ps-bfs-boj-18352/"/>
    <id>https://zinirun.github.io/2020/09/18/ps-bfs-boj-18352/</id>
    <published>2020-09-18T07:18:50.000Z</published>
    <updated>2020-09-18T07:27:42.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="특정-거리의-도시-찾기"><a href="#특정-거리의-도시-찾기" class="headerlink" title="특정 거리의 도시 찾기"></a>특정 거리의 도시 찾기</h2><p><a href="https://www.acmicpc.net/problem/18352">문제 Acmicpc</a></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">n,m,k,x=map(int,input().split())</span><br><span class="line">node=[[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(m):</span><br><span class="line">    a,b=map(int,input().split())</span><br><span class="line">    node[a].append(b)</span><br><span class="line"></span><br><span class="line">dist=[<span class="number">-1</span>]*(n+<span class="number">1</span>)</span><br><span class="line">dist[x]=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">q=deque([x])</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">    now=q.popleft()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> node[now]:</span><br><span class="line">        <span class="keyword">if</span> dist[i] == <span class="number">-1</span>:</span><br><span class="line">            dist[i]=dist[now]+<span class="number">1</span></span><br><span class="line">            q.append(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx,d <span class="keyword">in</span> enumerate(dist):</span><br><span class="line">    <span class="keyword">if</span> d == k:</span><br><span class="line">        print(idx)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p><code>모든 도로의 거리는 1</code>에서 너비 우선 탐색을 사용하는게 쉽겠구나라고 생각할 수 있어야 한다.</p><p>너비 우선 탐색은 기본적으로 큐를 이용하므로 파이썬에서는 <code>deque</code>를 사용한다. 기본 스택으로 선언하고 <code>pop(0)</code>을 사용하면 분명히 시간초과가 난다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dist=[<span class="number">-1</span>]*(n+<span class="number">1</span>)</span><br><span class="line">dist[x]=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">q=deque([x])</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">    now=q.popleft()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> node[now]:</span><br><span class="line">        <span class="keyword">if</span> dist[i] == <span class="number">-1</span>:</span><br><span class="line">            dist[i]=dist[now]+<span class="number">1</span></span><br><span class="line">            q.append(i)</span><br></pre></td></tr></table></figure><p>BFS를 구현한 부분이다. 방문했던 노드인지 확인하고 최단 거리를 저장하기 위해 <code>dist</code> 변수를 <code>-1</code>로 초기화하여 선언한다. 이후 덱에서 탐색할 노드를 <code>popleft()</code>하고, 노드의 각 경로를 <code>dist</code>를 검사하여 방문했던 노드인지 확인한 후, 미방문 노드이면 거리를 설정하고 다시 큐에 넣어준다.</p><p>BFS로 풀면 되겠다는 것을 바로 떠올리면 쉽게 풀 수 있지만, 아직 경로 관련 문제에서 이건 DFS, 저건 BFS라고 확신하기가 어렵다. 더 공부해야겠다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;특정-거리의-도시-찾기&quot;&gt;&lt;a href=&quot;#특정-거리의-도시-찾기&quot; class=&quot;headerlink&quot; title=&quot;특정 거리의 도시 찾기&quot;&gt;&lt;/a&gt;특정 거리의 도시 찾기&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.n</summary>
      
    
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/tags/algorithm/"/>
    
    <category term="ps" scheme="https://zinirun.github.io/tags/ps/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 30 - Day 25 Event Capture, Propagation, Bubbling and Once</title>
    <link href="https://zinirun.github.io/2020/09/15/js-course30-25/"/>
    <id>https://zinirun.github.io/2020/09/15/js-course30-25/</id>
    <published>2020-09-15T12:25:35.000Z</published>
    <updated>2020-09-15T12:40:38.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-25-Event-Capture-Propagation-Bubbling-and-Once"><a href="#Day-25-Event-Capture-Propagation-Bubbling-and-Once" class="headerlink" title="Day 25 - Event Capture, Propagation, Bubbling and Once"></a>Day 25 - Event Capture, Propagation, Bubbling and Once</h2><div class="video-container"><iframe src="https://www.youtube.com/embed/F1anRyL37lE" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>이번 과제는 <code>addEventListner</code>로 DOM 객체에 이벤트를 추가할 때 줄 수 있는 옵션들에 대한 것이다.</p><h2 id="Bubbling"><a href="#Bubbling" class="headerlink" title="Bubbling"></a>Bubbling</h2><p>Bubbling에 대한 이해가 필요한데, 특정 DOM 객체에서 이벤트가 발생하면 기본적으로 Bubbling이 발생한다. Bubbling이란 특정 DOM 객체에서만 이벤트가 발생하지 않고 상위 DOM 객체까지도 이벤트가 올라가며 발생하는 것이다.</p><p>간단하게 예시를 들면,</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;click&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>여기서 id가 <code>click</code>인 <code>div</code>에 클릭 이벤트를 추가해서 클릭 이벤트가 발생하면 상위 <code>div</code>, <code>body</code>, <code>html</code>까지 타고 올라가며 이벤트가 발생하는 것이다.</p><h2 id="addEventListener에-옵션-걸기"><a href="#addEventListener에-옵션-걸기" class="headerlink" title="addEventListener에 옵션 걸기"></a><code>addEventListener</code>에 옵션 걸기</h2><p><code>addEventListener</code>에서 추가적인 인자로 옵션을 주어 Bubbling 순서를 통제할 수 있다.</p><p>클릭 시 호출할 함수인 <code>logText</code>를 먼저 만들어보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logText</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.classList.value);</span><br><span class="line">  e.stopPropagation(); <span class="comment">// bubbling 금지</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 <code>div</code> 객체에 click 이벤트를 옵션과 함께 추가한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&quot;click&quot;</span>, logText, &#123;</span><br><span class="line">  <span class="comment">// capture: true ==&gt; down-&gt;up을 up-&gt;down으로</span></span><br><span class="line">  capture: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// unbinding: click 이벤트를 한번만 받음</span></span><br><span class="line">  once: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>capture</code> 속성으로 bubbling의 순서를 역으로 바꿀 수 있다. 기본 설정은 <code>false</code>이며, <code>true</code>로 주면 하위에서 상위 객체로 이벤트가 전달되는 것이 반대로 상위에서 하위 객체로 타고 내려간다.</p><p><code>once</code> 속성으로 <code>click</code> 이벤트를 단 한번만 받을 수 있다. 이 속성 <code>true</code>로 주면 해당 DOM 객체에서의 이벤트는 한 번밖에 실행되지 않는다.</p><h2 id="Bubbling-금지시키기"><a href="#Bubbling-금지시키기" class="headerlink" title="Bubbling 금지시키기"></a>Bubbling 금지시키기</h2><p>하위 객체로든, 상위 객체로든 Bubbling이 발생하지 않게 할 수도 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.stopPropagation();</span><br></pre></td></tr></table></figure><p>DOM 객체에 내장된 <code>stopPropagation()</code>을 호출하면 Bubbling이 발생하지 않는다. 앞에서 작성한 <code>logText</code> 함수로 예를 들면,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logText</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.classList.value);</span><br><span class="line">  e.stopPropagation(); <span class="comment">// bubbling 금지</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 Bubbling을 통제할 수 있다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day-25-Event-Capture-Propagation-Bubbling-and-Once&quot;&gt;&lt;a href=&quot;#Day-25-Event-Capture-Propagation-Bubbling-and-Once&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="javascript30" scheme="https://zinirun.github.io/tags/javascript30/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 30 - Day 24 Sticky Nav</title>
    <link href="https://zinirun.github.io/2020/09/12/js-course30-24/"/>
    <id>https://zinirun.github.io/2020/09/12/js-course30-24/</id>
    <published>2020-09-12T13:33:57.000Z</published>
    <updated>2020-09-12T14:16:51.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-24-Sticky-Nav"><a href="#Day-24-Sticky-Nav" class="headerlink" title="Day 24 - Sticky Nav"></a>Day 24 - Sticky Nav</h2><div class="video-container"><iframe src="https://www.youtube.com/embed/5FLOBCGH3_U" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>이번 과제는 반응형 웹에서 많이 쓰이는 디자인으로, 스크롤할 때 내비게이션 바(메뉴)가 고정되어 내려가고, 로고가 보이는 효과이다.</p><p>이전 과제 중에 <code>scroll</code> 속성을 이용한 과제들이 많았는데, 이번에도 그렇고, 쉬운 편이다.</p><h2 id="CSS-속성-추가하기"><a href="#CSS-속성-추가하기" class="headerlink" title="CSS 속성 추가하기"></a>CSS 속성 추가하기</h2><p>우선 우리가 고정시켜야 하는 내비게이션 바는 <code>&lt;nav&gt;</code>로 감싸져 있다. 특정 시점에서 <code>.fixed-nav</code>라는 class 속성을 추가하면 css 스타일의 변화도 쉽게 끄고 켜는 개념으로 조정할 수 있다.</p><h3 id="상단에-메뉴-고정시키기"><a href="#상단에-메뉴-고정시키기" class="headerlink" title="상단에 메뉴 고정시키기"></a>상단에 메뉴 고정시키기</h3><p>원래의 <code>nav</code> 속성은</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: black;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.5s</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 <code>relative</code> 속성이기 때문에 스크롤을 내리지 않은 상태에서는 그냥 중간에 위치한 메뉴바처럼 생겼다.</p><p>이제 <code>.fixed-nav</code> 속성이 <code>body</code>에 추가된 경우의 속성을 작성하자.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span><span class="selector-class">.fixed-nav</span> <span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">5px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이미 <code>nav</code>는 <code>top: 0</code>이고 <code>fixed</code> 위치 속성으로 바꿔줌으로써 상단에 고정시킬 수 있다.</p><h3 id="로고-보이게-하기"><a href="#로고-보이게-하기" class="headerlink" title="로고 보이게 하기"></a>로고 보이게 하기</h3><p>원래의 로고는</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-class">.logo</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.5s</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">600</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>max-width</code>가 0으로 설정되어 보이지 않는다. 간단하게 <code>.fixed-nav</code> 속성이 body에 추가됐을 때 위에서 한 것과 똑같이 <code>li.logo</code>의 <code>max-width</code> 속성만 바꾸면 된다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fixed-nav</span> <span class="selector-tag">li</span><span class="selector-class">.logo</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>transition: all 0.5s;</code>로 설정되었기 때문에 모든 효과들이 보기 좋게 변한다. <em>(스르륵 변화한다)</em></p><h2 id="JS-작성하기"><a href="#JS-작성하기" class="headerlink" title="JS 작성하기"></a>JS 작성하기</h2><p>이번 자바스크립트 작성은 정말 쉽다. <code>window.scrollY</code>로 스크롤 한 Y 좌표 값(높이값)을 구해서 내비게이션 바의 <code>offsetTop</code>과 비교해주고 class 속성을 넣었다 뺐다 하면 끝난다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nav = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#main&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> topOfNav = nav.offsetTop;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fixNav</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.scrollY &gt; topOfNav) &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.style.paddingTop = nav.offsetHeight + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.classList.add(<span class="string">&quot;fixed-nav&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.style.paddingTop = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.classList.remove(<span class="string">&quot;fixed-nav&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;scroll&quot;</span>, fixNav);</span><br></pre></td></tr></table></figure><p><code>paddingTop</code>을 설정하는 이유는 <code>fixed</code>로 속성이 변경될 때 의도하지 않는 여백이 생겨버려 뚝뚝 끊겨버리기 때문이다.</p><p>이제 부드러운 상단 고정 메뉴바가 완성되었다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day-24-Sticky-Nav&quot;&gt;&lt;a href=&quot;#Day-24-Sticky-Nav&quot; class=&quot;headerlink&quot; title=&quot;Day 24 - Sticky Nav&quot;&gt;&lt;/a&gt;Day 24 - Sticky Nav&lt;/h2&gt;&lt;div clas</summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="javascript30" scheme="https://zinirun.github.io/tags/javascript30/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
</feed>
