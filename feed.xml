<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zinirun</title>
  
  <subtitle>tech blog by Zini</subtitle>
  <link href="https://zinirun.github.io/feed.xml" rel="self"/>
  
  <link href="https://zinirun.github.io/"/>
  <updated>2020-08-27T06:29:13.190Z</updated>
  <id>https://zinirun.github.io/</id>
  
  <author>
    <name>zini</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React 첫번째 프로젝트 - TodoList</title>
    <link href="https://zinirun.github.io/2020/08/27/react-first-todolist/"/>
    <id>https://zinirun.github.io/2020/08/27/react-first-todolist/</id>
    <published>2020-08-27T05:55:36.000Z</published>
    <updated>2020-08-27T06:29:13.190Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2020-08-27-15-23-07.png" alt="todolist"><br><img src="https://github.com/zinirun/first-react-todo/raw/master/images/dev-timelapse.gif" alt="timelapse"></p><div style="text-align:center">개발 타임랩스 은근히 재밌다..</div><h2 id="리액트로-만든-첫번째-프로젝트-투두리스트"><a href="#리액트로-만든-첫번째-프로젝트-투두리스트" class="headerlink" title="리액트로 만든 첫번째 프로젝트, 투두리스트"></a>리액트로 만든 첫번째 프로젝트, 투두리스트</h2><p>항상 뭔가를 배우면 그걸로 프로젝트를 하나 만들어봐야(기왕이면 배포까지 해봐야) 직성이 풀리고 그 다음 주제로 넘어가야 직성이 풀린다. 이번에 리액트 컴포넌트를 배우고 (정말 간단한) TodoList를 구현해보았다.</p><h2 id="파일-구성과-로직"><a href="#파일-구성과-로직" class="headerlink" title="파일 구성과 로직"></a>파일 구성과 로직</h2><p>핵심적인 파일은</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">App.js</span><br><span class="line">CreateTodo.js</span><br><span class="line">TodoList.js</span><br></pre></td></tr></table></figure><p>다음과 같이 3개이다.</p><p>투두리스트를 추가, 토글, 삭제하는 함수는 <code>App.js</code>에 작성되어 있다. <code>App.js</code>에서 앱의 전체적인 구조(<code>&lt;CreateTodo&gt;</code> 컴포넌트와 <code>&lt;TodoList&gt;</code> 컴포넌트)를 렌더링한다.</p><h2 id="핵심-코드-작성하기"><a href="#핵심-코드-작성하기" class="headerlink" title="핵심 코드 작성하기"></a>핵심 코드 작성하기</h2><h3 id="useState-useRef-작성"><a href="#useState-useRef-작성" class="headerlink" title="useState(), useRef() 작성"></a>useState(), useRef() 작성</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [inputs, setInputs] = useState(&#123;</span><br><span class="line">  title: <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [todos, setTodos] = useState([</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    title: <span class="string">&quot;리액트 혼내주기&quot;</span>,</span><br><span class="line">    isImportant: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextId = useRef(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>앱에서 사용하는 변수를 <code>useState()</code>를 사용하여 선언한다. 투두리스트는 할 일(title)과 중요 여부(isImportant)로 구성되어 있다.</p><p>id는 1씩 증가시켜야 하는데, 비렌더링 객체로 관리해주기 위해 <code>useRef()</code>를 사용한다.</p><h3 id="할-일-추가-중요-여부-토글-삭제-구현"><a href="#할-일-추가-중요-여부-토글-삭제-구현" class="headerlink" title="할 일 추가, 중요 여부 토글, 삭제 구현"></a>할 일 추가, 중요 여부 토글, 삭제 구현</h3><h4 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate()"></a>onCreate()</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onCreate = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (title.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newTodo = &#123;</span><br><span class="line">      id: nextId.current,</span><br><span class="line">      title,</span><br><span class="line">    &#125;;</span><br><span class="line">    setTodos([...todos, newTodo]);</span><br><span class="line">    setInputs(&#123;</span><br><span class="line">      title: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    nextId.current += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>CreateTodo</code> 객체에서 <code>onCreate()</code> 함수가 호출되면 입력된 <code>title</code> 값을 <code>useState()</code>의 set 메소드로 추가해준다. <code>setTodo</code>에서 spread 방식으로 배열에 요소를 추가해줬는데, <code>concat()</code> 메소드를 써도 상관없다. 할 일이 추가되었다면 <code>setInputs()</code> 메소드로 사용자가 입력한 값을 초기화한다. 그 후 <code>nextId.current</code>를 1 증가시킨다. (뒤에 <code>.current</code>를 붙이는 이유는 일반적인 숫자 객체가 아닌 <code>useRef()</code>로 선언된 객체이기 때문이다)</p><h5 id="1시간동안-잡은-오류"><a href="#1시간동안-잡은-오류" class="headerlink" title="1시간동안 잡은 오류"></a>1시간동안 잡은 오류</h5><p><code>id</code>를 <code>nextId</code>로 정해주기 위해 계속 작성했으나 정상적으로 <code>id</code>가 선언되지 않고 계속 object 객체로 선언되었다. 바로 뒤에 <code>.current</code>를 붙이지 않아 생긴 오류였다. <code>useRef()</code>로 관리되는 객체는 접근시 항상 <code>.current</code>를 붙어야 한다.</p><h3 id="onRemove"><a href="#onRemove" class="headerlink" title="onRemove()"></a>onRemove()</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onRemove = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  setTodos(todos.filter(<span class="function">(<span class="params">todo</span>) =&gt;</span> todo.id !== id));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Todo</code> 객체에서 <code>onRemove()</code> 함수가 호출되면 <code>id</code>를 인자로 받아서 해당 <code>id</code> 값을 가진 요소를 제외한 배열을 필터링해서 <code>setTodo()</code> 메소드로 변수를 다시 지정한다.</p><h3 id="onToggle"><a href="#onToggle" class="headerlink" title="onToggle()"></a>onToggle()</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onToggle = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  setTodos(</span><br><span class="line">    todos.map(<span class="function">(<span class="params">todo</span>) =&gt;</span></span><br><span class="line">      todo.id === id ? &#123; ...todo, <span class="attr">isImportant</span>: !todo.isImportant &#125; : todo</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>중요 여부를 바꿀 수 있는 <code>onToggle()</code> 객체이다. 위에서 작성한 <code>onRemove()</code> 함수와 작동방식은 비슷한데, <code>id</code>를 인자로 받아 해당 <code>id</code> 값을 가진 요소의 <code>isImportant</code>를 true, false로 바꿔준다.</p><h3 id="TodoList-컴포넌트-작성"><a href="#TodoList-컴포넌트-작성" class="headerlink" title="TodoList 컴포넌트 작성"></a>TodoList 컴포넌트 작성</h3><p><code>TodoList</code> 컴포넌트로 <code>todos</code> 데이터가 들어오면 각각을 매핑하여 <code>Todo</code> 객체로 만들어 반환한다. 사실 이 부분에서 컴포넌트를 효율적으로 짜야 하는 이유를 체감했다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoList</span>(<span class="params">&#123; todos, onRemove, onToggle &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;todolist-wrapper&quot;</span>&gt;</span><br><span class="line">      &#123;todos.map(<span class="function">(<span class="params">todo</span>) =&gt;</span> (</span><br><span class="line">        &lt;Todo</span><br><span class="line">          key=&#123;todo.id&#125;</span><br><span class="line">          todo=&#123;todo&#125;</span><br><span class="line">          onRemove=&#123;onRemove&#125;</span><br><span class="line">          onToggle=&#123;onToggle&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="리액트를-깃허브-페이지에-배포하기"><a href="#리액트를-깃허브-페이지에-배포하기" class="headerlink" title="리액트를 깃허브 페이지에 배포하기"></a>리액트를 깃허브 페이지에 배포하기</h2><p>리액트 프로젝트를 다 만들었다면 깃허브 페이지에 배포하는 것은 일도 아니다. 우선 프로젝트 코드를 깃허브 레파지토리에 커밋, 푸시한다.</p><p>이제 프로젝트에 <code>gh-pages</code> 패키지를 설치한다.</p><p>npm을 사용한다면,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i gh-pages --save-dev</span><br></pre></td></tr></table></figure><p>yarn을 사용한다면,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add gh-pages --dev</span><br></pre></td></tr></table></figure><p>를 입력하면 된다. 이제 <code>package.json</code> 파일을 열어보자. 두가지만 하면 된다.</p><p>첫번째로, <code>homepage</code>를 추가한다. 그냥 끄트머리에</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;gh-pages&quot;: &quot;^3.1.0&quot;</span><br><span class="line">  &#125;, // 밑에서부터 참고해서 추가하면 된다</span><br><span class="line">  &quot;homepage&quot;: &quot;http://&lt;깃허브아이디&gt;.github.io/&lt;레파지토리 이름&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 한 줄을 추가한다.</p><p>두번째로 <code>scripts</code> 항목에 <code>deploy</code>와 <code>predeploy</code>를 추가한다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;react-scripts start&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;react-scripts build&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;react-scripts test&quot;,</span><br><span class="line">    &quot;eject&quot;: &quot;react-scripts eject&quot;,</span><br><span class="line">    <span class="comment">//밑에서부터 deploy, predeploy를 추가한다.</span></span><br><span class="line">    &quot;deploy&quot;: &quot;gh-pages -d build&quot;,</span><br><span class="line">    &quot;predeploy&quot;: &quot;yarn run build&quot; //yarn &lt;-&gt; npm</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p><code>predeploy</code>에는 yarn, npm을 기호에 맞게 사용하자.</p><p>이제 설정은 모두 끝났고, 깃허브 페이지로 배포만 하면 정말 끝이다.</p><p>터미널을 열어</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run deploy <span class="comment"># 또는 npm run deploy</span></span><br></pre></td></tr></table></figure><p>를 입력하고 페이지로 접속해보자.</p><blockquote><p>혹시나 깃허브 페이지에 접속하였는데 readme 파일이 뜬다면 깃허브의 레파지토리 설정으로 접속하여 GitHub Pages의 Source를 <code>gh-pages</code> 브랜치로 설정하고 새로고침하면 리액트 프로젝트가 정상적으로 표시된다.</p></blockquote><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>정말 별 볼일 없는 할 일 리스트지만 하나를 배우면 써먹어보는 습관은 자부심을 느끼게 한다. 맨땅에서 코드를 작성해서 오류도 잡아보고 배포까지 해보면 잊을래야 잊을 수가 없다. 리액트는 정말 매력적이고, 나는 아직 멀었다. 더 노력해야겠다.</p><blockquote><p>모든 코드는 <a href="https://github.com/zinirun/first-react-todo">Github</a>에서 확인할 수 있다.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/2020-08-27-15-23-07.png&quot; alt=&quot;todolist&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://github.com/zinirun/first-react-todo/raw/master/images/dev</summary>
      
    
    
    
    <category term="ReactJS" scheme="https://zinirun.github.io/categories/ReactJS/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="react" scheme="https://zinirun.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Flask 앱 Netlify, Heroku 배포 삽질기</title>
    <link href="https://zinirun.github.io/2020/08/26/flask-deploy-netlify-heroku/"/>
    <id>https://zinirun.github.io/2020/08/26/flask-deploy-netlify-heroku/</id>
    <published>2020-08-26T05:38:15.000Z</published>
    <updated>2020-08-26T06:06:49.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="결론은-안된다"><a href="#결론은-안된다" class="headerlink" title="결론은 안된다."></a>결론은 안된다.</h2><p>학교에서 대여해준 NHN Toast Cloud 서버가 8월 말에 사용이 중지된다는 얘기를 듣고 AWS에 입문해볼까 하다가 어차피 토이 프로젝트이니 이 정도는 <a href="https://www.netlify.com/">Netlify</a>나 <a href="https://herokuapp.com/">Heroku</a>에 서비스해도 될 것 같아서 배포를 하려 했는데, 딱 거기서 생각을 멈췄어야 했다. 아직도 머리가 얼얼하다.</p><blockquote><p>결론부터 말하자면 정적 웹(파일 업데이트가 없고 화면 view만 존재하는 웹)이 아니라면 헤로쿠든 네트리파이든 쓰면 안된다!!!</p></blockquote><p><img src="/images/2020-08-26-14-43-29.png"></p><p>정확히 오후 한시부터 밤 열시까지 이 삽질을 했다.</p><h2 id="안된다"><a href="#안된다" class="headerlink" title="안된다."></a>안된다.</h2><p>Flask는 기본적으로 파이썬을 개발용 웹으로 서비스해주기 때문에 <code>gunicorn</code>, <code>wsgi</code>같은 웹팩을 이용해서 사이트를 외부에 노출시켜야 한다.</p><p>플라스크 기반의 블로그가 네트리파이나 헤로쿠에서 잘 돌아가는 이유는, 지금 내가 쓰고 있는 헥소나 지킬과 같은 블로그 툴은 <code>git push</code> 과정으로 배포하는 방식이라 결국 푸시할 때마다 정적 뷰가 생성되기 때문에 잘 사용되는 것이다.</p><p>내가 옮기려는 Flask 앱은 이미지를 업로드하면 그 이미지를 분석해주는 서비스이기 때문에 이미지 “업로드”는 헤로쿠, 네트리파이와 같은 PaaS 클라우드에서는 할 수 없다..</p><p><img src="/images/2020-08-26-14-49-25.png"></p><p>네트리파이 개발자가 client-side가 아닌 server-side 앱은 호스팅이 안된다고 한다.</p><p>정적인 웹은 얼마든지 호스팅할 수 있다. 억울해서 이거라도 적어놓으려 한다.</p><h2 id="안되지만"><a href="#안되지만" class="headerlink" title="안되지만,"></a>안되지만,</h2><p>파일 업로드 등의 로직이 없는 Static Web은 네트리파이, 헤로쿠에서 얼마든지 서비스할 수 있는데, 일단 Flask 앱은 다 만들었다고 가정하고 이를 조금만 바꿔보자.</p><p>네트리파이는 <code>Flask-Freeze</code>를 이용하면 되고, 헤로쿠는 <code>gunicorn</code>선에서 서비스할 수 있다. 네트리파이는 <a href="https://medium.com/@francescaguiducci/how-to-build-a-simple-personal-website-with-python-flask-and-netlify-d800c97c283d">이 글</a>에 잘 정리되어 있으니 따라하면 되고, 헤로쿠만 정리해보겠다.</p><h3 id="헤로쿠에서-Flask-배포하기"><a href="#헤로쿠에서-Flask-배포하기" class="headerlink" title="헤로쿠에서 Flask 배포하기"></a>헤로쿠에서 Flask 배포하기</h3><p>우선 메인 앱(py)을 실행하는 부분이</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>다음과 같이 되어 있는지부터 확인해보자. <code>port</code>를 임의로 건드리면 안된다.</p><p>또한 앱을 라우팅하는 파이썬 파일에는</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br></pre></td></tr></table></figure><p>당연히 <code>app</code>을 <code>Flask</code>화 해야한다.</p><p>그리고 프로젝트 최상위 폴더에 <code>gunicorn</code> 관련 설정 파일을 하나 만드는데 확장자 없는 <code>Procfile</code> 파일을 만들어서</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web: gunicorn &lt;메인 앱 이름&gt;:app</span><br></pre></td></tr></table></figure><p>이렇게 한 줄의 텍스트를 넣고 저장한다. 이 <code>Procfile</code>을 헤로쿠에서 <code>web</code>으로 인식하고 <code>gunicorn</code> 기반으로 웹을 외부에 노출시키게 된다.</p><p>이제 <code>requirements.txt</code>와 <code>runtime.txt</code>만 설정하면 된다. 모두 프로젝트 최상위 폴더에 위치시킨다. 기본적으로 <code>Flask</code>와 웹팩 모듈들을 넣어준다. (파이썬 3.6.1 버전 기준이므로 버전에 맞게 바꿔준다)</p><p><code>requirements.txt</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">click&#x3D;&#x3D;6.7</span><br><span class="line">Flask&#x3D;&#x3D;0.12.2</span><br><span class="line">gunicorn&#x3D;&#x3D;19.7.1</span><br><span class="line">itsdangerous&#x3D;&#x3D;0.24</span><br><span class="line">Jinja2&#x3D;&#x3D;2.9.6</span><br><span class="line">MarkupSafe&gt;1.0</span><br><span class="line">Werkzeug&#x3D;&#x3D;0.12.2</span><br></pre></td></tr></table></figure><p>이제 파이썬 버전만 설정하면 정말 끝이다.</p><p><code>runtime.txt</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python-3.6.1</span><br></pre></td></tr></table></figure><p>이제 헤로쿠에 깃을 연결하고 배포하면 된다. 끝.</p><p><img src="/images/2020-08-26-15-03-10.png"></p><p>난 여기까지는 호스팅이 되는데 파일을 업로드하면 (당연히)</p><p><img src="/images/2020-08-26-15-04-09.png"></p><p>헤로쿠에서 파일 리퀘스트를 거부하는 500 Error가 발생한다.</p><p>이제 뭔가를 할 때는 되는지 안되는지부터 보고 삽질을 하던지 해야겠다.. 아무튼 내가 옮기려 했던 앱은 AWS에서 서비스 할 예정이다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;결론은-안된다&quot;&gt;&lt;a href=&quot;#결론은-안된다&quot; class=&quot;headerlink&quot; title=&quot;결론은 안된다.&quot;&gt;&lt;/a&gt;결론은 안된다.&lt;/h2&gt;&lt;p&gt;학교에서 대여해준 NHN Toast Cloud 서버가 8월 말에 사용이 중지된다는 얘기</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Javascript 30 - Day 12 Key Sequence Detection</title>
    <link href="https://zinirun.github.io/2020/08/26/js-course30-12/"/>
    <id>https://zinirun.github.io/2020/08/26/js-course30-12/</id>
    <published>2020-08-26T05:22:24.000Z</published>
    <updated>2020-08-26T05:36:57.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-12-Key-Sequence-Detection"><a href="#Day-12-Key-Sequence-Detection" class="headerlink" title="Day 12 - Key Sequence Detection"></a>Day 12 - Key Sequence Detection</h2><div class="video-container"><iframe src="https://www.youtube.com/embed/A5eVOIqGLU" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>윈도우에 키보드 이벤트를 걸고 특정 비밀 문자열을 만들어서 그 문자열을 입력하면 <code>cornify</code> 효과가 나타나는 과제이다.</p><p><img src="/images/2020-08-26-14-24-19.png"></p><p>귀여워서 계속 쳐봤다. 이게 대체 무슨 라이브러리일까 싶어서 <a href="https://www.cornify.com/">cornify</a> 사이트를 가보니 어떤 컨셉인지는 대충 알 것 같다..</p><h2 id="Full-script"><a href="#Full-script" class="headerlink" title="Full script"></a>Full script</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pressed = [];</span><br><span class="line"><span class="keyword">const</span> secretCode = <span class="string">&quot;zinirun&quot;</span>;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;keyup&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.key);</span><br><span class="line">  pressed.push(e.key);</span><br><span class="line">  <span class="keyword">if</span> (pressed.length &gt; secretCode.length) &#123;</span><br><span class="line">    pressed.splice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pressed.join(<span class="string">&quot;&quot;</span>) === secretCode) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;DING DING!&quot;</span>);</span><br><span class="line">    cornify_add();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(pressed);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이번 Day 12 과제는 지금까지의 과제를 잘 이해했다면 쉽게 구현할 수 있었다. <code>pressed</code>라는 키를 저장해둘 배열을 만들어 입력된 키 값을 넣어주면 되는데, <code>secretCode</code>의 길이에 맞게 잘라준다. (자르는 과정없이 모든 키를 배열에 푸시한다면 비밀 문자열의 입력 여부를 파악할 수 없으니까)</p><p><code>pressed</code> 배열을 자르는 코드는 <code>splice</code> 메소드를 이용하는데, 제작자와는 다르게 코드를 짰다. 원래는 다음과 같다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pressed.splice(-secretCode.length - <span class="number">1</span>, pressed.length - secretCode.length);</span><br></pre></td></tr></table></figure><p>다소 코드가 이해가 어려워서 내 방식대로 짰는데, 결과는 똑같다. <code>splice</code> 메소드는 첫번째 인자의 인덱스부터 두번째 인자의 개수까지 배열 요소를 삭제한다. 그러니까 내가 작성한 <code>pressed.splice</code>는 특정 조건일 때 인덱스 0을 삭제하고 앞으로 밀어주는 것이다.</p><p>이제 <code>pressed</code> 배열을 <code>secretCode</code>와 비교만 해주면 된다. 배열 요소를 한 문자열로 만들기 위해 <code>join(&#39;&#39;)</code>을 사용한다. 파이썬의 <code>&#39;&#39;.join()</code>과 같은 메소드인 것 같다. 그리고 <code>secretCode</code>와 대조하는데, 정답지의 코드는</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pressed.join(<span class="string">&quot;&quot;</span>).includes(secretCode)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;DING DING!&quot;</span>);</span><br><span class="line">  cornify_add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 <code>includes</code>를 이용하여 비교하는데, 결국 <code>===</code>를 사용해서 일치 여부를 판단하는 것이 더 낫다고 생각해서(어차피 <code>pressed</code> 배열은 <code>secretCode</code>의 길이만큼만 저장되고 포함되는지 여부가 궁금한게 아니고 일치하는지 여부가 궁금한거니까) 나는 <code>===</code>를 사용했다. 어떻게 하든 결과는 같다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day-12-Key-Sequence-Detection&quot;&gt;&lt;a href=&quot;#Day-12-Key-Sequence-Detection&quot; class=&quot;headerlink&quot; title=&quot;Day 12 - Key Sequence Detection&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="javascript30" scheme="https://zinirun.github.io/tags/javascript30/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 30 - Day 11 Custom Video Player</title>
    <link href="https://zinirun.github.io/2020/08/26/js-course30-11/"/>
    <id>https://zinirun.github.io/2020/08/26/js-course30-11/</id>
    <published>2020-08-25T15:59:36.000Z</published>
    <updated>2020-08-25T17:04:46.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-11-Custom-Video-Player"><a href="#Day-11-Custom-Video-Player" class="headerlink" title="Day 11 - Custom Video Player"></a>Day 11 - Custom Video Player</h2><div class="video-container"><iframe src="https://www.youtube.com/embed/yx-HYerClEA" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>비디오 플레이어를 직접 구현해보는 과제이다. 구현이 엄청 복잡할 줄 알았는데, <code>video</code> 태그에 대한 메소드들만 적당히 다룰 줄 안다면 구현하기 어렵지는 않을 것 같다.</p><p><img src="/images/2020-08-26-01-18-04.png"></p><p>여느 사이트에서나 볼 수 있는 비디오 플레이어를 플레이 버튼, 볼륨 조절, 배속 조절, 스킵, 재생 진행바까지 구현하는 것이 목표이다.</p><h3 id="재생"><a href="#재생" class="headerlink" title="재생"></a>재생</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">togglePlay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> method = video.paused ? <span class="string">&quot;play&quot;</span> : <span class="string">&quot;pause&quot;</span>;</span><br><span class="line">  video[method]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>처음에 보면 대체 무슨 말인가 할 수도 있다.</p><p>이 코드는 정확히 밑의 코드와 같다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">togglePlay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (video.paused) &#123;</span><br><span class="line">    video.play();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    video.pause();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사실 난 가독성은 밑의 코드가 더 나은 것 같다.</p><h4 id="이벤트-걸기"><a href="#이벤트-걸기" class="headerlink" title="이벤트 걸기"></a>이벤트 걸기</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">video.addEventListener(<span class="string">&quot;click&quot;</span>, togglePlay);</span><br><span class="line">toggle.addEventListener(<span class="string">&quot;click&quot;</span>, togglePlay);</span><br></pre></td></tr></table></figure><p>비디오를 클릭하나 재생버튼을 클릭하나 실행하는 함수는 같아야 한다.</p><h3 id="재생-버튼-변경"><a href="#재생-버튼-변경" class="headerlink" title="재생 버튼 변경"></a>재생 버튼 변경</h3><p>이제 재생 여부가 바뀔 때마다 삼각형 플레이 버튼과 일시정지 버튼을 서로 바꿔준다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> icon = <span class="built_in">this</span>.paused ? <span class="string">&quot;►&quot;</span> : <span class="string">&quot;❚ ❚&quot;</span>;</span><br><span class="line">  toggle.textContent = icon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="이벤트-걸기-1"><a href="#이벤트-걸기-1" class="headerlink" title="이벤트 걸기"></a>이벤트 걸기</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">video.addEventListener(<span class="string">&quot;play&quot;</span>, updateButton);</span><br><span class="line">video.addEventListener(<span class="string">&quot;pause&quot;</span>, updateButton);</span><br></pre></td></tr></table></figure><p>video 객체에는 <code>play</code>, <code>pause</code> 이벤트가 있다.(있더라)</p><h3 id="스킵"><a href="#스킵" class="headerlink" title="스킵"></a>스킵</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skip</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  video.currentTime += <span class="built_in">parseFloat</span>(<span class="built_in">this</span>.dataset.skip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>video.currentTime</code>으로 현재 재생 시간을 조절할 수 있다. <code>dataset</code>은 여전히 많이 사용되는 것 같으니 다시 상기하자.</p><h4 id="이벤트-걸기-2"><a href="#이벤트-걸기-2" class="headerlink" title="이벤트 걸기"></a>이벤트 걸기</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skipButtons.forEach(<span class="function">(<span class="params">button</span>) =&gt;</span> button.addEventListener(<span class="string">&quot;click&quot;</span>, skip));</span><br></pre></td></tr></table></figure><p><code>forEach</code> 구문은 이제 물구나무 서서도 작성할 줄 알아야 한다.</p><h3 id="볼륨-배속-조절"><a href="#볼륨-배속-조절" class="headerlink" title="볼륨, 배속 조절"></a>볼륨, 배속 조절</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRangeUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  video[<span class="built_in">this</span>.name] = <span class="built_in">this</span>.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>볼륨, 배속 조절은 모두 <code>input type=&quot;range&quot;</code>로 만들어졌기 때문에 DOM 객체의 name과 value를 가져와서 한 함수로 각각을 모두 조절할 수 있다.</p><h4 id="이벤트-걸기-3"><a href="#이벤트-걸기-3" class="headerlink" title="이벤트 걸기"></a>이벤트 걸기</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ranges.forEach(<span class="function">(<span class="params">range</span>) =&gt;</span> range.addEventListener(<span class="string">&quot;change&quot;</span>, handleRangeUpdate));</span><br><span class="line">ranges.forEach(<span class="function">(<span class="params">range</span>) =&gt;</span></span><br><span class="line">  range.addEventListener(<span class="string">&quot;mousemove&quot;</span>, handleRangeUpdate)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>ranges</code> 객체는 볼륨, 배속 조절 2가지 태그를 모두 포함한다. <code>mousemove</code>에도 이벤트를 거는 이유는 드래그 상태로 움직일 때 실시간으로 바꿔야 하니까.</p><h3 id="재생-진행바-시간-조절"><a href="#재생-진행바-시간-조절" class="headerlink" title="재생 진행바 (시간 조절)"></a>재생 진행바 (시간 조절)</h3><p>우선 재생 진행바를 클릭할 때 해당 위치로 재생 시간을 조절하기 위해 <code>scrub</code> 함수를 작성한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrub</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> scrubTime = (e.offsetX / progress.offsetWidth) * video.duration;</span><br><span class="line">  video.currentTime = scrubTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이벤트를 받는 DOM 객체의 x 좌표와 가로 크기, 비디오 재생 시간으로 재생 시간을 설정한다. 이 함수는 마우스 드래그, 클릭 이벤트에 모두 적용되어야 한다.</p><h4 id="이벤트-걸기-4"><a href="#이벤트-걸기-4" class="headerlink" title="이벤트 걸기"></a>이벤트 걸기</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mousedown = <span class="literal">false</span>;</span><br><span class="line">progress.addEventListener(<span class="string">&quot;click&quot;</span>, scrub);</span><br><span class="line">progress.addEventListener(<span class="string">&quot;mousemove&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> mousedown &amp;&amp; scrub(e));</span><br><span class="line">progress.addEventListener(<span class="string">&quot;mousedown&quot;</span>, <span class="function">() =&gt;</span> (mousedown = <span class="literal">true</span>));</span><br><span class="line">progress.addEventListener(<span class="string">&quot;mouseup&quot;</span>, <span class="function">() =&gt;</span> (mousedown = <span class="literal">false</span>));</span><br></pre></td></tr></table></figure><p>여기서 <code>mousedown &amp;&amp; scrub(e)</code>은 <code>mousemove</code> 이벤트일 때 <code>mousedown</code>이면 <code>scrub</code> 함수를 실행한다. 신박하다.</p><h3 id="재생-진행바-업데이트"><a href="#재생-진행바-업데이트" class="headerlink" title="재생 진행바 (업데이트)"></a>재생 진행바 (업데이트)</h3><p>이제 재생이 진행될 때 진행바도 같이 올라가면 끝이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleProgress</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> percent = (video.currentTime / video.duration) * <span class="number">100</span>;</span><br><span class="line">  progressBar.style.flexBasis = <span class="string">`<span class="subst">$&#123;percent&#125;</span>%`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="이벤트-걸기-5"><a href="#이벤트-걸기-5" class="headerlink" title="이벤트 걸기"></a>이벤트 걸기</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">video.addEventListener(<span class="string">&quot;timeupdate&quot;</span>, handleProgress);</span><br></pre></td></tr></table></figure><p>현재 재생 시간이 바뀔 때 마다 발생하는 <code>timeupdate</code>라는 이벤트도 있다.(있더라)</p><h2 id="응용"><a href="#응용" class="headerlink" title="응용"></a>응용</h2><h3 id="전체화면-만들기"><a href="#전체화면-만들기" class="headerlink" title="전체화면 만들기"></a>전체화면 만들기</h3><p><img src="/images/2020-08-26-02-04-41.png"></p><p>전체화면 만들기도 마지막에 해보라고 해서 만들어봤다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fullButton = player.querySelector(<span class="string">&quot;#fullscreen&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleFullScreen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (video.requestFullScreen) &#123;</span><br><span class="line">    video.requestFullScreen();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (video.webkitRequestFullScreen) &#123;</span><br><span class="line">    video.webkitRequestFullScreen();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (video.mozRequestFullScreen) &#123;</span><br><span class="line">    video.mozRequestFullScreen();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fullButton.addEventListener(<span class="string">&quot;click&quot;</span>, toggleFullScreen);</span><br></pre></td></tr></table></figure><p>구글링하니까 <code>requestFullScreen</code> 이라는 메소드가 있었고, 이벤트 거는건 어렵지 않았다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day-11-Custom-Video-Player&quot;&gt;&lt;a href=&quot;#Day-11-Custom-Video-Player&quot; class=&quot;headerlink&quot; title=&quot;Day 11 - Custom Video Player&quot;&gt;&lt;/a&gt;Day 11</summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="javascript30" scheme="https://zinirun.github.io/tags/javascript30/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - 정렬 (선택/삽입/퀵/계수/Python sort lambda)</title>
    <link href="https://zinirun.github.io/2020/08/24/ps-summary-sort-1/"/>
    <id>https://zinirun.github.io/2020/08/24/ps-summary-sort-1/</id>
    <published>2020-08-24T13:16:03.000Z</published>
    <updated>2020-08-24T14:43:04.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="정렬-알고리즘"><a href="#정렬-알고리즘" class="headerlink" title="정렬 알고리즘"></a>정렬 알고리즘</h1><p>정렬이란 데이터를 특정한 기준에 따라 순서대로 나열하는 것이다. 이진탐색의 전처리 과정이기도 하고, PS(Problem Solving)에서 빠지지 않는 유형의 알고리즘이다. 나는 선택 정렬은 검색 없이도 구현할 수 있었지만 삽입, 퀵, 계수 정렬은 직접 코딩하기엔 애매한 지식을 갖고 있었다. (항상 구글링해서 써먹었다) 난 알고리즘 대회 입상자가 목표가 아니라, 어느정도의 PS 실력을 갖춰 기업 코딩 테스트에 통과하는 것을 목표로 하기 때문에 각 정렬에 대한 기본적인 코드 작성, 평균 시간복잡도 정도만 인지하고 문제 풀이에 집중했다.</p><h2 id="선택-정렬"><a href="#선택-정렬" class="headerlink" title="선택 정렬"></a>선택 정렬</h2><blockquote><p>시간복잡도 - <code>O(N^2)</code></p></blockquote><p>가장 원시적인 방법으로, 매번 가장 작은 것을 선택한다는 의미에서 선택 정렬 알고리즘이라고 한다. 가장 작은 것을 선택해서 앞으로 보내는 과정을 모든 요소에 대해 반복하면 전체 데이터의 정렬이 이루어진다. 가장 무식한 방법이라고 하지만 PS를 하다보면 특정 리스트에서 가장 작은 데이터를 찾는 일이 흔하므로 선택 정렬 코드에 익숙해져야 한다.</p><h3 id="선택정렬-1"><a href="#선택정렬-1" class="headerlink" title="선택정렬 1"></a>선택정렬 1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">    min_index=i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(array)):</span><br><span class="line">        <span class="keyword">if</span> array[j]&lt;array[min_index]:</span><br><span class="line">            min_index=j</span><br><span class="line">    array[i], array[min_index] = array[min_index], array[i]</span><br><span class="line"></span><br><span class="line">print(array)</span><br></pre></td></tr></table></figure><h3 id="선택정렬-2"><a href="#선택정렬-2" class="headerlink" title="선택정렬 2"></a>선택정렬 2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(array)):</span><br><span class="line">        <span class="keyword">if</span> array[i]&gt;array[j]:</span><br><span class="line">            array[i], array[j] = array[j], array[i]</span><br><span class="line"></span><br><span class="line">print(array)</span><br></pre></td></tr></table></figure><h2 id="삽입-정렬"><a href="#삽입-정렬" class="headerlink" title="삽입 정렬"></a>삽입 정렬</h2><blockquote><p>시간복잡도 - 최선(정렬된 상태): <code>O(N)</code>, 최악: <code>O(N^2)</code></p></blockquote><p>삽입 정렬은 특정한 데이터를 적절한 위치에 삽입한다는 의미에서 삽입정렬이라고 한다. 특정한 데이터가 적절한 위치에 들어가기 전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다. 정렬된 리스트에서 적절한 위치를 찾은 뒤에, 그 위치에 삽입된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(array)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> array[j] &lt; array[j<span class="number">-1</span>]:</span><br><span class="line">            array[j], array[j<span class="number">-1</span>]=array[j<span class="number">-1</span>], array[j]</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(array)</span><br></pre></td></tr></table></figure><p>일반적인 경우(위 처럼)에 인덱스 0인 요소를 기준으로 잡아 1부터의 요소부터 적절한 위치를 판단한다.</p><h2 id="퀵-정렬"><a href="#퀵-정렬" class="headerlink" title="퀵 정렬"></a>퀵 정렬</h2><blockquote><p>시간복잡도 - 평균: <code>O(NlogN)</code>, 최악: <code>O(N^2)</code></p></blockquote><div class="video-container"><iframe src="https://www.youtube.com/embed/Hoixgm4-P4M" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>퀵 정렬은 가장 많이 사용되는 알고리즘이다. 병합정렬과 속도는 비슷하다. 퀵 정렬에는 피벗(pivot)이 사용된다. 큰 숫자, 작은 숫자를 교환할 때 교환하기 위한 기준이 바로 피벗이다. 사실 퀵 정렬을 글로만 이해하기는 쉽지 않고, 나는 위 영상을 참고했다.</p><h3 id="퀵-정렬-1-호어-분할-방식-정석"><a href="#퀵-정렬-1-호어-분할-방식-정석" class="headerlink" title="퀵 정렬 1 - 호어 분할 방식 (정석)"></a>퀵 정렬 1 - 호어 분할 방식 (정석)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">array, start, end</span>):</span></span><br><span class="line">    <span class="keyword">if</span> start&gt;=end: <span class="keyword">return</span></span><br><span class="line">    pivot=start</span><br><span class="line">    left=start+<span class="number">1</span></span><br><span class="line">    right=end</span><br><span class="line">    <span class="keyword">while</span> left&lt;=right:</span><br><span class="line">        <span class="keyword">while</span> left&lt;=end <span class="keyword">and</span> array[left]&lt;=array[pivot]: left+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right&gt;start <span class="keyword">and</span> array[right]&gt;=array[pivot]: right-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left&gt;right: array[right],array[pivot]=array[pivot],array[right]</span><br><span class="line">        <span class="keyword">else</span>: array[left],array[right]=array[right],array[left]</span><br><span class="line">    quick_sort(array,start,right<span class="number">-1</span>)</span><br><span class="line">    quick_sort(array,right+<span class="number">1</span>,end)</span><br><span class="line"></span><br><span class="line">quick_sort(array,<span class="number">0</span>,len(array)<span class="number">-1</span>)</span><br><span class="line">print(array)</span><br></pre></td></tr></table></figure><p>recursive 함수를 사용하는데 피벗을 기준으로 왼쪽(피봇보다 작은 데이터), 오른쪽(피봇보다 큰 데이터)로 나눠 재귀를 반복해서 하나의 정렬된 리스트로 만들어낸다.</p><h3 id="퀵-정렬-2-파이썬스러운-방식"><a href="#퀵-정렬-2-파이썬스러운-방식" class="headerlink" title="퀵 정렬 2 - 파이썬스러운 방식"></a>퀵 정렬 2 - 파이썬스러운 방식</h3><p>파이썬스럽게 바꾼 퀵 정렬 코드도 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort2</span>(<span class="params">array</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(array)&lt;=<span class="number">1</span>: <span class="keyword">return</span> array</span><br><span class="line">    pivot=array[<span class="number">0</span>]</span><br><span class="line">    tail=array[<span class="number">1</span>:] <span class="comment"># list excludes the pivot</span></span><br><span class="line">    left_=[x <span class="keyword">for</span> x <span class="keyword">in</span> tail <span class="keyword">if</span> x&lt;=pivot] <span class="comment"># left divided part</span></span><br><span class="line">    right_=[x <span class="keyword">for</span> x <span class="keyword">in</span> tail <span class="keyword">if</span> x&gt;pivot] <span class="comment"># right divided part</span></span><br><span class="line">    <span class="keyword">return</span> quick_sort2(left_)+[pivot]+quick_sort2(right_)</span><br><span class="line"></span><br><span class="line">print(quick_sort2(array))</span><br></pre></td></tr></table></figure><p>이 코드는 [퀵 정렬 1]보다는 시간 면에서 조금 비효율적이지만 더 직관적이고 기억하기 쉽다는 장점이 있다.</p><h2 id="계수정렬"><a href="#계수정렬" class="headerlink" title="계수정렬"></a>계수정렬</h2><blockquote><p>시간복잡도 - <code>O(N+K)</code></p></blockquote><p>계수 정렬 알고리즘은 특정 조건이 부합할 때만 사용할 수 있지만 매우 빠른 알고리즘이다. 간단하게 무작위로 배치된 정수 0~100까지의 데이터가 주어지면 101까지의 0으로 초기화한 배열을 만들고 정렬해야할 리스트를 순회하며 카운트하여 새로 만든 카운트용 배열의 숫자를 1씩 증가시킨다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">count=[<span class="number">0</span>]*(max(array)+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">    count[i]+=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(count)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(count[i]):</span><br><span class="line">        print(i, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><p>데이터의 범위가 한정되어 있다면 효과적으로 사용할 수 있으며 모든 알고리즘 중에서 가장 빠른 수준으로 동작한다. (비슷한 정렬 알고리즘으로 기수 정렬이 있다) 그러나 시간복잡도 면에서는 효율적이지만 같은 배열 크기 만큼의 카운트 배열을 하나 더 만들어야 하므로 공간복잡도 면에서는 비효율성을 초래할 수도 있으니 상황에 맞게 사용하자.</p><h2 id="파이썬-기본-정렬-알고리즘-sort"><a href="#파이썬-기본-정렬-알고리즘-sort" class="headerlink" title="파이썬 기본 정렬 알고리즘 sort()"></a>파이썬 기본 정렬 알고리즘 <code>sort()</code></h2><blockquote><p>시간복잡도 - <code>O(NlogN)</code></p></blockquote><p>파이썬의 기본 정렬 라이브러리인 <code>sort()</code>는 병합 정렬을 기반으로 만들어졌고, 시간복잡도는 <code>O(NlogN)</code>을 보장한다.</p><p>기본적인 사용법은 <code>sort(배열)</code>이며 배열 요소가 2개 이상인 경우 다음과 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">5</span>, <span class="number">1</span>), (<span class="number">5</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">b=sorted(a)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">c=sorted(a, key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">d=sorted(a, key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">e=sorted(a, key=<span class="keyword">lambda</span> x:(x[<span class="number">0</span>],x[<span class="number">1</span>]))</span><br><span class="line">print(e)</span><br></pre></td></tr></table></figure><p><code>lambda</code>를 이용하면 배열 요소의 특정 인덱스를 기준으로 정렬 기준을 정할 수 있다. 마지막 <code>e</code>는 인덱스 0을 기준으로 정렬하고, 인덱스 1인 기준으로 정렬하는 <code>lambda</code> 사용의 예시이다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;정렬-알고리즘&quot;&gt;&lt;a href=&quot;#정렬-알고리즘&quot; class=&quot;headerlink&quot; title=&quot;정렬 알고리즘&quot;&gt;&lt;/a&gt;정렬 알고리즘&lt;/h1&gt;&lt;p&gt;정렬이란 데이터를 특정한 기준에 따라 순서대로 나열하는 것이다. 이진탐색의 전처리 과정이기</summary>
      
    
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/tags/algorithm/"/>
    
    <category term="ps" scheme="https://zinirun.github.io/tags/ps/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 30 - Day 10 JS Checkbox Challenge!</title>
    <link href="https://zinirun.github.io/2020/08/24/js-course30-10/"/>
    <id>https://zinirun.github.io/2020/08/24/js-course30-10/</id>
    <published>2020-08-24T06:52:05.000Z</published>
    <updated>2020-08-24T07:09:46.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-10-JS-Checkbox-Challenge"><a href="#Day-10-JS-Checkbox-Challenge" class="headerlink" title="Day 10 - JS Checkbox Challenge!"></a>Day 10 - JS Checkbox Challenge!</h2><div class="video-container"><iframe src="https://www.youtube.com/embed/RIPYsKx1iiU" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>이번 과제는 <code>Shift</code> 키 이벤트로 <code>Checkbox</code> 객체를 다중 선택할 수 있게 한다. 예를 들어, Gmail, 윈도우의 개체를 선택하고 <code>Shift</code>키와 함께 선택한 요소에서부터 다음에 선택한 요소까지 다중으로 선택되는 기능을 구현하는 것이다.</p><h3 id="css-속성"><a href="#css-속성" class="headerlink" title="css + 속성"></a>css + 속성</h3><p>우선 css부터 이해가 필요하다. 체크박스 객체가 선택되었을 때 옆에 딸린 <code>p</code> 객체를 어떻게 줄을 그을 것인지, 물론 Javascript로도 할 수 있지만 css의 기본 속성으로도 구현할 수 있다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> + <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f9f9f9</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: line-through;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>간단하다. <code>input</code> 객체가 <code>checked</code> 상태일 때 <code>+</code>를 통해서 <code>p</code>의 css 속성을 제어할 수 있다. <code>checked</code> 말고도 <code>hover</code>, <code>focus</code> 등의 여러가지 속성이 많다.</p><h3 id="Script-Part"><a href="#Script-Part" class="headerlink" title="Script Part"></a>Script Part</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> checkboxes = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.inbox input[type=&quot;checkbox&quot;]&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lastChecked;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleCheck</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> inBetween = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (e.shiftKey &amp;&amp; <span class="built_in">this</span>.checked) &#123;</span><br><span class="line">    checkboxes.forEach(<span class="function"><span class="params">checkbox</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(checkbox);</span><br><span class="line">      <span class="keyword">if</span> (checkbox === <span class="built_in">this</span> || checkbox === lastChecked) &#123;</span><br><span class="line">        inBetween = !inBetween;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Starting to check them in between!&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (inBetween) &#123;</span><br><span class="line">        checkbox.checked = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  lastChecked = <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkboxes.forEach(<span class="function"><span class="params">checkbox</span> =&gt;</span> checkbox.addEventListener(<span class="string">&#x27;click&#x27;</span>, handleCheck));</span><br></pre></td></tr></table></figure><p>우선 체크박스 객체 전체를 선언하고 마지막에 체크된 객체를 저장하기 위해 <code>lastChecked</code>를 따로 만든다.</p><p>이제 체크박스들에 <code>handleCheck()</code> 함수를 이벤트로 걸어주는데, <code>inBetween</code>을 그냥 보면 이해가 어려울 것이다.</p><p>완성된 예제를 잘 생각해보자. 마지막에 선택한 체크박스 객체와 지금 클릭한 체크박스 객체 사이를 <code>checked</code>로 만들어주면 된다. 여기서 중간의 체크박스 객체들을 <code>inBetween = true</code>로 구분하여 체크해주는 것이다. 처음에는 <code>inBetween</code>을 <code>false</code>로 초기화시킨 후, 마지막에 선택했거나, 지금 클릭했다면 그 때 <code>inBetween</code>이 <code>true</code>로 업데이트되고, 또 다시 마지막에 선택했거나, 지금 클릭했다면 <code>false</code>로 업데이트되면서 중간의 객체들이 모두 체크된다. 이 방법을 이용하면 밑에서 위로 체크하는지, 위에서 밑으로 체크하는지 별도로 구현할 필요가 없다.</p><p>아마 이번 과제를 배우지 않았다면 <code>bottomUp</code>, <code>upBottom</code>을 선언하여 따로 구분짓고 for loop를 돌렸을 것 같다. 기발한 아이디어는 가독성, 효율 모두 좋게 만든다. 더 노력해야겠다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day-10-JS-Checkbox-Challenge&quot;&gt;&lt;a href=&quot;#Day-10-JS-Checkbox-Challenge&quot; class=&quot;headerlink&quot; title=&quot;Day 10 - JS Checkbox Challenge!&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="javascript30" scheme="https://zinirun.github.io/tags/javascript30/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 30 - Day 9 Dev Tools Domination</title>
    <link href="https://zinirun.github.io/2020/08/23/js-course30-9/"/>
    <id>https://zinirun.github.io/2020/08/23/js-course30-9/</id>
    <published>2020-08-23T11:55:35.000Z</published>
    <updated>2020-08-24T06:51:45.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-9-Dev-Tools-Domination"><a href="#Day-9-Dev-Tools-Domination" class="headerlink" title="Day 9 - Dev Tools Domination"></a>Day 9 - Dev Tools Domination</h2><div class="video-container"><iframe src="https://www.youtube.com/embed/xkzDaKwinA8" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>이번 과제는 개발자의 관점에서 사용하는 유용한 <code>console</code>의 메소드에 대한 과제이다. 사실 <code>console.log</code>, <code>console.dir</code>, <code>console.table</code> 외에는 모두 처음 들어본 내용이었고, 디버깅을 바보같이 하고 있었다는 생각에 반성하기도 했다.</p><h3 id="console-log"><a href="#console-log" class="headerlink" title="console.log()"></a>console.log()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Regular</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interpolated</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hello I am a %s string!&#x27;</span>, <span class="string">&#x27;💩&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Styled</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;%c I am some great text&#x27;</span>, <span class="string">&#x27;font-size:30px; background:red;&#x27;</span>);</span><br></pre></td></tr></table></figure><p>모두가 잘 아는 <code>console.log()</code>이다. 개인적으로 두번째의 <code>Interpolated</code> 방식보다는 <code>$&#123;var&#125;~</code> 방식을 선호한다. 콘솔에 style을 줄 수 있다는 것은 몰랐다.(필요한 일은 잘 없을 것 같다)</p><h3 id="console-warn-console-error-console-info"><a href="#console-warn-console-error-console-info" class="headerlink" title="console.warn(), console.error(), console.info()"></a>console.warn(), console.error(), console.info()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// warning!</span></span><br><span class="line"><span class="built_in">console</span>.warn(<span class="string">&#x27;OH NOOO&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error :|</span></span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">&#x27;Shit!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Info</span></span><br><span class="line"><span class="built_in">console</span>.info(<span class="string">&#x27;Crocodiles eat 3-4 people per year&#x27;</span>);</span><br></pre></td></tr></table></figure><p>각각 경고, 에러, 정보(ⓘ표시)에 대한 메소드이다.</p><h3 id="console-assert"><a href="#console-assert" class="headerlink" title="console.assert()"></a>console.assert()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Testing</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.assert(p.classList.contains(<span class="string">&#x27;ouch&#x27;</span>), <span class="string">&#x27;You did not select the right element!&#x27;</span>);</span><br></pre></td></tr></table></figure><p>자바스크립트에서 assert를 사용할 수 있는지 처음 알았다. <code>console.assert()</code>는 특정 조건을 첫번째 인자로, 그 특정 조건이 <code>false</code>라면 두번째 인자를 출력한다. 이런 조건들을 지금까지 <code>if (~): console.log(~)</code> 방식으로 사용해왔는데, 유용하게 쓸 것 같다.</p><h3 id="Grouping-console-group"><a href="#Grouping-console-group" class="headerlink" title="Grouping - console.group()"></a>Grouping - console.group()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dogs.forEach(<span class="function">(<span class="params">dog</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.groupCollapsed(<span class="string">`<span class="subst">$&#123;dog.name&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`This is <span class="subst">$&#123;dog.name&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;dog.name&#125;</span> is <span class="subst">$&#123;dog.age * <span class="number">7</span>&#125;</span> years old`</span>);</span><br><span class="line">    <span class="built_in">console</span>.groupEnd(<span class="string">`<span class="subst">$&#123;dog.name&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>console.group()</code> 부터 <code>console.groupEnd()</code>까지 한 그룹으로 묶어 안의 내용들을 콘솔에 나타내준다. 그룹의 기준은 각 group 메소드의 인자이다. <code>Collapsed</code>를 추가하면 닫혀있는 상태로 그룹 기준 이름만 콘솔에 나타내고, 개발자 도구에서 펼쳐서 각 내용을 볼 수 있다.</p><h3 id="console-count"><a href="#console-count" class="headerlink" title="console.count()"></a>console.count()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.count(<span class="string">&#x27;Wes&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.count(<span class="string">&#x27;Wes&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.count(<span class="string">&#x27;Steve&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.count(<span class="string">&#x27;Wes&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.count(<span class="string">&#x27;Steve&#x27;</span>);</span><br></pre></td></tr></table></figure><p>각 동일한 인자의 내용이 얼마나 콘솔에 찍혔는지를 카운트해준다.</p><h3 id="console-time"><a href="#console-time" class="headerlink" title="console.time()"></a>console.time()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;fetching data&#x27;</span>);</span><br><span class="line">fetch(<span class="string">&#x27;https://api.github.com/users/wesbos&#x27;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> data.json())</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;fetching data&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>성능(시간) 측정 시 유용하게 사용할 <code>console.time()</code> 메소드이다. <code>console.time()</code>을 시작으로 <code>console.timeEnd()</code> 까지의 시간을 측정한다. <code>console.group()</code>과 사용법은 비슷하다.</p><h3 id="console-dir-console-table"><a href="#console-dir-console-table" class="headerlink" title="console.dir(), console.table()"></a>console.dir(), console.table()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(dogs);</span><br><span class="line"><span class="built_in">console</span>.table(dogs);</span><br></pre></td></tr></table></figure><p>각 객체를 각각 디렉토리 형태, 테이블 형태로 표시한다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day-9-Dev-Tools-Domination&quot;&gt;&lt;a href=&quot;#Day-9-Dev-Tools-Domination&quot; class=&quot;headerlink&quot; title=&quot;Day 9 - Dev Tools Domination&quot;&gt;&lt;/a&gt;Day 9 </summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="javascript30" scheme="https://zinirun.github.io/tags/javascript30/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
  <entry>
    <title>Progammers - 자물쇠와 열쇠 (2020카카오공채)</title>
    <link href="https://zinirun.github.io/2020/08/23/ps-lock-and-key/"/>
    <id>https://zinirun.github.io/2020/08/23/ps-lock-and-key/</id>
    <published>2020-08-23T06:58:54.000Z</published>
    <updated>2020-08-23T09:19:55.492Z</updated>
    
    <content type="html"><![CDATA[<p>문제 출처 <a href="https://programmers.co.kr/learn/courses/30/lessons/60059">프로그래머스</a></p><h2 id="자물쇠와-열쇠"><a href="#자물쇠와-열쇠" class="headerlink" title="자물쇠와 열쇠"></a>자물쇠와 열쇠</h2><p>문제 <a href="https://programmers.co.kr/learn/courses/30/lessons/60059">프로그래머스</a></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">lock</span>):</span></span><br><span class="line">    l_=len(lock)//<span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(l_, l_*<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(l_, l_*<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> lock[i][j] != <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate_90</span>(<span class="params">m</span>):</span></span><br><span class="line">    N = len(m)</span><br><span class="line">    ret = [[<span class="number">0</span>] * N <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(N):</span><br><span class="line">            ret[c][N<span class="number">-1</span>-r] = m[r][c]</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">key, lock</span>):</span></span><br><span class="line">    m=len(key)</span><br><span class="line">    n=len(lock)</span><br><span class="line">    </span><br><span class="line">    big_lock=[[<span class="number">0</span>]*n*<span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n*<span class="number">3</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            big_lock[i+n][j+n]=lock[i][j]</span><br><span class="line">    <span class="keyword">for</span> rotate <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        key = rotate_90(key)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(n*<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(n*<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                        big_lock[x+i][y+j] += key[i][j]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> check(big_lock) == <span class="literal">True</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                        big_lock[x+i][y+j] -= key[i][j]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>로직은 생각보다 간단하지만, 문제에 대한 이해가 어려울 수 있다. (내가 오래 걸렸다)</p><p>자물쇠와 열쇠에 대한 이해가 필요한데, 열쇠를 회전, 이동하여 자물쇠에 맞춰지면 <code>true</code>, 아니면 <code>false</code>를 반환한다.</p><p>그런데 자물쇠나 열쇠나 2차원 배열로 만들어져 있으므로 회전, 이동, 체크(맞춰지는지)에 대한 알고리즘이 필요하다. 우선 2차원 배열에 대한 회전은 로직은 대충 생각나서 구글링으로 찾은 코드를 그대로 넣었다.</p><p>이제 이동과 검사를 어떻게 할 것이냐가 문제인데 <code>lock</code> 배열이 3x3 배열이라면 3배씩 확장시켜 0으로 초기화된 9x9 배열로 만들고 중간에 자물쇠 원본(3x3)을 넣는다. 그런 다음 열쇠를 <code>[0][0]</code>부터 차례로 움직이며 9x9의 자물쇠 배열에 더하여 중간 부분이 모두 더해서 1이 되었는지 검사하면 된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">lock</span>):</span></span><br><span class="line">    l_=len(lock)//<span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(l_, l_*<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(l_, l_*<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> lock[i][j] != <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>이 check 함수가 확장되어 <code>key</code>와 더해진 <code>lock</code> 배열의 중앙 부분을 검사하는 함수이다. 이 문제는 for loop에서 범위를 설정하기가 까다로웠다고 생각한다.</p><p>또한 코드를 보면 5개나 되는 for loop로 둘러쌓인 것을 알 수 있는데, <code>m</code>, <code>n</code>의 범위는 최대 20이므로 시간복잡도보다는 구현에 초점을 둔 것을 알 수 있다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;문제 출처 &lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/60059&quot;&gt;프로그래머스&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;자물쇠와-열쇠&quot;&gt;&lt;a href=&quot;#자물쇠와-열쇠&quot; class=&quot;header</summary>
      
    
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/tags/algorithm/"/>
    
    <category term="ps" scheme="https://zinirun.github.io/tags/ps/"/>
    
  </entry>
  
  <entry>
    <title>프로그래머스 Dev-Matching 2020 웹 프론트엔드 개발자(하반기) 후기</title>
    <link href="https://zinirun.github.io/2020/08/23/js-programmers-matching-2020-review/"/>
    <id>https://zinirun.github.io/2020/08/23/js-programmers-matching-2020-review/</id>
    <published>2020-08-22T15:44:03.000Z</published>
    <updated>2020-08-22T16:07:34.435Z</updated>
    
    <content type="html"><![CDATA[<h3 id="가벼운-마음으로"><a href="#가벼운-마음으로" class="headerlink" title="가벼운 마음으로"></a>가벼운 마음으로</h3><p>Vanilla Javascript에 대한 어느정도의 이해를 하고 있다고 생각했고, Javascript 30 Course도 열심히 따라가고 있어 호기심 반으로 <a href="https://programmers.co.kr/competitions/251/2020-web-fe-second">프로그래머스</a>의 Dev-Matching 2020을 신청했다.</p><p>이번 Javascript 과제 테스트를 통과하면 34개의 기업 중 본인이 선택한 최대 5개의 기업에 이력서를 보낼 기회가 생긴다. (이력서 전달하기도 참 힘든 세상이다) 사실 아직 대학을 졸업하기 1년이 넘게 남고 취업에 대한 절박함은 크지 않아서 부담없이 <em>즐기는 마음으로</em> 이번 시험을 치뤘다.</p><h3 id="문제에-대해서"><a href="#문제에-대해서" class="headerlink" title="문제에 대해서"></a>문제에 대해서</h3><p>내가 작성한 코드(어차피 틀렸겠지만)를 공개하고 싶지만 아직은 문제가 공개되지 않아 문제소지가 있을 것 같아서 나중에 공식적인 리뷰가 나온다면 다시 포스팅하겠다.</p><p>시험 시간은 3시간이었고, 토이 프로젝트 개념의 과제 하나만 완성하면 되었다. 검색 관련 문제였는데, 처음에 보고 Javascript 30의 <a href="https://zinirun.github.io/2020/08/19/js-course30-6/">Day 6 - Type Ahead</a>와 정말 비슷했고 그 전에 열심히 정리한 것이 많은 도움이 됐다.</p><p>문제의 큰 틀은 <code>input</code>에서 무언가가 입력될 때 제시된 주소의 파라미터로 데이터를 가져와서 추천 검색어 기능 구현, 이미지 검색 구현(이미지 Fetch 관련된 코드는 제시해주었다)이었는데 부수적인 조건이 많았다.</p><p>우선 제시된 주소에서 가끔 데이터를 보내지 않고 에러를 보내는데, 그 부분에 대한 모든 에러 핸들링이 필요했다. 이는 Promise 문법에서 <code>catch</code>를 통해 쉽게 해결되었다. 서버 에러 말고 정말 데이터가 없어서 빈 데이터가 들어오는 경우는 <code>if (data.length &gt; 0) ~ else ~</code>를 사용해서 핸들링했다.</p><p>그리고 추천 검색어를 나타낼 때 디바운싱을 사용하는 조건이 있었는데, 얼마 전 <a href="https://zinirun.github.io/2020/08/16/js-throttling-debouncing/">디바운싱과 쓰로틀링</a>에 대해 포스팅한 것이 도움이 됐다. (이 쯤 되면 운이 좋은건가)</p><p>추가적인 사항으로 Keyboard Event에 대한 여러가지 조건들이 많았는데, 크게 <code>esc</code>, <code>enter</code>, <code>방향키(상/하)</code> 3가지였다. key 값을 받아오는 것은 event 객체의 key 값을 검사하면 쉬웠지만, 가장 애를 먹었던 것은 상하 방향키로 추천 검색어의 포커스를 이동하고 엔터를 치면 검색이 되게 해야하는 것이었다. 나는 <code>cur</code>라는 현재 포커싱된 객체에만 <code>selected</code>라는 class를 추가하여 <code>enter</code>키를 입력받으면 <code>selected</code> class가 있는 <code>li</code> 객체의 <code>innerHTML</code>를 가져와서 검색 처리하였다.</p><p>다른 조건들도 많았는데, 핵심적인 파트는 ‘검색기’인 말 그대로 검색 기능을 필수 조건대로 성실히 구현하면 되는 문제였다. <em>(물론 능력자분들이 많을 것이기에 추가 조건도 모두 구현해야겠지만)</em></p><p><strong>좋은 경험이었고, 더 열심히 해야겠다는 생각밖에 안든다.</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;가벼운-마음으로&quot;&gt;&lt;a href=&quot;#가벼운-마음으로&quot; class=&quot;headerlink&quot; title=&quot;가벼운 마음으로&quot;&gt;&lt;/a&gt;가벼운 마음으로&lt;/h3&gt;&lt;p&gt;Vanilla Javascript에 대한 어느정도의 이해를 하고 있다고 생각했고, </summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 30 - Day 8 Fun with HTML5 Canvas</title>
    <link href="https://zinirun.github.io/2020/08/22/js-course30-8/"/>
    <id>https://zinirun.github.io/2020/08/22/js-course30-8/</id>
    <published>2020-08-22T13:09:47.000Z</published>
    <updated>2020-08-22T13:27:50.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-8-Fun-with-HTML5-Canvas"><a href="#Day-8-Fun-with-HTML5-Canvas" class="headerlink" title="Day 8 - Fun with HTML5 Canvas"></a>Day 8 - Fun with HTML5 Canvas</h2><div class="video-container"><iframe src="https://www.youtube.com/embed/8ZGAzJ0drl0" frameborder="0" loading="lazy" allowfullscreen></iframe></div><h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p class="codepen" data-height="387" data-theme-id="light" data-default-tab="js,result" data-user="zinirun" data-slug-hash="jOqVjyK" style="height: 387px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="JS30 - Day 8">  <span>See the Pen <a href="https://codepen.io/zinirun/pen/jOqVjyK">  JS30 - Day 8</a> by Jeon Jin Heo (<a href="https://codepen.io/zinirun">@zinirun</a>)  on <a href="https://codepen.io">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script>* 마우스 오른쪽 클릭: 그림 리셋하기<h2 id="Full-script"><a href="#Full-script" class="headerlink" title="Full script"></a>Full script</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#draw&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">canvas.width = <span class="built_in">window</span>.innerWidth;</span><br><span class="line">canvas.height = <span class="built_in">window</span>.innerHeight;</span><br><span class="line"></span><br><span class="line">ctx.strokeStyle = <span class="string">&#x27;#BADA55&#x27;</span>;</span><br><span class="line">ctx.lineJoin = <span class="string">&#x27;round&#x27;</span>;</span><br><span class="line">ctx.lineCap = <span class="string">&#x27;round&#x27;</span>;</span><br><span class="line">ctx.lineWidth = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isDrawing = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> lastX = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> lastY = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> hue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> direction = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isDrawing) <span class="keyword">return</span>;</span><br><span class="line">  ctx.strokeStyle = <span class="string">`hsl(<span class="subst">$&#123;hue&#125;</span>, 100%, 50%)`</span>;</span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.moveTo(lastX, lastY);</span><br><span class="line">  ctx.lineTo(e.offsetX, e.offsetY);</span><br><span class="line">  ctx.stroke();</span><br><span class="line">  [lastX, lastY] = [e.offsetX, e.offsetY];</span><br><span class="line"></span><br><span class="line">  hue++;</span><br><span class="line">  <span class="keyword">if</span> (hue &gt;= <span class="number">360</span>) &#123;</span><br><span class="line">    hue = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.lineWidth &gt;= <span class="number">100</span> || ctx.lineWidth &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    direction = !direction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (direction) &#123;</span><br><span class="line">    ctx.lineWidth++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.lineWidth--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">canvas.addEventListener(<span class="string">&#x27;contextmenu&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">  ctx.beginPath();</span><br><span class="line">&#125;);</span><br><span class="line">canvas.addEventListener(<span class="string">&#x27;mousedown&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  isDrawing = <span class="literal">true</span>;</span><br><span class="line">  [lastX, lastY] = [e.offsetX, e.offsetY];</span><br><span class="line">&#125;);</span><br><span class="line">canvas.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, draw);</span><br><span class="line">canvas.addEventListener(<span class="string">&#x27;mouseup&#x27;</span>, <span class="function">() =&gt;</span> (isDrawing = <span class="literal">false</span>));</span><br><span class="line">canvas.addEventListener(<span class="string">&#x27;mouseout&#x27;</span>, <span class="function">() =&gt;</span> (isDrawing = <span class="literal">false</span>));</span><br></pre></td></tr></table></figure><h3 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h3><p>이번 과제는 <code>canvas</code>의 메소드, 속성만 잘 사용한다면 문제없이 해결할 수 있었다.</p><h4 id="canvas-그리기"><a href="#canvas-그리기" class="headerlink" title="canvas 그리기"></a>canvas 그리기</h4><ul><li><code>strokeStyle</code> 말 그대로 그리기 스타일(색상)을 지정한다.</li><li><code>beginPath()</code> 새로운 경로를 만든다.</li><li><code>moveTo()</code> 스트로크의 시작점이다.</li><li><code>lineTo()</code> 스트로크의 끝점이다.</li><li><code>stroke()</code> 스트로크의 경로(시작점, 끝점)를 잇는다.</li></ul><p>간단하게 이해하면, <code>beginPath()</code>와 <code>stroke()</code>안에 시작 좌표 <code>moveTo()</code>, 끝 좌표 <code>lineTo()</code>를 통해 점을 선으로 이어서 “그림을 그리는” 개념이 된다고 생각하면 된다.</p><h4 id="canvas-비우기"><a href="#canvas-비우기" class="headerlink" title="canvas 비우기"></a>canvas 비우기</h4><p>canvas 비우기는 과제를 응용하며 찾아본 내용이다. 나는 오른쪽 클릭을 이벤트로 캔버스를 초기화했는데,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">canvas.addEventListener(<span class="string">&#x27;contextmenu&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>contextmenu</code>가 우클릭 이벤트이고, <code>e.preventDefault()</code>로 기본 우클릭 상자가 안보이게 한다.</p><p>이후 <code>clearRect()</code>와 <code>beginPath()</code>를 호출함으로써 캔버스를 초기화시킬 수 있다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day-8-Fun-with-HTML5-Canvas&quot;&gt;&lt;a href=&quot;#Day-8-Fun-with-HTML5-Canvas&quot; class=&quot;headerlink&quot; title=&quot;Day 8 - Fun with HTML5 Canvas&quot;&gt;&lt;/a&gt;Day</summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="javascript30" scheme="https://zinirun.github.io/tags/javascript30/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 30 - Day 7 Array Cardio Day 2</title>
    <link href="https://zinirun.github.io/2020/08/20/js-course30-7/"/>
    <id>https://zinirun.github.io/2020/08/20/js-course30-7/</id>
    <published>2020-08-20T13:16:26.000Z</published>
    <updated>2020-08-20T13:37:05.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-7-Array-Cardio-Day-2"><a href="#Day-7-Array-Cardio-Day-2" class="headerlink" title="Day 7 - Array Cardio Day 2"></a>Day 7 - Array Cardio Day 2</h2><div class="video-container"><iframe src="https://www.youtube.com/embed/QNmRfyNg1lw" frameborder="0" loading="lazy" allowfullscreen></iframe></div><h2 id="Full-Script"><a href="#Full-Script" class="headerlink" title="Full Script"></a>Full Script</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Data</span></span><br><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Wes&#x27;</span>, <span class="attr">year</span>: <span class="number">1988</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Kait&#x27;</span>, <span class="attr">year</span>: <span class="number">1986</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Irv&#x27;</span>, <span class="attr">year</span>: <span class="number">1970</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Lux&#x27;</span>, <span class="attr">year</span>: <span class="number">2015</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> comments = [</span><br><span class="line">  &#123; <span class="attr">text</span>: <span class="string">&#x27;Love this!&#x27;</span>, <span class="attr">id</span>: <span class="number">523423</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">text</span>: <span class="string">&#x27;Super good&#x27;</span>, <span class="attr">id</span>: <span class="number">823423</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">text</span>: <span class="string">&#x27;You are the best&#x27;</span>, <span class="attr">id</span>: <span class="number">2039842</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">text</span>: <span class="string">&#x27;Ramen is my fav food ever&#x27;</span>, <span class="attr">id</span>: <span class="number">123523</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">text</span>: <span class="string">&#x27;Nice Nice Nice!&#x27;</span>, <span class="attr">id</span>: <span class="number">542328</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some and Every Checks</span></span><br><span class="line"><span class="comment">// Array.prototype.some() // is at least one person 19 or older?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isAdult = people.some(<span class="function">(<span class="params">person</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - person.year &gt;= <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123; isAdult &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.prototype.every() // is everyone 19 or older?</span></span><br><span class="line"><span class="keyword">const</span> allAdults = people.every(<span class="function">(<span class="params">person</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - person.year &gt;= <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123; allAdults &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.prototype.find()</span></span><br><span class="line"><span class="comment">// Find is like filter, but instead returns just the one you are looking for</span></span><br><span class="line"><span class="comment">// find the comment with the ID of 823423</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> comment = comments.find(<span class="function">(<span class="params">comment</span>) =&gt;</span> comment.id === <span class="number">823423</span>);</span><br><span class="line"><span class="built_in">console</span>.log(comment);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.prototype.findIndex()</span></span><br><span class="line"><span class="comment">// Find the comment with this ID</span></span><br><span class="line"><span class="comment">// delete the comment with the ID of 823423</span></span><br><span class="line"><span class="keyword">const</span> index = comments.findIndex(<span class="function">(<span class="params">comment</span>) =&gt;</span> comment.id === <span class="number">823423</span>);</span><br><span class="line"><span class="built_in">console</span>.log(index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//comments.splice(index, 1);</span></span><br><span class="line"><span class="keyword">const</span> newComments = [...comments.slice(<span class="number">0</span>, index), ...comments.slice(index + <span class="number">1</span>)];</span><br><span class="line"><span class="built_in">console</span>.table(newComments);</span><br></pre></td></tr></table></figure><h3 id="some-every"><a href="#some-every" class="headerlink" title="some, every"></a>some, every</h3><p><code>some</code>은 하나라도 조건을 만족하면 <code>true</code>를 반환하고, <code>every</code>는 모두 조건을 만족해야 <code>true</code>을 반환한다. 사용법은 매우 간단하다. <code>some</code>과 <code>every</code>는 format이 동일하므로 <code>some</code>만 살펴보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isAdult = people.some(<span class="function">(<span class="params">person</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - person.year &gt;= <span class="number">19</span>);</span><br></pre></td></tr></table></figure><p>Arrow Function으로 작성되었는데 풀어보면</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isAdult = people.some(<span class="function"><span class="keyword">function</span> (<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> currentYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">  <span class="keyword">if</span> (currentYear - person.year &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이것과 똑같다. 특정 조건이 참인지 여부를 검사하고 boolean 값을 반환한다.</p><h3 id="find-findIndex"><a href="#find-findIndex" class="headerlink" title="find, findIndex"></a>find, findIndex</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> comment = comments.find(<span class="function">(<span class="params">comment</span>) =&gt;</span> comment.id === <span class="number">823423</span>);</span><br></pre></td></tr></table></figure><p><code>find</code>는 말 그대로 특정 조건에 부합하는 데이터를 찾고, 그 첫 번째 데이터를 반환한다. 단 하나의 객체만 반환할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> index = comments.findIndex(<span class="function">(<span class="params">comment</span>) =&gt;</span> comment.id === <span class="number">823423</span>);</span><br></pre></td></tr></table></figure><p><code>findIndex</code>는 <code>find</code>와 거의 동일하지만 객체 배열에서 특정 조건을 찾았을 때 객체를 반환하는 것이 아닌, 인덱스를 반환한다.</p><h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><p><code>splice</code>의 기본 문법은 다음과 같다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.splice(start[, deleteCount[, item1[, item2[, ...]]]])</span><br></pre></td></tr></table></figure><p>이번 예제에서 <code>splice</code>를 사용한 방법은</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comments.splice(index, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>위의 문법에 대입해서 생각하면 이전에 찾은 <code>index</code>값을 시작으로 1개의 값을 삭제한다.</p><h3 id="spread-전개구문"><a href="#spread-전개구문" class="headerlink" title="spread (전개구문)"></a>spread (전개구문)</h3><p>위의 <code>splice</code>를 사용하는 방법도 있지만, spread 구문을 사용하는 방법도 있다. 전개구문은 <code>...</code>을 배열에 붙여서 사용하는데, <code>unpack</code>의 개념과 비슷하다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(...arr) <span class="comment">// 1,2,3</span></span><br></pre></td></tr></table></figure><p>이렇게 배열의 껍데기를 벗기고 내용물을 보여준다.</p><p>예제의 <code>splice</code>, 즉 <code>index</code>의 내용을 제외한 나머지 <code>comments</code>를 보여주기 위해서는,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newComments = [</span><br><span class="line">    ...comments.slice(<span class="number">0</span>, index),</span><br><span class="line">    ...comments.slice(index + <span class="number">1</span>)</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><code>index</code>를 기준으로 앞에서 자르고 뒤에서 잘라서 붙여주면 된다. <code>...</code>를 사용하지 않으면 <code>object</code> 객체끼리 합쳐지기 때문에 내용물을 붙이기 위해 전개 구문을 사용한다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day-7-Array-Cardio-Day-2&quot;&gt;&lt;a href=&quot;#Day-7-Array-Cardio-Day-2&quot; class=&quot;headerlink&quot; title=&quot;Day 7 - Array Cardio Day 2&quot;&gt;&lt;/a&gt;Day 7 - Arra</summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="javascript30" scheme="https://zinirun.github.io/tags/javascript30/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - DFS/BFS (깊이우선탐색, 너비우선탐색)</title>
    <link href="https://zinirun.github.io/2020/08/20/ps-summary-dfs-bfs-1/"/>
    <id>https://zinirun.github.io/2020/08/20/ps-summary-dfs-bfs-1/</id>
    <published>2020-08-20T05:42:14.000Z</published>
    <updated>2020-08-23T09:22:44.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="들어가기-전에"><a href="#들어가기-전에" class="headerlink" title="들어가기 전에"></a>들어가기 전에</h2><p>대학교 알고리즘 수업 때 DFS, BFS를 배우면서 뭔 말인지는 대충 알겠는데 뭔가 별로 쓰일 것 같지도 않고, 정확하게 공부하자니 어려워서 딱 “필요한 만큼”만 공부했다. 그 때 확실히 끝냈더라면 DFS, BFS와 관련된 PS 문제를 수월하게 풀었을텐데, 후회했다. 이제 책을 보며 다시 정리하고 예제를 풀어보려 한다. 탐색 알고리즘은 정말 중요하고, 활용도가 높다. <em>(이번 부스트캠프 2020 2차 마지막 문제를 못 푼 것이 정말 아쉽다, 제대로 공부 해놓을걸.)</em></p><h2 id="DFS-깊이-우선-탐색"><a href="#DFS-깊이-우선-탐색" class="headerlink" title="DFS, 깊이 우선 탐색"></a>DFS, 깊이 우선 탐색</h2><p>DFS는 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다. 그래프의 기본 구조에서 두 노드가 간선으로 연결되어 있다면 ‘두 노드는 <strong>인접</strong> <em>adjacent</em>하다고 말한다.</p><p>사실 이런 설명을 보고 한번에 이해하면 진작에 탐색 알고리즘은 마스터했을 것이다. 나는 구글에서 DFS, BFS 글들을 아무리 검색해도 완벽하게 이해되지 않았는데, 책에 나온 코드를 보며 한 줄씩 따라가니 이해하기 쉬웠다. 코드를 먼저 보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">graph, v, visited</span>):</span></span><br><span class="line">    visited[v]=<span class="literal">True</span></span><br><span class="line">    print(v, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> graph[v]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">            dfs(graph, i, visited)</span><br><span class="line">            </span><br><span class="line">graph = [</span><br><span class="line">    [],</span><br><span class="line">    [<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">7</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">5</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">7</span>],</span><br><span class="line">    [<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br><span class="line">visited = [<span class="literal">False</span>]*len(graph)</span><br><span class="line">dfs(graph, <span class="number">1</span>, visited)</span><br></pre></td></tr></table></figure><p>실행 결과</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 7 6 8 3 4 5 </span><br></pre></td></tr></table></figure><p>생각보다 기본적인 <code>dfs</code> 함수 틀 자체는 복잡하지 않게 생겼다. <strong>재귀</strong>를 사용하는데 dfs는 스택, bfs는 큐이고 재귀 함수 자체가 기본적으로 스택이기 때문에 편하게 재귀를 사용한다. (안 쓰는 방법도 있고, 구현하는 방법은 정말 많다)</p><p><code>graph</code>를 보면 왠 숫자들의 배열이 배열로 감싸져 있는데, 그 전에 그래프를 표현하는 방식은 크게 2가지가 있다.</p><ul><li>인접 행렬(Adjacency Matrix) 방식<ul><li>2차원 배열에 각 노드가 연결된 형태를 기록하는 방식</li></ul></li><li>인접 리스트(Adjacency List) 방식<ul><li>모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장하는 방식</li></ul></li></ul><p>따라서 코드의 <code>graph</code>는 <code>인접 리스트</code> 방식으로 저장되어 있다. 1번 노드부터 8번 노드까지 차례대로 연결된 노드를 나타낸 것이다. 0번 노드는 없기 때문에 빈 배열로 자리만 차지하게 둔다.</p><p>이제 방문하는 노드마다 <code>visited</code>를 <code>True</code>로 표시하며 탐색을 시작한다. <code>graph</code>에 노드마다 연결된 노드들이 있으므로 <code>for</code>문으로 순회하며 방문하지 않은 노드들을 차례로 <code>dfs</code>를 재귀 호출하며 방문한다.</p><ul><li>방문 처리는 스택에 한번 삽입되어 처리된 노드가 다시 삽입되지 않게 체크하는 것을 의미한다. 방문 처리를 함으로써 각 노드를 한 번씩만 처리할 수 있다.</li></ul><blockquote><p>결론적으로 DFS는 차례대로 정렬된 노드를 방문하며 그 인접 노드들을 재귀적으로 방문하는 것이다.</p></blockquote><h2 id="BFS-너비-우선-탐색"><a href="#BFS-너비-우선-탐색" class="headerlink" title="BFS, 너비 우선 탐색"></a>BFS, 너비 우선 탐색</h2><p>BFS는 가까운 노드부터 탐색하는 알고리즘이다. DFS는 최대한 멀리 있는 노드, BFS는 제일 가까운 노드부터이다. 큐 자료구조를 이용하는 것이 정석인데, 인접한 노드를 반복적으로 큐에 넣도록 알고리즘을 작성하면 자연스럽게 먼저 들어온 것이 먼저 나가게 되기 때문이다.</p><p>알고리즘의 작동 방식은,</p><ul><li>탐색 시작 노드를 큐에 삽입 -&gt; 방문 처리</li><li>큐에서 노드를 꺼내고 그 노드의 인접노드 중 방문하지 않은 노드를 <strong>모두 큐에 삽입</strong> -&gt; 방문 처리</li><li>전 과정을 수행할 수 없을 때까지 반복</li></ul><p>코드를 보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">graph, start, visited</span>):</span></span><br><span class="line">    q=deque([start])</span><br><span class="line">    visited[start]=<span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        v=q.popleft()</span><br><span class="line">        print(v, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> graph[v]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">                q.append(i)</span><br><span class="line">                visited[i]=<span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">graph = [</span><br><span class="line">    [],</span><br><span class="line">    [<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">7</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">5</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">7</span>],</span><br><span class="line">    [<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br><span class="line">visited = [<span class="literal">False</span>]*len(graph)</span><br><span class="line">bfs(graph, <span class="number">1</span>, visited)</span><br></pre></td></tr></table></figure><p>큐 자료구조를 이용하므로 효율을 위해 파이썬에서는 <code>deque</code>를 사용한다. 첫 방문 노드를 queue에 삽입하고 방문처리 후, 인접 노드를 모두 큐에 넣고 하나씩 빼면서(<code>popleft()</code>) 방문처리하는 과정을 큐가 빌 때까지 반복한다.</p><p>DFS, BFS에 관련된 예제를 하나씩 풀어보자.</p><h2 id="DFS-음료수-얼려-먹기"><a href="#DFS-음료수-얼려-먹기" class="headerlink" title="DFS - 음료수 얼려 먹기"></a>DFS - 음료수 얼려 먹기</h2><p>0과 1로 이루어진 N*M의 배열에서 0 묶음의 개수(연결된 0의 묶음 개수)를 구하는 문제이다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dx=[<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>]</span><br><span class="line">dy=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x&lt;=<span class="number">-1</span> <span class="keyword">or</span> x&gt;=n <span class="keyword">or</span> y&lt;=<span class="number">-1</span> <span class="keyword">or</span> y&gt;=m: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> graph[x][y]==<span class="number">0</span>:</span><br><span class="line">        graph[x][y]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            dfs(x+dx[i],y+dy[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                </span><br><span class="line">n,m=map(int, input().split())</span><br><span class="line">graph = [list(map(int,input())) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">result=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">if</span> dfs(i,j) == <span class="literal">True</span>:</span><br><span class="line">            result+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>상, 하, 좌, 우로 탐색하므로 <code>dx</code>, <code>dy</code>로 이동 방향을 미리 정해주면 나중에 사용하기 편하다. 특정 지점의 상, 하, 좌, 우를 탐색한 후 인접 노드 중 값이 0이면서 아직 방문하지 않은 노드를 방문하고, 방문한 노드에서 다시 상, 하, 좌, 우를 탐색하며 방문을 진행하면 모든 노드를 방문할 수 있다.</p><h2 id="BFS-미로-탈출"><a href="#BFS-미로-탈출" class="headerlink" title="BFS - 미로 탈출"></a>BFS - 미로 탈출</h2><p>0과 1로 이루어진 배열에서 1로만 갈 수 있는 길의 방문 순서를 <code>1, 2, 3..</code> 으로 기록하여 최종적인 방문 순서를 구하는 문제이다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">dx=[<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">dy=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    q=deque()</span><br><span class="line">    q.append((x,y))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        x,y=q.popleft()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            nx, ny=x+dx[i], y+dy[i]</span><br><span class="line">            <span class="keyword">if</span> nx&lt;<span class="number">0</span> <span class="keyword">or</span> ny&lt;<span class="number">0</span> <span class="keyword">or</span> nx&gt;=n <span class="keyword">or</span> ny&gt;=m <span class="keyword">or</span> graph[nx][ny]==<span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> graph[nx][ny]==<span class="number">1</span>:</span><br><span class="line">                graph[nx][ny]=graph[x][y]+<span class="number">1</span></span><br><span class="line">                q.append((nx,ny))</span><br><span class="line">    <span class="keyword">return</span> graph[n<span class="number">-1</span>][m<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">n,m=map(int, input().split())</span><br><span class="line">graph = [list(map(int,input())) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">print(bfs(<span class="number">0</span>,<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>맨 처음에 (1,1)의 위치에서 시작하며, (1,1)의 값은 항상 1이라고 문제에 언급되어 있다. 시작 좌표에서 상, 하, 좌, 우로 탐색하고, 1인 값의 노드가 있다면 2로 바꾼다. 위 과정을 반복하면 최단 경로의 값들이 1씩 증가하는 형태가 된다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;들어가기-전에&quot;&gt;&lt;a href=&quot;#들어가기-전에&quot; class=&quot;headerlink&quot; title=&quot;들어가기 전에&quot;&gt;&lt;/a&gt;들어가기 전에&lt;/h2&gt;&lt;p&gt;대학교 알고리즘 수업 때 DFS, BFS를 배우면서 뭔 말인지는 대충 알겠는데 뭔가 별로 </summary>
      
    
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/tags/algorithm/"/>
    
    <category term="ps" scheme="https://zinirun.github.io/tags/ps/"/>
    
  </entry>
  
  <entry>
    <title>ReactJS - state (컴포넌트 상태 관리)</title>
    <link href="https://zinirun.github.io/2020/08/19/react-state/"/>
    <id>https://zinirun.github.io/2020/08/19/react-state/</id>
    <published>2020-08-19T14:55:53.000Z</published>
    <updated>2020-08-19T15:15:45.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>프로퍼티는 컴포넌트 내부에서 값을 바꿀 수 없다. 그러면 상품의 수량을 입력하거나, 댓글을 남기는 등 값을 바꿔야 하는 경우엔 어떻게 할까? <code>state</code>를 사용한다.</p><h3 id="StateExample-jsx"><a href="#StateExample-jsx" class="headerlink" title="StateExample.jsx"></a>StateExample.jsx</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateExample</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props); <span class="comment">//state 정의</span></span><br><span class="line">    <span class="comment">//forceUpdate 사용시 this.loading=true; 와 같이 직접선언</span></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      loading: <span class="literal">true</span>,</span><br><span class="line">      formData: <span class="string">&#x27;no data&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.handleData = <span class="built_in">this</span>.handleData.bind(<span class="built_in">this</span>); <span class="comment">//함수로 넘어갈 this는 반드시 생성자에서 bind로 묶어야함</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="built_in">this</span>.handleData, <span class="number">3000</span>); <span class="comment">//3초 후 저장된 값을 변경</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleData() &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="string">&#x27;new data&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123; formData &#125; = <span class="built_in">this</span>.state; <span class="comment">//특수변수 this.state를 사용하여 state값에 접근</span></span><br><span class="line">    <span class="comment">//setState가 호출되면 자동으로 render함수가 호출됨</span></span><br><span class="line">    <span class="comment">//직접 변경하고 검증없이 강제로 render함수를 실행하고 싶다면</span></span><br><span class="line">    <span class="comment">//this로 접근해서 직접 바꾸고 this.forceUpdate() 사용</span></span><br><span class="line">    <span class="comment">//but render에서의 접근은 this.state.data가 아닌 this.data로 접근</span></span><br><span class="line">    <span class="comment">// this.loading = false;</span></span><br><span class="line">    <span class="comment">// this.formData = data + this.formData;</span></span><br><span class="line">    <span class="comment">// this.forceUpdate();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      loading: <span class="literal">false</span>,</span><br><span class="line">      formData: data + formData,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;loading값&#x27;</span>, <span class="built_in">this</span>.state.loading);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//setState 함수의 인자로 함수를 전달하면 이전 state값을 쉽게 읽을 수 있음</span></span><br><span class="line">  handleData2(data) &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123;</span><br><span class="line">      loading: <span class="literal">false</span>,</span><br><span class="line">      formData: data + prevState.formData,</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;span&gt;로딩중: &#123;<span class="built_in">String</span>(<span class="built_in">this</span>.state.loading)&#125;&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;결과: &#123;<span class="built_in">this</span>.state.formData&#125;&lt;/span&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> StateExample;</span><br></pre></td></tr></table></figure><p>기본적으로 state는</p><ul><li><code>constructor</code>에 선언</li><li><code>setState()</code>로 변경</li></ul><p>이렇게 사용한다.</p><p><code>setState()</code>가 실행되면 검증 단계 후 자동으로 <code>render()</code>를 실행시키므로 별도의 새로고침 없이도 동적인 페이지에서 값이 바뀐다. 검증 단계를 거치기 싫고 강제로 값을 바꿔 새로고침을 만들고 싶다면 <code>forceUpdate()</code>를 사용하면 되는데, 자세한 설명은 위 코드 내에 주석으로 해놓았다.</p><p>그리고 중요한 것은, 함수로 넘어갈 <code>this</code>는 반드시 생성자 <code>constructor</code>에서 <code>bind()</code> 함수로 묶어주어야 한다.</p><h3 id="이전-상태와-함께-사용하기"><a href="#이전-상태와-함께-사용하기" class="headerlink" title="이전 상태와 함께 사용하기"></a>이전 상태와 함께 사용하기</h3><p>상태를 바꿀 때 이전 상태가 필요한 경우가 있다. <code>count</code>를 1씩 증가시키는 예제로 살펴보자.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//state 정의</span></span><br><span class="line">    <span class="built_in">this</span>.increaseCount = <span class="built_in">this</span>.increaseCount.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  increaseCount() &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function">(<span class="params">prev</span>) =&gt;</span> (&#123; <span class="attr">count</span>: prev.count + <span class="number">1</span> &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;span&gt;카운트: &#123;<span class="built_in">this</span>.state.count&#125;&lt;/span&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.increaseCount&#125;&gt;카운트 증가&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter;</span><br></pre></td></tr></table></figure><p><code>count</code>를 <code>이전 값 + 1</code> 해줘야 하므로 이전 <code>state</code>에 대한 접근이 필요한데, 이 때 <code>setState</code>의 첫 번째 인자로 이전 상태에 접근할 수 있다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;state&quot;&gt;&lt;a href=&quot;#state&quot; class=&quot;headerlink&quot; title=&quot;state&quot;&gt;&lt;/a&gt;state&lt;/h2&gt;&lt;p&gt;프로퍼티는 컴포넌트 내부에서 값을 바꿀 수 없다. 그러면 상품의 수량을 입력하거나, 댓글을 남기는 등 값</summary>
      
    
    
    
    <category term="ReactJS" scheme="https://zinirun.github.io/categories/ReactJS/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="react" scheme="https://zinirun.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Flask 앱 도커로 서비스하기 (nginX, uwsgi)</title>
    <link href="https://zinirun.github.io/2020/08/19/deploy-flask-to-docker/"/>
    <id>https://zinirun.github.io/2020/08/19/deploy-flask-to-docker/</id>
    <published>2020-08-19T13:04:45.000Z</published>
    <updated>2020-08-22T14:40:05.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flask-배포하기"><a href="#Flask-배포하기" class="headerlink" title="Flask 배포하기"></a>Flask 배포하기</h2><p><strong>Flask</strong>에서 만든 웹 어플리케이션을 서버에서 서비스한다면 서버(Host OS)상에 만든 파일을 업로드하고 <code>nginX</code> 프레임워크와 <code>Flask</code> 앱을 연결시키기 위해 <code>uwsgi</code>을 사용할 수 있다.</p><p>우분투 서버에서 Flask 기반의 서비스를 구동하기 위해 <code>Python</code>, <code>Anaconda</code>, <code>nginX</code>, <code>uwsgi</code>를 세팅하고 파이썬에 Flask와 필요한 라이브러리를 <code>pip</code>로 설치할 수 있다.</p><p>그러나 Docker를 사용하면 패키지 버전 충돌에 스트레스 받지 않고 간편하게 웹 서비스를 컨테이너화할 수 있다.</p><p>이 글은 Flask 구동에 관련된 파이썬 파일과 웹 파일(py, html 등)이 작성되었다는 가정하에 시작한다.</p><h2 id="Flask-서비스-준비"><a href="#Flask-서비스-준비" class="headerlink" title="Flask 서비스 준비"></a>Flask 서비스 준비</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 서버 실행</span></span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, debug=<span class="literal">True</span>, port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>메인이 되는 파이썬 파일을 수정한다. port를 <code>80</code>으로 설정한 이유는 nginX의 기본 포트가 <code>80</code>이기 때문에 이를 설정하지 않으면 컨테이너화해도 nginX와 포트를 공유하지 못해 웹 페이지가 정상적으로 열지 못한다.</p><p><img src="https://1.bp.blogspot.com/-tDeiZUXzEIM/Xlen0OBfjYI/AAAAAAAAAUE/jbTLZ6LVxf0f85dcJ7c3YVGAKoODoz6YgCLcBGAsYHQ/s1600/%25ED%258C%258C%25EC%259D%25B4%25EC%25B0%25B8%25ED%258F%25B4%25EB%258D%2594.JPG" alt="1"></p><p>그리고 파일 위치를 정리한다. 프로젝트 폴더 내에 <code>app</code> 폴더를 만들어 <code>main.py</code>를 포함한 파일과 폴더를 위치시킨다. 완료된 모습은 위와 같다. 프로젝트 폴더로 들어가면 <code>app</code> 폴더와 곧 만들 <code>Dockerfile</code>만 존재한다.</p><h2 id="Dockerfile-requirements-작성하기"><a href="#Dockerfile-requirements-작성하기" class="headerlink" title="Dockerfile, requirements 작성하기"></a>Dockerfile, requirements 작성하기</h2><p>도커의 장점을 활용할 때가 왔다. Dockerhub를 검색하니 <code>uwsgi+nginx+flask</code> 환경이 모두 세팅된 이미지가 있었다. 이를 사용해서 간단하게 플라스크 앱을 싱글 컨테이너로 배포할 수 있다.</p><p><code>Dockerfile</code></p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> tiangolo/uwsgi-nginx-flask:python3.<span class="number">7</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./app /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span></span><br></pre></td></tr></table></figure><ul><li><code>FROM</code> : tiangolo/uwsgi-nginx-flask 이미지를 통해 도커이미지를 만든다.</li><li><code>COPY</code> : app 폴더 내의 내용을 컨테이너 내부의 app 폴더에 복사한다.</li><li><code>RUN</code> : app 폴더 내에 만들어둔 requirements.txt 내용을 파이썬 패키지 설치한다.</li><li>참고로 <code>Dockerfile</code>은 확장자가 없는, 그냥 파일명이 <code>Dockerfile</code>이다.</li></ul><p><code>app</code> 폴더 내의 <code>requirements.txt</code> 파일에는 파이썬에 필요한 라이브러리의 목록이 들어있다.</p><p><code>requirements.txt</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opencv-python</span><br><span class="line">scikit-learn</span><br></pre></td></tr></table></figure><p>이는 예시이다. 필자는 이미지 분석에 필요한 라이브러리를 추가했다. 필요한 라이브러리들을 엔터로 구분하여 작성하면 된다. Flask는 이미지에 들어있기 때문에 작성할 필요가 없다.</p><h2 id="Docker-이미지-빌드하고-실행하기"><a href="#Docker-이미지-빌드하고-실행하기" class="headerlink" title="Docker 이미지 빌드하고 실행하기"></a>Docker 이미지 빌드하고 실행하기</h2><p>이제 도커 이미지를 만들기 위한 모든 파일 작성이 끝났다. 프로젝트 폴더를 <code>ftp</code>를 이용해 서버에 업로드하고(Github을 이용해도 상관없다), 터미널에서 <code>프로젝트 폴더</code>로 이동하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myimage .</span><br></pre></td></tr></table></figure><p>도커 이미지를 빌드한다. <code>myimage</code> 대신 원하는 이름을 사용해도 된다. 마지막의 온점 <code>.</code> 을 까먹지 말자. 해당 폴더에서 자동으로 <code>Dockerfile</code>을 찾아 이미지를 빌드할 것이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mycontainer -p 80:80 myimage</span><br></pre></td></tr></table></figure><p>빌드된 <code>myimage</code> 이미지를 컨테이너로 실행한다. <code>-d</code>는 백그라운드 실행이다.</p><p>호스트의 <code>80</code>포트와 도커의 <code>80</code>포트를 공유함으로써 <code>호스트 IP/도메인</code>을 통해 브라우저로 접속할 수 있다. 주소에 포트를 입력하지 않으면 자동으로 80포트로 접속하기 때문에 굳이 <code>:80</code>을 입력할 필요가 없다.</p><p>이제 브라우저를 통해서 접속한다.</p><p>접속 거부 메시지가 뜬다면 <code>py</code> 파일에서 <code>app.run</code>의 포트를 <code>80</code>으로 설정했는지 확인해보자. 다른 오류 메시지가 뜬다면 <em>역시 구글링이 답이다.</em></p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>Docker를 통해 Flask 기반의 웹 애플리케이션을 서비스해보았다. 도커의 편리함을 또 체감한다. 환경 구축뿐만 아니라 컨테이너화해서 구동하는 이점을 생각하면 Host에서 직접 구동하는 것보다는 훨씬 뛰어난 것을 느낀다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Flask-배포하기&quot;&gt;&lt;a href=&quot;#Flask-배포하기&quot; class=&quot;headerlink&quot; title=&quot;Flask 배포하기&quot;&gt;&lt;/a&gt;Flask 배포하기&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Flask&lt;/strong&gt;에서 만든 웹 어플리케이션을 </summary>
      
    
    
    
    <category term="cloud" scheme="https://zinirun.github.io/categories/cloud/"/>
    
    <category term="docker" scheme="https://zinirun.github.io/categories/cloud/docker/"/>
    
    
    <category term="flask" scheme="https://zinirun.github.io/tags/flask/"/>
    
    <category term="docker" scheme="https://zinirun.github.io/tags/docker/"/>
    
    <category term="nginx" scheme="https://zinirun.github.io/tags/nginx/"/>
    
    <category term="uwsgi" scheme="https://zinirun.github.io/tags/uwsgi/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 30 - Day 6 Type Ahead</title>
    <link href="https://zinirun.github.io/2020/08/19/js-course30-6/"/>
    <id>https://zinirun.github.io/2020/08/19/js-course30-6/</id>
    <published>2020-08-19T12:43:00.000Z</published>
    <updated>2020-08-20T00:57:31.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-6-Type-Ahead"><a href="#Day-6-Type-Ahead" class="headerlink" title="Day 6 - Type Ahead"></a>Day 6 - Type Ahead</h2><div class="video-container"><iframe src="https://www.youtube.com/embed/y4gZMJKAeWs" frameborder="0" loading="lazy" allowfullscreen></iframe></div><h3 id="Full-Script"><a href="#Full-Script" class="headerlink" title="Full Script"></a>Full Script</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> endpoint =</span><br><span class="line">    <span class="string">&#x27;https://gist.githubusercontent.com/Miserlou/c5cd8364bf9b2420bb29/raw/2bf258763cdddd704f8ffd3ea9a3e81d25e2c6f6/cities.json&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cities = [];</span><br><span class="line"></span><br><span class="line">  fetch(endpoint)</span><br><span class="line">    .then(<span class="function">(<span class="params">blob</span>) =&gt;</span> blob.json())</span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> cities.push(...data)); <span class="comment">//spread</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">findMatches</span>(<span class="params">wordToMatch, cities</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cities.filter(<span class="function">(<span class="params">place</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(wordToMatch, <span class="string">&#x27;ig&#x27;</span>); <span class="comment">// i:insensitive, g:global</span></span><br><span class="line">      <span class="keyword">return</span> place.city.match(regex) || place.state.match(regex);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">displayMatches</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> matchArray = findMatches(<span class="built_in">this</span>.value, cities);</span><br><span class="line">    <span class="keyword">const</span> html = matchArray</span><br><span class="line">      .map(<span class="function">(<span class="params">place</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="built_in">this</span>.value, <span class="string">&#x27;gi&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> cityName = place.city.replace(regex, <span class="string">`&lt;span class=&quot;hl&quot;&gt;<span class="subst">$&#123;<span class="built_in">this</span>.value&#125;</span>&lt;/span&gt;`</span>);</span><br><span class="line">        <span class="keyword">const</span> stateName = place.state.replace(regex, <span class="string">`&lt;span class=&quot;hl&quot;&gt;<span class="subst">$&#123;<span class="built_in">this</span>.value&#125;</span>&lt;/span&gt;`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;li&gt;</span></span><br><span class="line"><span class="string">    &lt;span class=&quot;name&quot;&gt;<span class="subst">$&#123;cityName&#125;</span>, <span class="subst">$&#123;stateName&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;span class=&quot;population&quot;&gt;<span class="subst">$&#123;numberWithCommas(place.population)&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">  &lt;/li&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">      &#125;)</span><br><span class="line">      .join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    suggestions.innerHTML = html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">numberWithCommas</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.toString().replace(<span class="regexp">/\B(?=(\d&#123;3&#125;)+(?!\d))/g</span>, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> searchInput = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.search&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> suggestions = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.suggestions&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  searchInput.addEventListener(<span class="string">&#x27;change&#x27;</span>, displayMatches);</span><br><span class="line">  searchInput.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, displayMatches);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    searchInput.focus();</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="json-데이터-가져오기-fetch"><a href="#json-데이터-가져오기-fetch" class="headerlink" title="json 데이터 가져오기 (fetch)"></a>json 데이터 가져오기 (fetch)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(endpoint)</span><br><span class="line">  .then(<span class="function">(<span class="params">blob</span>) =&gt;</span> blob.json())</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> cities.push(...data)); <span class="comment">//spread</span></span><br></pre></td></tr></table></figure><p><code>fetch()</code>를 호출하면 브라우저는 네트워크 요청을 보내고 <code>Promise</code>가 반환된다. 데이터를 <code>json</code> 형태로 만들고, 그 데이터를 <code>cities</code>에 <code>push</code>한다. (<code>cities</code>는 <code>const</code>로 선언되었기 때문에 대입시킬 수 없다)</p><h3 id="정규식-사용하기-RegExp"><a href="#정규식-사용하기-RegExp" class="headerlink" title="정규식 사용하기 (RegExp)"></a>정규식 사용하기 (RegExp)</h3><h4 id="데이터-찾기"><a href="#데이터-찾기" class="headerlink" title="데이터 찾기"></a>데이터 찾기</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMatches</span>(<span class="params">wordToMatch, cities</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cities.filter(<span class="function">(<span class="params">place</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(wordToMatch, <span class="string">&#x27;ig&#x27;</span>); <span class="comment">// i:insensitive, g:global</span></span><br><span class="line">    <span class="keyword">return</span> place.city.match(regex) || place.state.match(regex);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>정규식을 사용하기 위해 <code>RegExp</code>를 선언한다. 자바스크립트에서 정규표현식 사용은 <a href="https://poiemaweb.com/js-regexp">PoiemaWeb</a>에 잘 설명되어 있다. 찾을 단어 <code>wordToMatch</code>를 <code>cities</code>의 각 요소 <code>place</code>에서 찾는데, <code>city</code>와 <code>state</code>에서 한 개라도 맞으면 반환한다.</p><h4 id="데이터-변환-교체-하고-HTML에서-나타내기"><a href="#데이터-변환-교체-하고-HTML에서-나타내기" class="headerlink" title="데이터 변환(교체)하고 HTML에서 나타내기"></a>데이터 변환(교체)하고 HTML에서 나타내기</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayMatches</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> matchArray = findMatches(<span class="built_in">this</span>.value, cities);</span><br><span class="line">  <span class="keyword">const</span> html = matchArray</span><br><span class="line">    .map(<span class="function">(<span class="params">place</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="built_in">this</span>.value, <span class="string">&#x27;gi&#x27;</span>);</span><br><span class="line">      <span class="keyword">const</span> cityName = place.city.replace(regex, <span class="string">`&lt;span class=&quot;hl&quot;&gt;<span class="subst">$&#123;<span class="built_in">this</span>.value&#125;</span>&lt;/span&gt;`</span>);</span><br><span class="line">      <span class="keyword">const</span> stateName = place.state.replace(regex, <span class="string">`&lt;span class=&quot;hl&quot;&gt;<span class="subst">$&#123;<span class="built_in">this</span>.value&#125;</span>&lt;/span&gt;`</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;li&gt;</span></span><br><span class="line"><span class="string">          &lt;span class=&quot;name&quot;&gt;<span class="subst">$&#123;cityName&#125;</span>, <span class="subst">$&#123;stateName&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">          &lt;span class=&quot;population&quot;&gt;<span class="subst">$&#123;numberWithCommas(place.population)&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;`</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  suggestions.innerHTML = html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>입력하는 값과 일치하는 부분을 highlight 표시하기 위해 <code>regex</code>를 이용하여 바꿔준다. 그리고 <code>matchArray</code>의 값을 적절히 가공하여 <code>innerHTML</code>에 넣어준다.</p><h4 id="Event-추가하기"><a href="#Event-추가하기" class="headerlink" title="Event 추가하기"></a>Event 추가하기</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> searchInput = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.search&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> suggestions = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.suggestions&#x27;</span>);</span><br><span class="line"></span><br><span class="line">searchInput.addEventListener(<span class="string">&#x27;change&#x27;</span>, displayMatches);</span><br><span class="line">searchInput.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, displayMatches);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  searchInput.focus();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>필요한 함수들을 모두 만들었으니 이벤트만 걸어주면 된다. <code>change</code>에만 이벤트를 걸면 사용자가 입력이 완전히 끝났을 때만 함수가 실행되므로 예제의 목적에 맞게 <code>keyup</code>에도 이벤트를 걸어야 실시간으로 변하는 것처럼 보인다.</p><p>예제 솔루션에는 포함되어 있지 않지만 <code>focus</code> 메소드를 사용하여 <code>input</code> 객체에 포커스를 주었다.</p><h2 id="응용하기"><a href="#응용하기" class="headerlink" title="응용하기"></a>응용하기</h2><h3 id="regex-대신-includes-사용하기"><a href="#regex-대신-includes-사용하기" class="headerlink" title="regex 대신 includes 사용하기"></a>regex 대신 <code>includes</code> 사용하기</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMatches</span>(<span class="params">wordToMatch, cities</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cities.filter(<span class="function">(<span class="params">place</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      place.city.toLowerCase().includes(wordToMatch.toLowerCase()) ||</span><br><span class="line">      place.city.toLowerCase().includes(wordToMatch.toLowerCase())</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> place.city || place.state;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>findMatches()</code> 함수를 정규식을 사용하지 않고 <code>includes</code>를 사용할 수도 있다. 이게 더 가독성이 좋을 지도 모르겠다.</p><h3 id="Debounce-처리하기"><a href="#Debounce-처리하기" class="headerlink" title="Debounce 처리하기"></a>Debounce 처리하기</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timer;</span><br><span class="line"><span class="keyword">const</span> delay = <span class="number">200</span>;</span><br><span class="line">searchInput.addEventListener(<span class="string">&#x27;input&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">  &#125;</span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    displayMatches(e.target);</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>모든 input event에서 함수를 처리하면 성능상으로도, 비용상으로도 비효율적이다. 이 때 <strong>디바운싱</strong>을 사용할 수 있다. 검색 event에서 디바운싱의 사용은 획기적으로 API 요청을 줄여주기에, 안 쓸 이유가 없다. 다른 글에 <a href="https://zinirun.github.io/2020/08/16/js-throttling-debouncing/">디바운싱과 쓰로틀링</a>을 정리해두었으니 참고하자.</p><p>이제 6번째 날인데, 자바스크립트의 활용 범위는 끝이 없는 것 같다. 남은 24일이 기대된다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day-6-Type-Ahead&quot;&gt;&lt;a href=&quot;#Day-6-Type-Ahead&quot; class=&quot;headerlink&quot; title=&quot;Day 6 - Type Ahead&quot;&gt;&lt;/a&gt;Day 6 - Type Ahead&lt;/h2&gt;&lt;div class=&quot;v</summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="javascript30" scheme="https://zinirun.github.io/tags/javascript30/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - 구현 (Implementation)</title>
    <link href="https://zinirun.github.io/2020/08/19/ps-summary-implementation-1/"/>
    <id>https://zinirun.github.io/2020/08/19/ps-summary-implementation-1/</id>
    <published>2020-08-19T06:16:07.000Z</published>
    <updated>2020-08-19T07:25:50.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="구현-피지컬-싸움"><a href="#구현-피지컬-싸움" class="headerlink" title="구현, 피지컬 싸움"></a>구현, 피지컬 싸움</h2><p>PS에서 <code>구현</code>이란 <code>머리속에 있는 알고리즘을 소스코드로 바꾸는 과정</code>이다. 어떤 문제를 풀건 소스 코드를 작성하는 과정은 필수이므로 결국 <code>구현</code> 문제유형은 모든 PS 유형을 포함하는 개념이다.</p><p>우리는 알고리즘 문제를 보고, 문제 풀이 방법을 고민한다. 고민 후 문제에 대한 풀이 방법이 떠오른다고 정답을 받을 수 있는 것은 아니다. 생각한 문제 풀이 방법을 프로그래밍 언어로 정확히 구현해야 한다.</p><p>결국 <code>구현</code> 유형의 문제는 ‘풀이를 떠올리는 것은 쉽지만 소스 코드로 옮기기기 어려운 문제’를 의미한다. 그런 의미에서 구현 유형의 문제는 코딩 피지컬을 요구하는 문제라고도 할 수 있다.</p><h2 id="상하좌우"><a href="#상하좌우" class="headerlink" title="상하좌우"></a>상하좌우</h2><p><code>N*N</code>의 좌표공간에서 <code>RRRUDD</code>와 같은 방향을 나타내는 문자열이 들어왔을 때 최종 도착 지점의 좌표를 출력하는 문제이다.</p><ul><li>L: 왼쪽, R: 오른쪽, U: 위, D: 아래</li><li><code>N*N</code> 크기의 공간을 벗어나는 움직임은 무시</li></ul><h3 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">w=int(input())</span><br><span class="line">x,y=<span class="number">1</span>,<span class="number">1</span></span><br><span class="line">move=input().split()</span><br><span class="line">d=&#123;<span class="string">&#x27;L&#x27;</span>:<span class="number">-1</span>,<span class="string">&#x27;R&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;U&#x27;</span>:<span class="number">-1</span>,<span class="string">&#x27;D&#x27;</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">for</span> mov <span class="keyword">in</span> move:</span><br><span class="line">    <span class="keyword">if</span> mov <span class="keyword">in</span> [<span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]:</span><br><span class="line">        t_x=x+d[mov]</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;t_x&lt;=w: x=t_x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        t_y=y+d[mov]</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;t_y&lt;=w: y=t_y</span><br><span class="line">print(x,y)</span><br></pre></td></tr></table></figure><p>구현 유형 문제의 특징은 문제의 요구사항대로 구현하면 된다는 것이다. 이 때 <code>N*N</code> 크기의 공간을 벗어나는 움직임의 예외 처리를 정확히 해주어야 한다.</p><h2 id="시각"><a href="#시각" class="headerlink" title="시각"></a>시각</h2><p>정수 N이 입력되었을 때 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중 3이 하나라도 포함되는 모든 경우의 수를 구하는 문제이다.</p><h3 id="풀이-1"><a href="#풀이-1" class="headerlink" title="풀이"></a>풀이</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> h <span class="keyword">in</span> range(int(input())+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">60</span>):</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> range(<span class="number">60</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;3&#x27;</span> <span class="keyword">in</span> str(h)+str(m)+str(s): count+=<span class="number">1</span></span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure><p>이 문제의 경우 모든 시각의 경우를 하나씩 모두 세서 풀어도 문제가 되지 않는다. <code>N</code>이 <code>23</code>으로 (최대로) 입력되었다고 해도 84300가지밖에 존재하지 않기에 시각을 1씩 증가시키면서 3이 포함되어 있는지 검사해도 무방하다.</p><h2 id="왕실의-나이트"><a href="#왕실의-나이트" class="headerlink" title="왕실의 나이트"></a>왕실의 나이트</h2><p><code>8*8</code> 좌표 평면에서 특정 방향으로만 이동할 수 있는데, 이 때 이동할 수 있는 좌표의 경우의 수를 구하는 문제이다.</p><blockquote><p>이동 방법은 다음과 같다.</p></blockquote><ul><li>수평으로 두 칸 이동 -&gt; 수직으로 한 칸 이동</li><li>수직으로 두 칸 이동 -&gt; 수평으로 한 칸 이동</li></ul><h3 id="풀이-2"><a href="#풀이-2" class="headerlink" title="풀이"></a>풀이</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cur=input()</span><br><span class="line">mov=[[<span class="number">1</span>,<span class="number">-2</span>],[<span class="number">2</span>,<span class="number">-1</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">-1</span>,<span class="number">2</span>],[<span class="number">-2</span>,<span class="number">1</span>],[<span class="number">-2</span>,<span class="number">1</span>],[<span class="number">-1</span>,<span class="number">-2</span>]]</span><br><span class="line">x_=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>]</span><br><span class="line">x=x_.index(cur[<span class="number">0</span>])+<span class="number">1</span></span><br><span class="line">y=int(cur[<span class="number">1</span>])</span><br><span class="line">count=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mov:</span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span>&lt;x+i[<span class="number">0</span>]&lt;=<span class="number">8</span> <span class="keyword">and</span> <span class="number">0</span>&lt;y+i[<span class="number">1</span>]&lt;=<span class="number">8</span>: count+=<span class="number">1</span></span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure><p>앞서 풀었던 상하좌우 문제와 거의 똑같은 유형의 문제이다. 이동할 수 있는 경우의 수는 8가지임으로 <code>mov</code>에 모든 경우의 수를 집어넣고 좌표 공간에서 벗어나는지만 확인하면 된다.</p><h2 id="게임개발"><a href="#게임개발" class="headerlink" title="게임개발"></a>게임개발</h2><p>특정 조건 하에서 좌표 공간을 이동할 때 방문한 좌표의 수를 구하는 문제이다.</p><blockquote><p>이동 조건은 다음과 같다.</p></blockquote><ul><li>현재 위치에서 현재 방향을 기준으로 왼쪽 방향(반시계 90도 회전)</li><li>왼쪽 방향에 방문하지 않은 칸이 존재하면 -&gt; 왼쪽 방향으로 회전 후 왼쪽으로 한 칸 전진</li><li>왼쪽 방향에 방문하지 않은 칸이 없다면 -&gt; 왼쪽 방향으로 회전 후 처음 단계로 돌아가기</li><li>네 방향 모두 방문했거나 바다로 되어 있다면 바라보는 방향에서 한 칸 뒤로 가고 처음으로 돌아가기 (단, 뒤쪽 방향이 바다라서 뒤로 못가면 멈추기)</li></ul><h3 id="풀이-3"><a href="#풀이-3" class="headerlink" title="풀이"></a>풀이</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">w,h=map(int,input().split())</span><br><span class="line">x,y,d=map(int,input().split())</span><br><span class="line">m=[list(map(int,input().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> range(w)]</span><br><span class="line"></span><br><span class="line">v=[[<span class="number">0</span>]*h <span class="keyword">for</span> _ <span class="keyword">in</span> range(w)]</span><br><span class="line">v[x][y]=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">dx,dy=[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">count=<span class="number">1</span></span><br><span class="line">turn=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">turnLeft</span>():</span></span><br><span class="line">    <span class="keyword">global</span> d</span><br><span class="line">    d -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> d == <span class="number">-1</span>: d=<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    turnLeft()</span><br><span class="line">    nx,ny=x+dx[d],y+dy[d]</span><br><span class="line">    <span class="keyword">if</span> v[nx][ny]==<span class="number">0</span> <span class="keyword">and</span> m[nx][ny]==<span class="number">0</span>:</span><br><span class="line">        v[nx][ny]=<span class="number">1</span></span><br><span class="line">        x,y=nx,ny</span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">        turn=<span class="number">0</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>: turn+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> turn==<span class="number">4</span>:</span><br><span class="line">        nx,ny=x-dx[d],y-dy[d]</span><br><span class="line">        <span class="keyword">if</span> m[nx][ny]==<span class="number">0</span>:x,y=nx,ny</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">        turn=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure><p>문제가 길지만 사실상 문제에 나온 요구사항을 그대로 코드에 옮기기만 하면 되는 문제이다. 방문 체크를 위한 배열 <code>v</code>, <code>d</code>를 바탕으로 움직이는 방향을 <code>dx</code>, <code>dy</code>로 변수화하고, 움직인 횟수 <code>count</code>, 방향을 돌리고 모든 방향을 돌았을 때 예외처리 하기위해 <code>turn</code>을 선언한다.</p><h3 id="방향-관련-구현-유형의-문제"><a href="#방향-관련-구현-유형의-문제" class="headerlink" title="방향 관련 구현 유형의 문제"></a>방향 관련 구현 유형의 문제</h3><p>위와 같이 상하좌우로 움직이는 좌표 공간에서 “방향”을 설정해서 이동하는 문제는 <code>dx</code>, <code>dy</code>라는 별도의 리스트를 만들어 방향을 정하는 것이 효과적이다. 위 예제에서 캐릭터를 움직일 때 동, 서, 남, 북 방향을 <code>dx</code>, <code>dy</code>로 별도로 리스트화해서 생각하면 <code>if d==1: ~</code> 등의 불필요한 구현을 없앨 수 있다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;구현-피지컬-싸움&quot;&gt;&lt;a href=&quot;#구현-피지컬-싸움&quot; class=&quot;headerlink&quot; title=&quot;구현, 피지컬 싸움&quot;&gt;&lt;/a&gt;구현, 피지컬 싸움&lt;/h2&gt;&lt;p&gt;PS에서 &lt;code&gt;구현&lt;/code&gt;이란 &lt;code&gt;머리속에 있는 알고리</summary>
      
    
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/tags/algorithm/"/>
    
    <category term="ps" scheme="https://zinirun.github.io/tags/ps/"/>
    
  </entry>
  
  <entry>
    <title>ReactJS - 자식 프로퍼티(Child Property)</title>
    <link href="https://zinirun.github.io/2020/08/19/react-child-property/"/>
    <id>https://zinirun.github.io/2020/08/19/react-child-property/</id>
    <published>2020-08-18T15:52:35.000Z</published>
    <updated>2020-08-19T15:15:32.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="자식-프로퍼티"><a href="#자식-프로퍼티" class="headerlink" title="자식 프로퍼티"></a>자식 프로퍼티</h2><p><code>JSX</code>도 마크업 표현식을 사용할 수 있다. <code>JSX</code>에서는 컴포넌트 하위에 배치한 노드 <em>(또는 컴포넌트)</em> 를 하위 컴포넌트에서 프로퍼티로 접근할 수 있게 한다.</p><h3 id="App-jsx"><a href="#App-jsx" class="headerlink" title="App.jsx"></a>App.jsx</h3><p>우선 App 컴포넌트 <code>App.jsx</code>에 포함시킨 <code>ChildProperty</code> 컴포넌트 하위에 자식 노드를 배치한 경우이다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ChildProperty <span class="keyword">from</span> <span class="string">&#x27;./03/ChildProperty&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&quot;body&quot;</span>&gt;</span><br><span class="line">          &lt;ChildProperty&gt;</span><br><span class="line">            &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>자식 노드<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">          &lt;/ChildProperty&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h3 id="ChildProperty-jsx"><a href="#ChildProperty-jsx" class="headerlink" title="ChildProperty.jsx"></a>ChildProperty.jsx</h3><p>이제 <code>ChildProperty</code> 컴포넌트에서는 <code>&#123;this.props.children&#125;</code>과 같은 방법으로 <code>&lt;div&gt;&lt;span&gt;자식 노드&lt;/span&gt;&lt;/div&gt;</code>를 쉽게 받을 수 있다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildProperty</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ChildProperty.propTypes = &#123;</span><br><span class="line">  children: PropTypes.node,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ChildProperty;</span><br></pre></td></tr></table></figure><p>결과를 확인하면 <code>&#123;this.props.children&#125;</code> 위치에 <code>&lt;div&gt;&lt;span&gt;자식 노드&lt;/span&gt;&lt;/div&gt;</code>가 출력될 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildProperty children&#x3D;&#123;&lt;div&gt;&lt;span&gt;자식노드&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&#125; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>이는 위와 같이 별도의 프로퍼티로 자식 노드를 전달하는 것과 같다.</p><p>하지만 자식 프로퍼티를 사용하는 방법이 간편하기에, 노드 전달 시에는 자식 프로퍼티를 사용하자.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;자식-프로퍼티&quot;&gt;&lt;a href=&quot;#자식-프로퍼티&quot; class=&quot;headerlink&quot; title=&quot;자식 프로퍼티&quot;&gt;&lt;/a&gt;자식 프로퍼티&lt;/h2&gt;&lt;p&gt;&lt;code&gt;JSX&lt;/code&gt;도 마크업 표현식을 사용할 수 있다. &lt;code&gt;JSX&lt;/co</summary>
      
    
    
    
    <category term="ReactJS" scheme="https://zinirun.github.io/categories/ReactJS/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="react" scheme="https://zinirun.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 30 - Day 5 Flex Panel Gallery</title>
    <link href="https://zinirun.github.io/2020/08/18/js-course30-5/"/>
    <id>https://zinirun.github.io/2020/08/18/js-course30-5/</id>
    <published>2020-08-18T13:14:09.000Z</published>
    <updated>2020-08-18T13:43:41.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-5-Flex-Panel-Gallery"><a href="#Day-5-Flex-Panel-Gallery" class="headerlink" title="Day 5 - Flex Panel Gallery"></a>Day 5 - Flex Panel Gallery</h2><div class="video-container"><iframe src="https://www.youtube.com/embed/9eif30i26jg" frameborder="0" loading="lazy" allowfullscreen></iframe></div><h3 id="CSS-Part"><a href="#CSS-Part" class="headerlink" title="CSS Part"></a>CSS Part</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.panels</span> &#123;</span><br><span class="line">        <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span><br><span class="line">        <span class="attribute">overflow</span>: hidden;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.panel</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#6b0f9c</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: inset <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.1</span>);</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="comment">/* Safari transitionend event.propertyName === flex */</span></span><br><span class="line">    <span class="comment">/* Chrome + FF transitionend event.propertyName === flex-grow */</span></span><br><span class="line">    <span class="attribute">transition</span>: font-size <span class="number">0.7s</span> <span class="built_in">cubic-bezier</span>(<span class="number">0.61</span>, -<span class="number">0.19</span>, <span class="number">0.7</span>, -<span class="number">0.11</span>),</span><br><span class="line">      flex <span class="number">0.7s</span> <span class="built_in">cubic-bezier</span>(<span class="number">0.61</span>, -<span class="number">0.19</span>, <span class="number">0.7</span>, -<span class="number">0.11</span>), background <span class="number">0.2s</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-size</span>: cover;</span><br><span class="line">    <span class="attribute">background-position</span>: center;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Flex Children */</span></span><br><span class="line"><span class="selector-class">.panel</span> &gt; * &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">transition</span>: transform <span class="number">0.5s</span>;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Flex Display</code>에 대한 이해가 필요한 예제였다. <code>Flex</code>나 <code>Grid</code>에 완전히 익숙하지가 않아 차근차근 이해하려 노력했다.</p><h3 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h3><p><code>Flex</code>와 관련된 CSS 속성들이 정말 많다. 간단하게 이번 에제에서 사용된 것만 정리해보면,</p><p><code>flex: 1</code> : flex 적용을 받는 요소들의 너비를 1로 통일 (1이든 100이든 상관없음)<br><code>justify-content: center</code>, <code>align-items: center</code> : 요소 중앙 정렬<br><code>flex-direction: column</code> : flex 적용을 받는 요소 안에 내용물의 방향(기본: <code>row</code>)</p><p><strong>Flex Layout은 <a href="https://studiomeal.com/archives/197">이 곳</a>에 정리가 잘 되어 있다</strong></p><h3 id="cubic-bezier"><a href="#cubic-bezier" class="headerlink" title="cubic-bezier"></a>cubic-bezier</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">font-size</span> 0<span class="selector-class">.7s</span> <span class="selector-tag">cubic-bezier</span>(0<span class="selector-class">.61</span>, <span class="selector-tag">-0</span><span class="selector-class">.19</span>, 0<span class="selector-class">.7</span>, <span class="selector-tag">-0</span><span class="selector-class">.11</span>),</span><br><span class="line">          <span class="selector-tag">flex</span> 0<span class="selector-class">.7s</span> <span class="selector-tag">cubic-bezier</span>(0<span class="selector-class">.61</span>, <span class="selector-tag">-0</span><span class="selector-class">.19</span>, 0<span class="selector-class">.7</span>, <span class="selector-tag">-0</span><span class="selector-class">.11</span>), <span class="selector-tag">background</span> 0<span class="selector-class">.2s</span>;</span><br></pre></td></tr></table></figure><p><code>.panel</code>에 선언된 css 속성이다. <code>cubic-bezier()</code> function은 <code>transition</code> 속성 또는 <code>transition-timing-function</code> 속성에서 전환 시작과 끝까지의 효과를 제어한다.</p><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http://cfile9.uf.tistory.com/image/99DBDB4F5B0CD3E418BCA9" alt="베지어곡선"></p><p>이 <code>베지어 곡선</code>을 정의하는 것이라고 이해하면 된다.</p><p>위의 예에서 <code>transition</code>이 일어날 때 <code>font-size</code>, <code>flex</code>에 대해 <code>cubic-bezier</code>를 정의했는데, <code>()</code>에 들어가는 4개의 숫자가 곡선의 <code>curve</code>를 나타낸다.</p><h3 id="event-처리를-위한-css-class-설정"><a href="#event-처리를-위한-css-class-설정" class="headerlink" title="event 처리를 위한 css class 설정"></a>event 처리를 위한 css class 설정</h3><p>이제 <code>Javascript</code>에서 각 <code>panel</code>에 이벤트를 걸어 <code>css</code> 속성을 바꿔주는데, 이 때 <code>classList.toggle</code>을 통해 css를 제어할 것이다.</p><p>우선 <code>.panel</code>의 첫 번째와 마지막 글자를 위한 <code>transform</code> 속성을 정의한다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.panel</span> &gt; *<span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">100%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.panel</span><span class="selector-class">.open-active</span> &gt; *<span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.panel</span> &gt; *<span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">100%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.panel</span><span class="selector-class">.open-active</span> &gt; *<span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 <code>.panel</code>의 flex layout을 변경하기 위해 <code>flex</code> 속성을 정의한다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.panel</span><span class="selector-class">.open</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>모든 요소가 <code>flex: 1</code>인 상태에서 <code>.open</code> class를 부여받은 <code>panel</code>만 5배의 비율로 늘어난다.</p><h2 id="Javascript-Part"><a href="#Javascript-Part" class="headerlink" title="Javascript Part"></a>Javascript Part</h2><p>이제 <code>.panel</code>에 event를 걸어준다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> panels = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;.panel&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleOpen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  <span class="built_in">this</span>.classList.toggle(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleActive</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.propertyName.includes(<span class="string">&quot;flex&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.classList.toggle(<span class="string">&quot;open-active&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">panels.forEach(<span class="function">(<span class="params">panel</span>) =&gt;</span> panel.addEventListener(<span class="string">&quot;click&quot;</span>, toggleOpen));</span><br><span class="line">panels.forEach(<span class="function">(<span class="params">panel</span>) =&gt;</span></span><br><span class="line">  panel.addEventListener(<span class="string">&quot;transitionend&quot;</span>, toggleActive)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>toggle</code> 속성이 꽤 자주 사용된다. <code>class</code>를 부여하는데, 있으면 놔두고 없으면 추가한다.</p><h2 id="응용"><a href="#응용" class="headerlink" title="응용"></a>응용</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> panels = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;.panel&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleOpen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  panels.forEach(<span class="function">(<span class="params">panel</span>) =&gt;</span> panel.classList.remove(<span class="string">&quot;open&quot;</span>));</span><br><span class="line">  <span class="built_in">this</span>.classList.toggle(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleActive</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.propertyName.includes(<span class="string">&quot;flex&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.classList.toggle(<span class="string">&quot;open-active&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">panels.forEach(<span class="function">(<span class="params">panel</span>) =&gt;</span> panel.addEventListener(<span class="string">&quot;click&quot;</span>, toggleOpen));</span><br><span class="line">panels.forEach(<span class="function">(<span class="params">panel</span>) =&gt;</span></span><br><span class="line">  panel.addEventListener(<span class="string">&quot;transitionend&quot;</span>, toggleActive)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>한 이미지를 선택할 때 나머지 이미지의 layout을 원래대로 돌려놓게 응용했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panels.forEach(<span class="function">(<span class="params">panel</span>) =&gt;</span> panel.classList.remove(<span class="string">&quot;open&quot;</span>));</span><br></pre></td></tr></table></figure><p><code>toggleOpen()</code> 함수가 실행될 때 모든 <code>panel</code>의 <code>open</code> class를 삭제한 후 이벤트가 발생한 <code>panel</code>에만 <code>open</code> class를 부여했다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day-5-Flex-Panel-Gallery&quot;&gt;&lt;a href=&quot;#Day-5-Flex-Panel-Gallery&quot; class=&quot;headerlink&quot; title=&quot;Day 5 - Flex Panel Gallery&quot;&gt;&lt;/a&gt;Day 5 - Flex</summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="javascript30" scheme="https://zinirun.github.io/tags/javascript30/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Greedy (그리디, 탐욕법)</title>
    <link href="https://zinirun.github.io/2020/08/18/ps-summary-greedy-1/"/>
    <id>https://zinirun.github.io/2020/08/18/ps-summary-greedy-1/</id>
    <published>2020-08-18T08:13:47.000Z</published>
    <updated>2020-08-18T11:15:36.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="그리디-당장-좋은-것"><a href="#그리디-당장-좋은-것" class="headerlink" title="그리디, 당장 좋은 것"></a>그리디, 당장 좋은 것</h2><p><strong>그리디(Greedy)</strong> 알고리즘은 단순하지만 강력한 PS 알고리즘이다. <code>탐욕법</code>이라고도 부르는 이 알고리즘은 이름에서 알 수 있듯이 어떠한 문제를 단순 무식하게, 탐욕적으로 해결한다. 매 순간 가장 좋아보이는 것을 선택하며, <strong>현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다.</strong></p><p>기준에 따라 좋은 것을 선택하는 알고리즘이므로 문제에서 <code>가장 큰(작은) 순서대로</code>와 같은 힌트를 알게 모르게 제시해준다. 보통 이 기준은 <code>정렬 알고리즘</code>과 자주 사용된다.</p><h2 id="거스름돈"><a href="#거스름돈" class="headerlink" title="거스름돈"></a>거스름돈</h2><p>500원, 100원, 50원, 10원짜리 동전이 있을 때 손님에게 거슬러 줘야할 동전의 <strong>최소 개수</strong>를 구하는 문제이다. (단, 거슬러 줘야할 돈 N은 항상 10의 배수이다.)</p><h3 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">money = int(input())</span><br><span class="line">cash=[<span class="number">500</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">10</span>]</span><br><span class="line">count=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> coin <span class="keyword">in</span> cash:</span><br><span class="line">    count += money // coin</span><br><span class="line">    money %= coin</span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure><p>앞서 설명했듯이 문제에 동전의 “최소 개수”를 구하라고 명시되어 있다. 또한 그리디로 해결할 수 있는 이유는 큰 단위가 항상 작은 단위의 배수임으로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문이다. 시간복잡도는 화폐의 종류가 K개라고 할 때 <code>O(K)</code>가 된다.</p><h2 id="큰-수의-법칙"><a href="#큰-수의-법칙" class="headerlink" title="큰 수의 법칙"></a>큰 수의 법칙</h2><p>다양한 수로 이뤄진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만든다. 단, 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없다.</p><p>예) <code>[2,4,5,4,6]</code>, <code>M=8</code>, <code>K=3</code>일 때 <code>6+6+6+5+6+6+6+5=46</code></p><h3 id="첫번째-풀이"><a href="#첫번째-풀이" class="headerlink" title="첫번째 풀이"></a>첫번째 풀이</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">n,m,k=map(int,input().split())</span><br><span class="line">numbers=list(map(int,input().split()))</span><br><span class="line">numbers.sort()</span><br><span class="line"></span><br><span class="line">result=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">n_1=numbers[<span class="number">-1</span>]</span><br><span class="line">n_2=numbers[<span class="number">-2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(k):</span><br><span class="line">        <span class="keyword">if</span> m==<span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">        result+=n_1</span><br><span class="line">        m-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> m==<span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">    result+=n_2</span><br><span class="line">    m-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>결국 필요한 수는 가장 큰 수와 두번째로 큰 수이다. 가장 큰 수를 반복하다가, 같은 수가 K번이 넘을 때 두번째로 큰 수를 끼워주면 되기 때문이다.</p><p>하지만 위와 같은 방식은 수가 커질수록 비효율적이게 된다.</p><p><strong>반복되는 수열</strong>에 대해서 파악해야 한다.</p><h3 id="두번째-풀이"><a href="#두번째-풀이" class="headerlink" title="두번째 풀이"></a>두번째 풀이</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n,m,k=map(int,input().split())</span><br><span class="line">numbers=list(map(int,input().split()))</span><br><span class="line">numbers.sort()</span><br><span class="line"></span><br><span class="line">n_1=numbers[<span class="number">-1</span>]</span><br><span class="line">n_2=numbers[<span class="number">-2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#나누어 떨어지는 경우, 나누어 떨어지지 않는 경우 (나누어 떨어지지 않는 경우는 무조건 가장 큰 수를 더하는 경우임)</span></span><br><span class="line">count=int(m/(k+<span class="number">1</span>))*k + m%(k+<span class="number">1</span>)</span><br><span class="line">result=count*n_1 + (m-count)*n_2</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>전체적으로 가장 큰 수가 필요한 경우, 두번째로 큰 수가 필요한 경우(결국 전체 개수 M에서 가장 큰 수를 쓴 횟수를 뺀 값이 된다)를 구하면 끝나는 문제이다.</p><h2 id="숫자-카드-게임"><a href="#숫자-카드-게임" class="headerlink" title="숫자 카드 게임"></a>숫자 카드 게임</h2><p>여러 개(N*M)의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드 한장을 뽑는다. 단, 선택된 행의 가장 낮은 숫자 카드를 뽑는다.</p><h3 id="풀이-1"><a href="#풀이-1" class="headerlink" title="풀이"></a>풀이</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">N,M=map(int,input().split())</span><br><span class="line">num=[]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(N):</span><br><span class="line">    num.append(min(map(int,input().split())))</span><br><span class="line">print(max(num))</span><br></pre></td></tr></table></figure><p>간단하다. 입력받음과 동시에 가장 작은 수를 <code>num</code>배열에 넣고 마지막에 최대값을 출력해주면 된다.</p><h2 id="1이-될-때까지"><a href="#1이-될-때까지" class="headerlink" title="1이 될 때까지"></a>1이 될 때까지</h2><p>어떤 수 N이 1이 될 때까지 나누거나 뺀다. 방법은 두가지이다.</p><ul><li>N에서 1을 뺀다</li><li>N을 K로 나눈다 (단, N이 K로 나누어 떨어질때만)</li></ul><h3 id="첫번째-풀이-1"><a href="#첫번째-풀이-1" class="headerlink" title="첫번째 풀이"></a>첫번째 풀이</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n,k=map(int,input().split())</span><br><span class="line">count=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> n%k==<span class="number">0</span>:</span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">        n=n//k</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">        n-=<span class="number">1</span></span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure><p>최대한 많이 나누면 된다. 1을 빼는 것보다 나눌 때 숫자가 훨씬 빨리 작아지기 때문이다. N이 K의 배수가 되도록 한번에 뺀다면 좀 더 효율적으로 짤 수 있다.</p><h3 id="두번째-풀이-1"><a href="#두번째-풀이-1" class="headerlink" title="두번째 풀이"></a>두번째 풀이</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n,k=map(int,input().split())</span><br><span class="line">count=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    target=(n//k)*k <span class="comment"># N이 K의 배수가 되도록 만들기</span></span><br><span class="line">    count+=(n-target) <span class="comment"># n-target: 1을 몇번 뺐는지</span></span><br><span class="line">    n=target <span class="comment"># 결국 n은 k의 배수</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n&lt;k: <span class="keyword">break</span> <span class="comment"># 더 이상 나눌 수 없을 때</span></span><br><span class="line">    <span class="comment"># n을 k로 나누기</span></span><br><span class="line">    count+=<span class="number">1</span></span><br><span class="line">    n//=k</span><br><span class="line"></span><br><span class="line">count+=(n<span class="number">-1</span>)</span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure><p>N을 K의 배수가 되도록 만들고 나머지 경우를 빼주면 된다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;그리디-당장-좋은-것&quot;&gt;&lt;a href=&quot;#그리디-당장-좋은-것&quot; class=&quot;headerlink&quot; title=&quot;그리디, 당장 좋은 것&quot;&gt;&lt;/a&gt;그리디, 당장 좋은 것&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;그리디(Greedy)&lt;/strong&gt; 알고리</summary>
      
    
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://zinirun.github.io/tags/algorithm/"/>
    
    <category term="ps" scheme="https://zinirun.github.io/tags/ps/"/>
    
  </entry>
  
  <entry>
    <title>Javascript - 디바운싱, 쓰로틀링</title>
    <link href="https://zinirun.github.io/2020/08/16/js-throttling-debouncing/"/>
    <id>https://zinirun.github.io/2020/08/16/js-throttling-debouncing/</id>
    <published>2020-08-16T12:46:09.000Z</published>
    <updated>2020-08-24T13:54:35.753Z</updated>
    
    <content type="html"><![CDATA[<p>JS ES6 문법은 아니지만, <strong>지연 처리</strong>를 효율적으로 구현할 수 있다. 디바운싱, 쓰로틀링 모두 서버의 데이터를 요청하는 등의 작업에서 생기는 부하를 크게 줄여준다.</p><h2 id="디바운싱-debouncing"><a href="#디바운싱-debouncing" class="headerlink" title="디바운싱(debouncing)"></a>디바운싱(debouncing)</h2><p><strong>디바운싱</strong>의 정의는 연이어 호출되는 함수들 중에서 마지막 함수 or 맨 처음 함수만 호출하도록 하는 것이다. 간단하게 연관 검색어 창을 떠올려보자.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;search&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.querySelector(<span class="string">&quot;#search&quot;</span>).addEventListener(<span class="string">&quot;input&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;서버 ajax 검색 요청&quot;</span>, e.target.value);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>만약 이 코드대로 검색 시스템을 만들었다면, 사용자가 <code>자바</code>를 검색하면 <code>ㅈ</code>,<code>자</code>,<code>잡</code>,<code>자바</code> 4개의 ajax 요청이 들어가게 된다. 쿼리 하나하나가 비용이 들기 때문에 100명의 사용자가 평균 20번의 input event가 발생한다고 치면 2000번의 비용이 발생한다는 것이다.</p><p>대부분의 사람들은 타자를 연달아서 친다. 따라서 입력이 다 끝난 후에 요청을 보내면 된다. 이 때 타자를 칠 때마다 타이머를 설정하는데, <code>100ms</code>동안 입력이 없으면 입력이 끝난 것으로 치고, <code>100ms</code>동안 입력이 발생하면 타이머를 새로 설정한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timer;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;#search&quot;</span>).addEventListener(<span class="string">&quot;input&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;서버 ajax 검색 요청&quot;</span>, e.target.value);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이제 맨 처음 들었던 예시처럼 모든 input event 경우에 대해 ajax 요청이 들어가지 않는다. <code>100ms</code>동안 <code>자바</code>를 모두 입력했다면 <code>자바</code>라는 요청 한 번만 들어가게 된다. 이렇게 디바운싱은 서버 부하를 현저히 줄일 수 있다는 장점이 있다.</p><h2 id="쓰로틀링-throttling"><a href="#쓰로틀링-throttling" class="headerlink" title="쓰로틀링(throttling)"></a>쓰로틀링(throttling)</h2><p><strong>쓰로틀링</strong>은 디바운싱 개념과 비슷하지만 <code>입력하는 동안에도 바로 이전에 요청한 작업을 주기적으로 실행하는 점</code>이 다르다. 이해가 어렵다면, 페이스북 스크롤을 생각해보자. 일명 이 무한 스크롤 기능이 디바운싱으로 구현되어 있다면 스크롤리 멈추지 않는 한 다음 타임라인은 로딩되지 않을 것이다.</p><p>위에서 예로 들었던 검색 기능을 쓰로틀링으로 다시 작성해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timer;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;#search&quot;</span>).addEventListener(<span class="string">&quot;input&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;서버 ajax 검색 요청&quot;</span>, e.target.value);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="/source/images/2020-08-24-22-54-08.png"><br>디바운싱과 달리 쓰로틀링으로 짠 이 코드는 검색 요청을 <code>100ms</code>마다 보낸다. 타이머가 설정되어 있으면 아무 동작도 하지 않다가, 타이머가 없다면 타이머를 설정한다. 타이머는 일정 시간 후에 스스로를 해제하고, 검색 요청을 보낸다.</p><p>참조 <a href="https://www.zerocho.com/category/JavaScript/post/59a8e9cb15ac0000182794fa">ZeroCho</a>님</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JS ES6 문법은 아니지만, &lt;strong&gt;지연 처리&lt;/strong&gt;를 효율적으로 구현할 수 있다. 디바운싱, 쓰로틀링 모두 서버의 데이터를 요청하는 등의 작업에서 생기는 부하를 크게 줄여준다.&lt;/p&gt;
&lt;h2 id=&quot;디바운싱-debouncing</summary>
      
    
    
    
    <category term="javascript" scheme="https://zinirun.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="VanillaJS" scheme="https://zinirun.github.io/tags/VanillaJS/"/>
    
  </entry>
  
</feed>
