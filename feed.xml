<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zinirun</title>
  
  <subtitle>tech blog by Zini</subtitle>
  <link href="https://zinirun.github.io/feed.xml" rel="self"/>
  
  <link href="https://zinirun.github.io/"/>
  <updated>2021-01-31T09:30:18.934Z</updated>
  <id>https://zinirun.github.io/</id>
  
  <author>
    <name>zini</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go 서비스를 헤로쿠에 배포하기</title>
    <link href="https://zinirun.github.io/2021/01/31/go-deploy-heroku/"/>
    <id>https://zinirun.github.io/2021/01/31/go-deploy-heroku/</id>
    <published>2021-01-31T08:54:49.000Z</published>
    <updated>2021-01-31T09:30:18.934Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2021-01-31-17-57-53.png" alt="heroku + go"></p><p>요즘 Golang에 빠졌다. 책 한권을 다 읽고 Go의 병렬처리를 이용한 서비스를 만들었고, <code>echo</code> 기반의 웹으로 만들어서 배포해보고 싶었다. 갓 헤로쿠에서는 Go도 지원한다. 처음엔 조금 헤맸는데, 몇 번 시도 끝에 성공했다.</p><p>먼저 헤로쿠에 프로젝트를 하나 생성하고, 깃을 연결한다. 나는 깃허브 계정의 프로젝트를 연결했는데, Auto Deploy를 설정하면 커밋할 때마다 다시 빌드 후 배포해줘서 편하다.(이 과정에 대한 설명은 생략하겠다)</p><h3 id="Procfile-만들기"><a href="#Procfile-만들기" class="headerlink" title="Procfile 만들기"></a>Procfile 만들기</h3><p>프로젝트 최상단에 <code>Procfile</code> 파일을 만든다. 헤로쿠의 배포 설정에 대한 부분이고 확장자는 없다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web: go-project-name</span><br></pre></td></tr></table></figure><p><code>go-project-name</code>은 본인 프로젝트의 이름에 맞게 수정하면 된다. Procfile 설정은 끝이다.</p><h2 id="의존성-추가하기"><a href="#의존성-추가하기" class="headerlink" title="의존성 추가하기"></a>의존성 추가하기</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init github.com/user-name/project-name</span><br></pre></td></tr></table></figure><p>본인의 깃허브 레파지토리에 맞게 <code>go mod init</code> 명령어를 실행하면 <code>go.mod</code> 파일이 생성된다. <code>go mod</code> 파일에 require 항목을 작성해야 하는데, VSCode + Go 환경인 경우 <code>go.mod</code> 최상단에 보이는 버튼으로 자동으로 <code>require</code> 항목을 작성해주고, 의존성에 따른 <code>vendor</code> 폴더까지 자동으로 만들어준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module github.com&#x2F;zinirun&#x2F;eden-zip</span><br><span class="line"></span><br><span class="line">go 1.15</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com&#x2F;labstack&#x2F;echo v3.3.10+incompatible</span><br><span class="line">    github.com&#x2F;labstack&#x2F;gommon v0.3.0 &#x2F;&#x2F; indirect</span><br><span class="line">    golang.org&#x2F;x&#x2F;crypto v0.0.0-20201221181555-eec23a3978ad &#x2F;&#x2F; indirect</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>내 프로젝트에 적용한 <code>go.mod</code> 파일의 예시이다. <code>// indirect</code> 주석이 달린 의존성은 프로젝트에서 직접 추가한 패키지가 아닌, 패키지에서 요구되는 또 다른 의존성 패키지라는 의미이다.</p><h2 id="포트-설정하기"><a href="#포트-설정하기" class="headerlink" title="포트 설정하기"></a>포트 설정하기</h2><p>이번 프로젝트에는 Echo 프레임워크를 사용했는데, 다른 웹 프레임워크도 포트 설정은 비슷하게 할 것이다. 포트를 하드코딩하는 것이 아닌 <code>os.Getenv(&quot;PORT&quot;)</code>로 포트를 잡아줘야 헤로쿠 내부의 포트로 정상적으로 실행된다.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    e := echo.New()</span><br><span class="line">    e.Start(<span class="string">&quot;:&quot;</span> + os.Getenv(<span class="string">&quot;PORT&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기존에는 <code>:1323</code> 등의 방법으로 로컬에서 실행했지만, 배포시 <code>:ENV상의 PORT</code>로 설정해준다.</p><h2 id="Commit-and-Push"><a href="#Commit-and-Push" class="headerlink" title="Commit and Push"></a>Commit and Push</h2><p>이제 설정을 마친 레파지토리를 커밋 후 푸시하면 헤로쿠에 배포된다. <img src="www.herokuapp.com" alt="헤로쿠 웹페이지">에서 빌드 과정, 로그를 확인할 수 있다. 프로그램 실행 중의 로그를 볼 수도 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heroku logs -a 앱이름</span><br></pre></td></tr></table></figure><p><img src="/images/2021-01-31-18-29-47.png"></p><p>로그의 일부인데, 빌드가 정상적으로 끝났지만 웹이 열리지 않는 경우 로그를 보면 해결에 도움이 된다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/2021-01-31-17-57-53.png&quot; alt=&quot;heroku + go&quot;&gt;&lt;/p&gt;
&lt;p&gt;요즘 Golang에 빠졌다. 책 한권을 다 읽고 Go의 병렬처리를 이용한 서비스를 만들었고, &lt;code&gt;echo&lt;/code</summary>
      
    
    
    
    <category term="go" scheme="https://zinirun.github.io/categories/go/"/>
    
    
    <category term="heroku" scheme="https://zinirun.github.io/tags/heroku/"/>
    
    <category term="go" scheme="https://zinirun.github.io/tags/go/"/>
    
    <category term="echo" scheme="https://zinirun.github.io/tags/echo/"/>
    
  </entry>
  
  <entry>
    <title>Nest.js - Jest를 이용한 테스트</title>
    <link href="https://zinirun.github.io/2021/01/29/nestjs-study-4/"/>
    <id>https://zinirun.github.io/2021/01/29/nestjs-study-4/</id>
    <published>2021-01-29T07:02:20.000Z</published>
    <updated>2021-01-29T07:50:33.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="테스트의-종류"><a href="#테스트의-종류" class="headerlink" title="테스트의 종류"></a>테스트의 종류</h2><p>테스트에는 많은 종류가 있다.</p><ul><li><strong>유닛 테스트(Unit Testing)</strong> : 컴포넌트, 함수 단위의 작은 코드를 테스트</li><li><strong>엔드 투 엔드 테스트(End to End Testing)</strong> : 사용자 관점에서 취할만한 행동에 따라 각각의 서비스가 정해진 대로 동작하는지 테스트</li><li><strong>부하 테스트(Load Testing), 스트레스 테스트(Stress Testing)</strong> : 얼마나 많은 동시 접속자를 처리할 수 있는지 테스트 (서버 관점에서의 테스트)</li></ul><p>Nest.js에서는 기본적으로 E2E(End To End) 테스트 파일을 만들어주고, 컨트롤러, 서비스 각각을 제너레이터를 사용하여 생성하면 유닛 테스트 파일도 자동으로 만들어준다.</p><p>E2E 테스트는 <code>test</code> 폴더의 <code>app.e2e-spec.ts</code>에 있고, 유닛 테스트는 <code>src</code> 폴더 내부에 <code>.spec.ts</code>의 파일로 사용한다.</p><h2 id="유닛-테스트"><a href="#유닛-테스트" class="headerlink" title="유닛 테스트"></a>유닛 테스트</h2><p>기본적으로 <code>describe</code> <code>it</code> <code>expect</code>만 사용해서도 테스트할 수 있고, 원활한 사용을 위해서는 <code>beforeEach</code> <code>beforeAll</code> <code>afterEach</code> <code>afterAll</code>도 같이 쓴다.</p><h3 id="테스트-구조"><a href="#테스트-구조" class="headerlink" title="테스트 구조"></a>테스트 구조</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">&#x27;MoviesService&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> service: MoviesService;</span><br><span class="line"></span><br><span class="line">    beforeEach(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">module</span>: TestingModule = await Test.createTestingModule(&#123;</span><br><span class="line">            providers: [MoviesService],</span><br><span class="line">        &#125;).compile();</span><br><span class="line"></span><br><span class="line">        service = <span class="built_in">module</span>.get&lt;MoviesService&gt;(MoviesService);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(<span class="string">&#x27;should be defined&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        expect(service).toBeDefined();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>beforeEach에 대해서는 테스트 구조 설명 후 알아보겠다.</p></blockquote><p>먼저 테스트할 서비스를 불러오고, 서비스가 정의된 객체인지 판별한다. 테스트에 통과했다면 이제 서비스에 구현한 각각의 함수(Unit)에 대해 테스트를 수행하면 된다. <code>describe</code> 내부에 <code>describe</code>를 써서 상위, 하위 개념으로 작성한다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">&#x27;getAll&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    it(<span class="string">&#x27;should be return an array&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = service.getAll();</span><br><span class="line">        expect(result).toBeInstanceOf(<span class="built_in">Array</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>getAll</code> 메소드는 배열 타입을 반환해야 하는데, 이를 테스트한 것이다. <code>expect</code>는 말그대로 “기대”이다. <code>expect(a).toEqual(b)</code>라면 “a가 b와 같기를 기대해” 라는 의미이고, <code>toEqual</code>, <code>toBeDefined</code>, <code>toBeGreaterThan</code> 등 <code>expect</code>에서 사용할 수 있는 다양한 메소드를 활용해서 테스트를 진행한다.</p><p>하나 더 예를 들면, 서비스가 404(Not Found)를 뱉어주기를 원한다면 다음과 같이 작성할 수 있다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;should return a 404&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        service.deleteOne(<span class="number">999</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        expect(e).toBeInstanceOf(NotFoundException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>물론 서비스에서도 핸들링을 통해 <code>NotFoundException</code>을 뱉어야 한다. 이런 저명(?)한 예외 처리는 <code>@nestjs/common</code>에 왠만하면 다 들어가있어서 별도로 에러 객체를 구현하지 않아도 된다.</p><h3 id="beforeEach-beforeAll-afterEach-afterAll"><a href="#beforeEach-beforeAll-afterEach-afterAll" class="headerlink" title="beforeEach, beforeAll, afterEach, afterAll"></a>beforeEach, beforeAll, afterEach, afterAll</h3><p><code>describe</code> 내부에 넣는 하나의 메소드인데, 말 그대로 테스트 전/후로 각각 테스트/전체 테스트에 메소드를 실행하는 것이다.</p><p>예를 들어 <code>beforeEach</code>나 <code>beforeAll</code>은 테스트할 서비스 객체를 가져오거나 DB 연결을 초기화하는 등의 작업을 수행할 수 있고, <code>afterEach</code>나 <code>afterAll</code>로는 테스트 후 DB를 정리하는 등의 작업을 할 수 있다. 대부분의 테스트는 DB와 함께 동작할텐데, 이 때 필요한 동작을 번거로움없이 해결 할 수 있다.</p><h3 id="테스트-수행"><a href="#테스트-수행" class="headerlink" title="테스트 수행"></a>테스트 수행</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yarn <span class="built_in">test</span> <span class="comment"># npm run test</span></span><br><span class="line">$ yarn <span class="built_in">test</span>:watch <span class="comment"># npm run test:watch</span></span><br></pre></td></tr></table></figure><p>기본적으로 <code>test</code> 명령어로 테스트를 실행하고, <code>:watch</code>를 사용하면 파일이 저장되어 바뀔 때마다 새롭게 테스트를 실행할 수 있다.</p><h2 id="E2E-테스트"><a href="#E2E-테스트" class="headerlink" title="E2E 테스트"></a>E2E 테스트</h2><p>E2E 테스트도 유닛 테스트와 구조는 다를 게 없다. 테스트 하는 대상의 범위만 다를 뿐이다. 유닛 테스트가 톱니바퀴에 나사가 잘 끼워졌는지, 윤활은 잘 되어있는지 등을 검사한다면 E2E 테스트는 톱니바퀴가 잘 돌아가는 그림 정도를 본다.</p><h3 id="테스트-구조-1"><a href="#테스트-구조-1" class="headerlink" title="테스트 구조"></a>테스트 구조</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">&#x27;AppController (e2e)&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> app: INestApplication;</span><br><span class="line"></span><br><span class="line">    beforeAll(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> moduleFixture: TestingModule = <span class="keyword">await</span> Test.createTestingModule(&#123;</span><br><span class="line">            imports: [AppModule],</span><br><span class="line">        &#125;).compile();</span><br><span class="line"></span><br><span class="line">        app = moduleFixture.createNestApplication();</span><br><span class="line">        <span class="comment">// 실제 app의 pipe를 test에도 별도로 적용해야 데코레이터가 적용됨</span></span><br><span class="line">        app.useGlobalPipes(</span><br><span class="line">            <span class="keyword">new</span> ValidationPipe(&#123;</span><br><span class="line">                whitelist: <span class="literal">true</span>,</span><br><span class="line">                forbidNonWhitelisted: <span class="literal">true</span>,</span><br><span class="line">                transform: <span class="literal">true</span>,</span><br><span class="line">            &#125;),</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">await</span> app.init();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(<span class="string">&#x27;/ (GET)&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> request(app.getHttpServer()).get(<span class="string">&#x27;/&#x27;</span>).expect(<span class="number">200</span>).expect(<span class="string">&#x27;Welcome to API&#x27;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>Nest가 자동으로 E2E 테스트의 틀은 짜준다. 여기서 채워넣으면 되는데, 주의할 점이 있다. 테스트 전에 실행하는 메소드인 <code>beforeAll</code> 내부를 보면 <code>app</code>을 다시 생성한다. 따라서 <code>main.ts</code>에서 별도로 <code>app</code>에 global pipe를 추가했거나 다른 파이프를 연결한 경우 필요에 따라 다시 app에 미들웨어를 끼워줘야 한다. 이러지 않으면 실제 구동할 때와 테스트할 때 app의 속성이 달라서 당황할 수도 있다.</p><h3 id="GET-테스트"><a href="#GET-테스트" class="headerlink" title="GET 테스트"></a>GET 테스트</h3><p><code>/</code>에 GET 요청이 들어왔을 때의 E2E 테스트를 보자.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;/ (GET)&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(app.getHttpServer()).get(<span class="string">&#x27;/&#x27;</span>).expect(<span class="number">200</span>).expect(<span class="string">&#x27;Welcome to movie API&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>beforeAll</code>에서 초기화한 <code>app</code>을 사용하기 위해 <code>request()</code> 메소드를 사용한다. <code>request(app.getHttpServer())</code>를 통해 GET, POST 등의 요청을 보낼 수 있다. 그 후 똑같이 <code>expect</code>를 테스트 목적에 맞게 이어주면 된다.</p><h3 id="POST-테스트"><a href="#POST-테스트" class="headerlink" title="POST 테스트"></a>POST 테스트</h3><p>POST 요청에 대한 테스트로 하나 더 예를 들자면,</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;POST 201&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(app.getHttpServer())</span><br><span class="line">        .post(<span class="string">&#x27;/movies&#x27;</span>)</span><br><span class="line">        .send(&#123;</span><br><span class="line">            title: <span class="string">&#x27;Test&#x27;</span>,</span><br><span class="line">            year: <span class="number">2020</span>,</span><br><span class="line">            genres: [<span class="string">&#x27;test&#x27;</span>],</span><br><span class="line">        &#125;)</span><br><span class="line">        .expect(<span class="number">201</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>GET과 방식은 유사한데, <code>send</code> 메소드를 통해 Body에 내용을 실어서 보낸다. 그리고 정상적으로 POST되었다는 응답인 201 상태를 <code>expect</code>에 걸어주면 된다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;POST 400&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(app.getHttpServer())</span><br><span class="line">        .post(<span class="string">&#x27;/movies&#x27;</span>)</span><br><span class="line">        .send(&#123;</span><br><span class="line">            title: <span class="string">&#x27;Test&#x27;</span>,</span><br><span class="line">            year: <span class="number">2020</span>,</span><br><span class="line">            genres: [<span class="string">&#x27;test&#x27;</span>],</span><br><span class="line">            other: <span class="string">&#x27;thing&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .expect(<span class="number">400</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Validator에 대한 검증을 위해 성공하면 안되는 경우를 테스트할 때는 위처럼 400 상태를 <code>expect</code>에 걸어주면 된다.</p><h3 id="uri에-대한-테스트-묶기"><a href="#uri에-대한-테스트-묶기" class="headerlink" title="uri에 대한 테스트 묶기"></a>uri에 대한 테스트 묶기</h3><p>그리고 일반적으로 한 uri에 포함된 GET, POST, DELETE 등의 테스트들은 한 개의 <code>describe</code>에 묶어준다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">&#x27;/movies/:id&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        it(<span class="string">&#x27;GET 200&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> request(app.getHttpServer()).get(<span class="string">&#x27;/movies/1&#x27;</span>).expect(<span class="number">200</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        it(<span class="string">&#x27;GET 404&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> request(app.getHttpServer()).get(<span class="string">&#x27;/movies/999&#x27;</span>).expect(<span class="number">404</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        it(<span class="string">&#x27;PATCH 200&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> request(app.getHttpServer())</span><br><span class="line">                .patch(<span class="string">&#x27;/movies/1&#x27;</span>)</span><br><span class="line">                .send(&#123; title: <span class="string">&#x27;Updated Test&#x27;</span> &#125;)</span><br><span class="line">                .expect(<span class="number">200</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        it(<span class="string">&#x27;DELETE 200&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> request(app.getHttpServer()).delete(<span class="string">&#x27;/movies/1&#x27;</span>).expect(<span class="number">200</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        it(<span class="string">&#x27;DELETE 404&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> request(app.getHttpServer()).delete(<span class="string">&#x27;/movies/999&#x27;</span>).expect(<span class="number">404</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>위 같은 방식으로 묶어주면 테스트 화면에서</p><p><img src="/images/2021-01-29-16-41-19.png"></p><p>이렇게 가독성 좋은 결과를 출력할 수 있다.</p><h3 id="테스트-수행-1"><a href="#테스트-수행-1" class="headerlink" title="테스트 수행"></a>테스트 수행</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn <span class="built_in">test</span>:e2e <span class="comment"># npm run test:e2e</span></span><br></pre></td></tr></table></figure><p>말 그대로 <code>test</code>에 <code>:e2e</code>를 붙여주면 E2E 테스트를 수행할 수 있다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><h3 id="테스트-커버리지-보기"><a href="#테스트-커버리지-보기" class="headerlink" title="테스트 커버리지 보기"></a>테스트 커버리지 보기</h3><p>테스트에 대한 커버리지를 보고 싶다면 다음과 같이 입력하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn <span class="built_in">test</span>:cov <span class="comment"># npm run test:cov</span></span><br></pre></td></tr></table></figure><p><img src="/images/2021-01-29-16-49-23.png"></p><p>정상적으로 테스트를 모든 유닛에 대해 적용했다면 100이 나온다.</p><h3 id="테스트의-중요성"><a href="#테스트의-중요성" class="headerlink" title="테스트의 중요성"></a>테스트의 중요성</h3><p>Nest에서 기본적으로 제공하는 Jest를 활용한 테스트를 알아보았다. 실제 실무에서는 비즈니스 로직에 대한 코드 작성보다 테스트를 위한 코드 작성에 시간을 더 할애하는 경우도 많다고 한다. 그만큼 테스트가 중요하다는 말이다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;테스트의-종류&quot;&gt;&lt;a href=&quot;#테스트의-종류&quot; class=&quot;headerlink&quot; title=&quot;테스트의 종류&quot;&gt;&lt;/a&gt;테스트의 종류&lt;/h2&gt;&lt;p&gt;테스트에는 많은 종류가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;유닛 테스트(Unit </summary>
      
    
    
    
    <category term="Nest.js" scheme="https://zinirun.github.io/categories/Nest-js/"/>
    
    
    <category term="Nest.js" scheme="https://zinirun.github.io/tags/Nest-js/"/>
    
  </entry>
  
  <entry>
    <title>Nest.js - DTO를 PartialType으로 재사용하기</title>
    <link href="https://zinirun.github.io/2021/01/29/nestjs-study-3/"/>
    <id>https://zinirun.github.io/2021/01/29/nestjs-study-3/</id>
    <published>2021-01-29T06:55:52.000Z</published>
    <updated>2021-01-29T07:02:34.529Z</updated>
    
    <content type="html"><![CDATA[<h2 id="extends-PartialType"><a href="#extends-PartialType" class="headerlink" title="extends PartialType"></a>extends PartialType</h2><p>POST, UPDATE 요청을 처리할 때 데이터 삽입에 대한 DTO, 데이터 수정에 대한 DTO를 만든다. 일반적으로 데이터 수정 DTO는 삽입 시의 DTO에 종속된다. 수정시의 DTO에 들어가는 개체가 삽입시의 DTO에 들어있는 개체에 포함된다는 것이다.</p><p>그런 상황에서 사용할 수 있는 것이 <code>PartialType</code>다.</p><p>POST 처리를 위한 DTO가 <code>CreateDto</code>라고 가정하면,</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; IsNumber, IsOptional, IsString &#125; <span class="keyword">from</span> <span class="string">&#x27;class-validator&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CreateDto &#123;</span><br><span class="line">    <span class="meta">@IsString</span>()</span><br><span class="line">    <span class="keyword">readonly</span> title: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IsNumber</span>()</span><br><span class="line">    <span class="keyword">readonly</span> year: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IsString</span>(&#123; each: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="meta">@IsOptional</span>()</span><br><span class="line">    <span class="keyword">readonly</span> genres: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런식이 된다. 이제 이 클래스를 <code>UpdateDto</code>에도 재사용할 수 있다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PartialType &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/mapped-types&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CreateDto &#125; <span class="keyword">from</span> <span class="string">&#x27;./create.dto&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> UpdateDto <span class="keyword">extends</span> PartialType(CreateDto) &#123;&#125;</span><br></pre></td></tr></table></figure><p>위처럼 <code>extends PartialType(상위DTO)</code>를 통해 선택적으로 종속받을 수 있다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;extends-PartialType&quot;&gt;&lt;a href=&quot;#extends-PartialType&quot; class=&quot;headerlink&quot; title=&quot;extends PartialType&quot;&gt;&lt;/a&gt;extends PartialType&lt;/h2&gt;&lt;p&gt;PO</summary>
      
    
    
    
    <category term="Nest.js" scheme="https://zinirun.github.io/categories/Nest-js/"/>
    
    
    <category term="Nest.js" scheme="https://zinirun.github.io/tags/Nest-js/"/>
    
  </entry>
  
  <entry>
    <title>Nest.js - 컨트롤러, 서비스, 모듈의 구현</title>
    <link href="https://zinirun.github.io/2021/01/28/nestjs-study-2/"/>
    <id>https://zinirun.github.io/2021/01/28/nestjs-study-2/</id>
    <published>2021-01-28T04:36:16.000Z</published>
    <updated>2021-01-28T06:23:55.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="컨트롤러-서비스-모듈-구현하기"><a href="#컨트롤러-서비스-모듈-구현하기" class="headerlink" title="컨트롤러, 서비스, 모듈 구현하기"></a>컨트롤러, 서비스, 모듈 구현하기</h2><h3 id="컨트롤러-서비스-모듈-생성"><a href="#컨트롤러-서비스-모듈-생성" class="headerlink" title="컨트롤러, 서비스, 모듈 생성"></a>컨트롤러, 서비스, 모듈 생성</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nest g mo <span class="comment">#module</span></span><br><span class="line">nest g co <span class="comment">#controller</span></span><br><span class="line">nest g s <span class="comment">#service</span></span><br></pre></td></tr></table></figure><p>generate 명령어로 컨트롤러와 서비스, 모듈을 같은 이름으로 생성한다. 그러면 그 이름으로 된 폴더가 src 폴더에 만들어지고 그 안에 3개의 파일과 <code>.spec.ts</code>의 테스트 파일이 생성된다.</p><h3 id="모듈-다루기"><a href="#모듈-다루기" class="headerlink" title="모듈 다루기"></a>모듈 다루기</h3><p>모듈은 같은 이름으로 생성한 컨트롤러와 서비스를 import해서 한 역할을 하는 모듈로 만든다. 그 모듈들이 루트 모듈(AppModule)에서 import되고, 객체지향 프로그래밍을 할 수 있게 된다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MoviesController &#125; <span class="keyword">from</span> <span class="string">&#x27;./movies.controller&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MoviesService &#125; <span class="keyword">from</span> <span class="string">&#x27;./movies.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">    controllers: [MoviesController],</span><br><span class="line">    providers: [MoviesService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MoviesModule &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>위처럼 기본적인 구조를 nest에서 알아서 잡아주기에 필요시 controllers와 providers(서비스)에 넣어주면 된다.</p><h3 id="컨트롤러-다루기"><a href="#컨트롤러-다루기" class="headerlink" title="컨트롤러 다루기"></a>컨트롤러 다루기</h3><p>컨트롤러는 클라이언트로부터 uri를 통해 특정 작업을 요청받고, 서비스로 데이터 처리를 요청하고 클라이언트에게 반환하는 역할을 한다. 따라서 Nest의 OOP 철학을 준수하기 위해서는 비즈니스 로직을 서비스에 구현하여 컨트롤러와 분리시켜야 한다.</p><h4 id="GET-다루기"><a href="#GET-다루기" class="headerlink" title="GET 다루기"></a>GET 다루기</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Movie &#125; <span class="keyword">from</span> <span class="string">&#x27;./entities/movie.entity&#x27;</span>;</span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">&#x27;movies&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MoviesController &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> <span class="keyword">readonly</span> moviesService: MoviesService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Get</span>()</span><br><span class="line">    getAll(): Movie[] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.moviesService.getAll();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>이렇게 GET 요청을 받고, 서비스에 넘겨줄 뿐이다. 신기한 것은 서비스를 따로 import하지 않고 생성자(constructor)에서 불러온다는 것이다. <code>@Get</code>으로 GET 요청을 받고 있는데, REST API에서 사용하는 <code>@Post</code> <code>@Put</code> <code>@Patch</code> <code>@Delete</code> 등 모든 메소드를 데코레이터로 사용할 수 있다. (이 점에서 상당히 스프링부트와 유사하다)</p><p>또한 기본적으로 타입스크립트 기반이기 때문에 Type을 준수해야 한다. 당연히 기본적인 타입으로는 정확한 타입을 명시하지 못하는 경우가 많은데, <code>entities</code> 폴더를 따로 만들어 별도의 타입을 명시할 수 있다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/movies/entities/movie.entity.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Movie &#123;</span><br><span class="line">    id: <span class="built_in">number</span>;</span><br><span class="line">    title: <span class="built_in">string</span>;</span><br><span class="line">    year: <span class="built_in">number</span>;</span><br><span class="line">    genres: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 이 entity를 타입스크립트 리턴 타입, 파라미터 타입으로 사용하면 된다. (이 부분은 Nest보다는 타입스크립트에 가까우니 더 자세한 설명은 생략하겠다)</p><p>본론으로 넘어와서, <code>/movies</code>에 GET 요청을 받으면</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Get</span>()</span><br><span class="line">getAll(): Movie[] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.moviesService.getAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 getAll 함수가 호출되고, 이 컨트롤러에서 생성자에서 정의한 서비스의 메소드를 호출한다.</p><h4 id="POST-다루기"><a href="#POST-다루기" class="headerlink" title="POST 다루기"></a>POST 다루기</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Post</span>()</span><br><span class="line">create(<span class="meta">@Body</span>() movieData: CreateMovieDto): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.moviesService.create(movieData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>POST 요청도 GET과 마찬가지다. Body의 내용은 <code>@Body() 변수이름: (타입)</code>으로 받는다. Body로 넘어온 인자에 대한 유효성 검사는 나중에 <code>DTO</code> 개념에 대해서 설명하겠다. (이걸 아는 순간 신세계가 열린다)</p><p>다른 DELETE, PATCH 등의 요청도 똑같이 <code>@Delete()</code>, <code>@Patch()</code> 등의 데코레이터로 알맞게 받아주면 된다.</p><h4 id="파라미터-쿼리-받기"><a href="#파라미터-쿼리-받기" class="headerlink" title="파라미터, 쿼리 받기"></a>파라미터, 쿼리 받기</h4><p>파라미터든 쿼리든 컨트롤러에서 자유롭게 받을 수 있다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Get</span>(<span class="string">&#x27;search&#x27;</span>)</span><br><span class="line">search(<span class="meta">@Query</span>(<span class="string">&#x27;year&#x27;</span>) searchingYear: <span class="built_in">number</span>): Movie[] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.moviesService.search(searchingYear);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>쿼리는 위처럼 <code>@Query(&#39;value 이름&#39;) 변수명: (타입)</code>으로 받는다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Get</span>(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line">getOne(<span class="meta">@Param</span>(<span class="string">&#x27;id&#x27;</span>) movieId: <span class="built_in">number</span>): Movie &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.moviesService.getOne(movieId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>파라미터는 <code>@Param(&#39;value 이름&#39;) 변수명: (타입)</code>으로 받는다.</p><h4 id="Req-Res를-사용하지-않는-이유"><a href="#Req-Res를-사용하지-않는-이유" class="headerlink" title="Req, Res를 사용하지 않는 이유"></a>Req, Res를 사용하지 않는 이유</h4><p>그런데 Express에서는 Request 객체로 쿼리와 파라미터를 다뤘었다. 그래서 보통 <code>req.params</code>, <code>req.query</code>처럼 request 객체를 직접 인자로 받아 핸들링했다. Nest에서도 <code>@Req</code>, <code>@Res</code>처럼 Express 응답 객체를 다룰 수 있지만, Nest는 Express 프레임워크만이 아닌 Fastify 프레임워크도 지원한다. 따라서 프로젝트를 무조건 Express로 고정할 것이 아니라면 <code>@Param</code> <code>@Query</code> 등 공통적으로 사용할 수 있는 Nest의 방식을 준수하는 것이 낫다.</p><blockquote><p>참고로 Fastify는 Express보다 벤치마킹 결과가 2배정도 빠르다고 한다</p></blockquote><h3 id="서비스-다루기"><a href="#서비스-다루기" class="headerlink" title="서비스 다루기"></a>서비스 다루기</h3><p>서비스는 비즈니스 로직의 전반이 구현된 클래스이다. 컨트롤러에서 받은 요청을 처리하는데, 이 비즈니스 로직은 데이터 처리 등의 모든 로직이 포함되어 있다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MoviesService &#123;</span><br><span class="line">    <span class="keyword">private</span> movies: Movie[] = [];</span><br><span class="line"></span><br><span class="line">    getAll(): Movie[] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.movies;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>위 컨트롤러에서 GET 요청을 받고 서비스의 <code>getAll()</code>을 호출한다. 여기서 받은 데이터를 그대로 컨트롤러에 넘겨주고, 컨트롤러는 클라이언트에 넘겨준다.</p><p>여기서는 데이터베이스 없이 메모리상의 배열 데이터를 DB로 가정했지만, 실제로는 Sequelize같은 ORM을 쓰던, Mysql 라이브러리를 쓰던지 해서 데이터를 처리하면 된다.</p><h4 id="파라미터가-있는-메소드-처리"><a href="#파라미터가-있는-메소드-처리" class="headerlink" title="파라미터가 있는 메소드 처리"></a>파라미터가 있는 메소드 처리</h4><p>파라미터가 있는 메소드도 마찬가지다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search(year: <span class="built_in">number</span>): Movie[] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.movies.filter(<span class="function">(<span class="params">movie</span>) =&gt;</span> movie.year &gt;= year);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컨트롤러에서 받은 타입을 그대로 서비스 메소드의 파라미터 타입에도 그대로 명시하고 처리하면 된다. 타입스크립트기에 타입을 정확하게 다룰 수 있어야 한다.</p><p>서비스는 전반적으로 이렇게 구현된다. 이러면 OOP 개념은 거의 끝났다. 이제 신세계를 느꼈던 DTO에 대해서 알아볼까 한다.</p><h3 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a>DTO</h3><p>DTO(Data Transfer Object)는 데이터 교환을 위한 객체이다. POST, PUT 등 Body에 데이터를 실어서 보낼 때 사용한다. 일반적으로 Express에서는 검증 미들웨어를 별도로 구현하던지, 실제 비즈니스 로직에서 파라미터의 데이터에 대한 유효성 처리를 구현해야 한다.</p><p>Nest에서는 DTO를 정의하고, global pipe를 연결해주면 정말 쉽게 클라이언트가 보낸 데이터에 대한 검증을 해결할 수 있다. </p><h4 id="class-validator-사용하기"><a href="#class-validator-사용하기" class="headerlink" title="class-validator 사용하기"></a>class-validator 사용하기</h4><p>우선 <code>class-validator</code>를 npm 패키지로 설치한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add class-validator <span class="comment"># npm i class-validator</span></span><br></pre></td></tr></table></figure><p>그리고 같은 폴더에 <code>dto</code>라는 폴더를 만들고, <code>~.dto.ts</code> 파일을 만든다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/movies/dto/create-movie.dto.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; IsNumber, IsOptional, IsString &#125; <span class="keyword">from</span> <span class="string">&#x27;class-validator&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CreateMovieDto &#123;</span><br><span class="line">    <span class="meta">@IsString</span>()</span><br><span class="line">    <span class="keyword">readonly</span> title: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IsNumber</span>()</span><br><span class="line">    <span class="keyword">readonly</span> year: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IsString</span>(&#123; each: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="meta">@IsOptional</span>()</span><br><span class="line">    <span class="keyword">readonly</span> genres: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 POST 요청 시 받을 데이터를 위에서 엔터티 만들던 방식대로 만든다. 그리고 <code>@IsString()</code> 등의 데코레이터를 달아준다. <code>class-validator</code>에는 정말 많은 검증 데코레이터가 있다. <a href="https://www.npmjs.com/package/class-validator">NPM 공식 문서</a>에서 Validation decorators를 보고 알맞게 데코레이터를 붙여주면 된다. 참고로 <code>&#123;each: true&#125;</code>를 넣은 것은 배열 하위의 데이터 각자가 <code>string</code>이어야 한다고 명시한 것이다. <code>@IsOptinal</code>은 선택사항이고 없어도 된다는 데코레이터이다.</p><h3 id="useGlobalPipes-추가하기"><a href="#useGlobalPipes-추가하기" class="headerlink" title="useGlobalPipes 추가하기"></a>useGlobalPipes 추가하기</h3><p>이제 이 Validator가 돌아갈 수 있게 미들웨어 형식으로 메인 <code>app</code>에 달아준다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ValidationPipe &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NestFactory &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppModule &#125; <span class="keyword">from</span> <span class="string">&#x27;./app.module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create(AppModule);</span><br><span class="line">    app.useGlobalPipes(</span><br><span class="line">        <span class="keyword">new</span> ValidationPipe(&#123;</span><br><span class="line">            whitelist: <span class="literal">true</span>,</span><br><span class="line">            forbidNonWhitelisted: <span class="literal">true</span>,</span><br><span class="line">            transform: <span class="literal">true</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">await</span> app.listen(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure><p>마법이 시작되는 공간이다. ValidationPipe를 미들웨어로 달아줌으로써 위의 DTO에서 구현해놓은 데코레이터가 작동하며 클라이언트로부터 전달받은 파라미터의 데이터를 검증한다. Exception을 뱉어줄 경우 친절하게 왜 뱉었는지도 알려준다. <code>whitelist</code>, <code>forbidNonWhitelisted</code>, <code>transfrom</code> 옵션에 대해서 알아보자.</p><h4 id="transform-옵션"><a href="#transform-옵션" class="headerlink" title="transform 옵션"></a>transform 옵션</h4><p>아직 마법까진 아니라고 생각할 수도 있다. 자, 이제 <code>transform</code>에 대한 기능이다. 잠시 DTO 생각은 잊고, 일반적으로 파라미터 넘어온 값은 숫자로 보내도 벡엔드에서는 string 형식으로 받는다. 그래서 대부분 <code>parseInt()</code> 메소드나 <code>+number</code> 등의 방식으로 데이터 타입을 한번 변경한 후 사용한다.</p><p>예를 들면,</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Get</span>(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line">getOne(<span class="meta">@Param</span>(<span class="string">&#x27;id&#x27;</span>) movieId: <span class="built_in">string</span>): Movie &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.moviesService.getOne(movieId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 id는 number형으로 넘겨받고 싶지만 어쩔 수 없이 string으로 받고 서비스나 컨트롤러에서 데이터 타입을 변환해야 한다. 하지만 위 global pipe에서 <code>transform</code> 옵션을 넣었기 때문에 이제 number로 받아도 된다. 알아서 데이터 타입을 변경해준다. 결론적으로 <code>transform</code>은 클라이언트가 보낸 값을 서버가 원하는 값의 타입으로 변환한다. 그러면 만약에 <code>abc</code> 처럼 number로 변환할 수 없는 값을 받았을 때는? <code>NaN</code>으로 변환되기 때문에 로직에서 문제될 것이 없다.</p><h4 id="whitelist-옵션"><a href="#whitelist-옵션" class="headerlink" title="whitelist 옵션"></a>whitelist 옵션</h4><p><code>whitelist: true</code>는 유효하지 않은 데이터가 포함되어 넘어왔을 때 Validator에 도달하지 않게 한다.</p><p>예를 들어서 <code>CreateMovieDto</code>에서는 <code>title</code>, <code>year</code>, <code>genres</code>를 받았지만 만약 클라이언트가 악의적으로 <code>hello</code> 개체를 데이터에 포함해서 넘겼다면, whitelist에서 자동으로 <code>hello</code> 개체는 빼고 보낸다.</p><h4 id="forbidNonWhitelisted-옵션"><a href="#forbidNonWhitelisted-옵션" class="headerlink" title="forbidNonWhitelisted 옵션"></a>forbidNonWhitelisted 옵션</h4><p><code>forbidNonWhitelisted: true</code>는 유효하지 않은 개체일 경우 리퀘스트 자체를 막는다. 이 3개의 옵션뿐만 아니라 공식 문서에 useGlobalPipes에 들어가는 여러가지 옵션이 있다.</p><h3 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h3><p>타입스크립트와 Express만 어느정도 다룰 줄 안다면 Nest를 적용시키는 것은 일도 아니다. 오히려 너무 편하다. 분명히 내가 모르는 다른 유용한 기능도 많을 것이고, 그런 것들은 공식문서나 검색으로 넣어주면 된다. 다음에는 테스트에 대해서 알아볼 것인데, 사실 테스트에 큰 흥미가 없었는데 이번 기회에 <code>Jest</code>를 사용한 유닛 테스트, E2E 테스트에 많은 재미를 느꼈다. 아무튼 난 토이프로젝트가 아닌 이상 Pure Express App이 아닌 Nest 프레임워크를 사용할 것 같다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;컨트롤러-서비스-모듈-구현하기&quot;&gt;&lt;a href=&quot;#컨트롤러-서비스-모듈-구현하기&quot; class=&quot;headerlink&quot; title=&quot;컨트롤러, 서비스, 모듈 구현하기&quot;&gt;&lt;/a&gt;컨트롤러, 서비스, 모듈 구현하기&lt;/h2&gt;&lt;h3 id=&quot;컨트롤러-</summary>
      
    
    
    
    <category term="Nest.js" scheme="https://zinirun.github.io/categories/Nest-js/"/>
    
    
    <category term="Nest.js" scheme="https://zinirun.github.io/tags/Nest-js/"/>
    
  </entry>
  
  <entry>
    <title>Nest.js 시작하기 - 꼭 써야하는 이유와 OOP</title>
    <link href="https://zinirun.github.io/2021/01/27/nestjs-study-1/"/>
    <id>https://zinirun.github.io/2021/01/27/nestjs-study-1/</id>
    <published>2021-01-27T13:00:55.000Z</published>
    <updated>2021-01-28T04:40:38.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nest-js"><a href="#Nest-js" class="headerlink" title="Nest.js"></a>Nest.js</h2><blockquote><p>Nest, Next, Nuxt… 이름은 비슷해보여도 서로 전혀 다른 프레임워크이다. 이름을 같은 자리에서 동시에 지었나</p></blockquote><p>Express만을 이용하여 Node.js 개발을 하다보면 다른 언어에서는 찾아볼 수 없는 자유에 취하다가, 모든 것을 개발자에게 맡기는 그 자유때문에 서비스의 규모가 커질수록 유지보수, 테스트가 어려워지고 코드도 난해해지기 일쑤다. 그래서 Typescript를 적용해서 Node.ts 환경으로 코드를 작성하면 훨씬 나아지지만, 초기 설정에는 시간과 비용이 든다. OOP(Object Oriented Programming)보다 Functional Programming에 익숙한 나는 타입스크립트를 적용한 환경에서도 모듈, 컨트롤러들의 배치와 구조를 결국 내 생각대로 짰어야 했다. 그 모든 비효율을 잡아주는 프레임워크가 <a href="https://nestjs.com/">Nest.js</a>이다.</p><p>이번에 Nest.js를 공부하면서 정말 1시간에 한번은 감탄한 것 같다. 대단할 정도로 구조를 잘 잡아주고, 테스트 파일(Jest)도 자동으로 생성해주고, import도 자동으로 해준다. 장점도 무궁무진하지만 소규모 프로젝트에는 시간, 비용이 역으로 들 수도 있으니 어느 정도 규모가 있는 프로젝트를 체계적으로 구축하고 싶을 때 망설임없이 사용해도 되겠다고 생각했다.</p><h2 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -g @nestjs/cli</span><br></pre></td></tr></table></figure><p>설치는 npm global로 설치하면 된다. <code>yarn global add</code>는 설치가 되는 것처럼 보여도 문제가 생긴다. yarn 신봉자이지만 이번엔 npm으로 설치했다.</p><h2 id="프로젝트-시작"><a href="#프로젝트-시작" class="headerlink" title="프로젝트 시작"></a>프로젝트 시작</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nest new first-nest-project</span><br></pre></td></tr></table></figure><p>프로젝트가 만들어지면 모든 초기 폴더와 파일들이 세팅된다. 대부분의 작업은 <code>src</code>에서 진행될 것이고, end-to-end 테스트에는 <code>test</code> 폴더 내부에서 작업할 것이다.</p><p><code>src</code>의 구조는 다음과 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── src</span><br><span class="line">     ├── app.controller.ts</span><br><span class="line">     ├── app.service.ts</span><br><span class="line">     ├── app.module.ts</span><br><span class="line">     ├── main.ts</span><br></pre></td></tr></table></figure><h2 id="Nest-관점에서-OOP의-이해"><a href="#Nest-관점에서-OOP의-이해" class="headerlink" title="Nest 관점에서 OOP의 이해"></a>Nest 관점에서 OOP의 이해</h2><h3 id="모듈"><a href="#모듈" class="headerlink" title="모듈"></a>모듈</h3><p><img src="/images/2021-01-27-22-15-06.png" alt="모듈의 구조"></p><p>모듈은 어플리케이션의 일부분이다. 한 어플리케이션 안에는 루트 모듈(Root Module)이 1개 존재하고, 그 루트 모듈 하위에 여러가지 모듈이 import된다. 그림처럼 Users, Orders, Chat 3가지 각각 다른 역할의 어플리케이션의 일부분은 루트 모듈 하위에 들어간다. Nest에서는 <code>@Module()</code> 데코레이터로 모듈을 정의한다.</p><h3 id="컨트롤러"><a href="#컨트롤러" class="headerlink" title="컨트롤러"></a>컨트롤러</h3><p><img src="/images/2021-01-27-22-18-58.png" alt="컨트롤러의 구조"></p><p>컨트롤러는 Express의 라우터 개념이다. 클라이언트의 Request를 받고 Response를 반환해준다. uri로 전달받은 요청을 프로바이더로 넘겨준다.</p><h3 id="프로바이더-서비스"><a href="#프로바이더-서비스" class="headerlink" title="프로바이더 (서비스)"></a>프로바이더 (서비스)</h3><p><img src="/images/2021-01-27-22-20-05.png" alt="프로바이더의 구조"></p><p>컨트롤러에서 받은 요청을 처리하는 비즈니스 로직을 정의하는 부분이다. Nest는 컨트롤러를 비즈니스 로직(서비스)와 구분짓고 싶어한다.</p><blockquote><p>Dependency Injection: 컨트롤러에서 서비스를 불러올 때 Nest가 서비스를 import하고 컨트롤러에 의존성을 주입(inject)하는 과정이다. 그래서 서비스에는 @Injectable() 데코레이터를 붙인다. 결국 컨트롤러에서 직접 import하지 않아도 된다.</p></blockquote><h2 id="generate-사용하기"><a href="#generate-사용하기" class="headerlink" title="generate 사용하기"></a>generate 사용하기</h2><p>Root 구조(<code>app.module</code>, <code>app.controller</code>, <code>app.service</code>)는 자동으로 초기에 잡아준다. 그러면 다른 파일은 직접 작성해야 할까? 사실 이 부분에서 감동이었다. 명령어 몇 자만 치면 내가 원하는 파일을 만들고, <code>.spec</code> 파일을 만들고(나중에 유닛 테스트시 필요한 파일이다), App Module(루트 모듈)에 자동으로 import도 시켜준다. (여기다가 vscode extension 중 auto import라는 툴을 같이 사용하면 코드 꼭대기에서 import… 를 직접 칠 일이 없다)</p><h3 id="nest를-쳐보자"><a href="#nest를-쳐보자" class="headerlink" title="nest를 쳐보자"></a>nest를 쳐보자</h3><p><img src="/images/2021-01-27-22-27-49.png" alt="nest 명령어"></p><p>쉘에 <code>nest</code>를 입력하면 generate 옵션들이 나온다. 위에서 말한 모듈, 컨트롤러, 서비스(프로바이더)가 목록에 있다. 이외에도 graphql 리졸버까지 자동으로 만들어준다.</p><h3 id="nest-g"><a href="#nest-g" class="headerlink" title="nest g"></a>nest g</h3><p>generate는 g로 대체할 수 있고, 위 목록에서 name을 전부 치지 않고 alias만 쳐도 된다.</p><p>그러니까 모듈은 <code>nest g mo</code>, 컨트롤러는 <code>nest g co</code>, 서비스는 <code>nest g s</code>로 만들 수 있다.</p><p>예를 들어 컨트롤러를 만들기 위해 <code>nest g co</code>를 입력하면</p><p><img src="/images/2021-01-27-22-31-05.png" alt="nest g co 입력시"></p><p>이렇게 컨트롤러의 이름을 묻는다. 내가 원하는 이름으로 해주면 되는데, 그에 따른 모듈과 서비스의 이름도 동일하게 만들면 된다. 그러면 한 폴더에서 자동으로 서로 엮어준다.</p><blockquote><p>지금은 Nest.js에 대한 기초 공부를 모두 마친 상태인데, 다시 정리할 겸 적고 있다. 앞으로 Pure Express 어플리케이션을 만들 일이 있을까 싶다. 공부하다 보면 얼마전에 맛만 본 Spring Boot와 정말 비슷한 느낌이 드는데, 난 개인적으로 Java보다 Typescript가 더 좋다. 그래서 Nest.js는 3일동안 정말 흥미롭게 공부했고 푹 빠졌다.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Nest-js&quot;&gt;&lt;a href=&quot;#Nest-js&quot; class=&quot;headerlink&quot; title=&quot;Nest.js&quot;&gt;&lt;/a&gt;Nest.js&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Nest, Next, Nuxt… 이름은 비슷해보여도 서로 전혀 다른</summary>
      
    
    
    
    <category term="Nest.js" scheme="https://zinirun.github.io/categories/Nest-js/"/>
    
    
    <category term="Nest.js" scheme="https://zinirun.github.io/tags/Nest-js/"/>
    
  </entry>
  
  <entry>
    <title>Gulp.js로 빌드 자동화하기</title>
    <link href="https://zinirun.github.io/2021/01/27/node-gulp-start/"/>
    <id>https://zinirun.github.io/2021/01/27/node-gulp-start/</id>
    <published>2021-01-27T11:41:10.000Z</published>
    <updated>2021-01-27T11:51:52.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Gulp-js"><a href="#Gulp-js" class="headerlink" title="Gulp.js"></a>Gulp.js</h2><p>Node.js 프로젝트를 하면서 빌드, 개발 테스트에 귀찮을 때가 많다. 이런 귀찮음을 위해서 쓰는 도구가 <a href="gulpjs.com">Gulp.js</a>이다.</p><p>사용하는 방법은 정말 간단하다. 자동화가 필요한 부분을 역할에 맞게 나눠서 “파이프”를 연결하고, “시리즈”로 묶어주면 된다. 전체적인 플로우는 이렇게 설명할 수 있지만, 중간에 막히면 공식 문서를 보거나 검색하면 충분히 나온다.</p><h3 id="자동화-분배하기"><a href="#자동화-분배하기" class="headerlink" title="자동화 분배하기"></a>자동화 분배하기</h3><p>pug, scss, 이미지 파일, 자바스크립트 파일을 다뤘다. 일반적으로 Gulp 없이는 하나하나 코드를 줄이던지, 이미지를 압축하던지, 렌더링 템플릿을 변환하던지 따로 작업해야 한다. 각각의 작업에 필요한 일련의 과정을 <code>src</code>, <code>pipe</code>, <code>dest</code>를 이용하여 묶는다.</p><h3 id="작업-만들기"><a href="#작업-만들기" class="headerlink" title="작업 만들기"></a>작업 만들기</h3><h4 id="src-pipe-dest"><a href="#src-pipe-dest" class="headerlink" title="src().pipe().dest()"></a>src().pipe().dest()</h4><p>기본적인 로직은 다음과 같다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> operation = <span class="function">() =&gt;</span> gulp.src(파일의 위치)</span><br><span class="line">                            .pipe(작업 수행)</span><br><span class="line">                            .dest(작업 수행 후 파일의 위치)</span><br></pre></td></tr></table></figure><p>pug면 pug에 맞게, js면 js에 맞게 각각을 이러한 패턴으로 디자인할 수 있다. 직접 구현할 작업은 없을 정도로 gulp에 대한 플러그인이 잘 되어있다.</p><h4 id="series"><a href="#series" class="headerlink" title="series"></a>series</h4><p>각각의 작업은 다음과 같이 시리즈로 묶는다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> prepare = gulp.series([operation1, operation2]);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> dev = gulp.series([prepare, operation3]);</span><br></pre></td></tr></table></figure><p>export시 변수 이름 그대로 <code>gulp 변수이름</code>으로 시리즈의 작업을 수행할 수 있다. 위처럼 선언해놓은 시리즈를 시리즈 안에 삽입하는 것도 가능하다. 작업을 동시에 처리하고 싶다면 <code>series</code> 대신 <code>parallel</code>을 사용하면 된다.</p><h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>작업 중 파일이 변경되었을 때의 작업도 설정할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> watch = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    gulp.watch(<span class="string">&quot;인식할 파일(와일드카드 가능)&quot;</span>, 수행할 작업)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 <code>watch</code> 변수도 똑같이 필요한 부분의 시리즈에 같이 묶어주면 된다.</p><h3 id="gulp-plugins"><a href="#gulp-plugins" class="headerlink" title="gulp plugins"></a>gulp plugins</h3><p>거의 자동화할 모든 작업들은 플러그인이 만들어져 있다. npm, yarn으로 플러그인 설치 시 <code>--dev</code> 또는 <code>-D</code>를 옵션에 추가하여 개발환경 의존성에 추가한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add 플러그인이름 -D <span class="comment"># npm i 플러그인이름 -D</span></span><br></pre></td></tr></table></figure><p>이번에 사용한 플러그인은 다음과 같다.</p><ul><li>gulp-pug<ul><li>pug 파일을 html 파일로 변환, 인덴트 압축</li></ul></li><li>del<ul><li>파일, 디렉토리 삭제</li></ul></li><li>gulp-webserver<ul><li>간단한 테스트용 개발 서버 열기</li></ul></li><li>gulp-image<ul><li>이미지 압축 -&gt; 압축에는 시간이 다소 소요되기 때문에 watch 작업에 포함할 때는 신중하게 결정해야 한다.</li></ul></li><li>gulp-sass<ul><li>scss 파일을 css 파일로 변환</li></ul></li><li>gulp-autoprefixer<ul><li>css 파일을 브라우저 호환 옵션에 맞게 확장</li></ul></li><li>gulp-csso<ul><li>css 파일 코드 압축</li></ul></li><li>gulp-bro (babelify, uglifyify)<ul><li>간편하게 Babel로 호환성 변환, 코드 압축</li></ul></li><li>gulp-gh-pages<ul><li>Github Page 배포</li></ul></li></ul><blockquote><p>나는 <a href="nomadcoders.co">노마드코더</a>에서 강의를 보았고, 단순 클론 코딩이 아닌 내 워크플로우에 적용할 수 있는 메커니즘을 배운 것 같다. 어느 정도 규모가 있는 프로젝트에 적용하면 잘 써먹을 수 있겠다.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Gulp-js&quot;&gt;&lt;a href=&quot;#Gulp-js&quot; class=&quot;headerlink&quot; title=&quot;Gulp.js&quot;&gt;&lt;/a&gt;Gulp.js&lt;/h2&gt;&lt;p&gt;Node.js 프로젝트를 하면서 빌드, 개발 테스트에 귀찮을 때가 많다. 이런 귀찮음을 위</summary>
      
    
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/categories/nodejs/"/>
    
    <category term="gulp" scheme="https://zinirun.github.io/categories/nodejs/gulp/"/>
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/tags/nodejs/"/>
    
    <category term="gulpjs" scheme="https://zinirun.github.io/tags/gulpjs/"/>
    
  </entry>
  
  <entry>
    <title>Typescript - tsconfig 속성</title>
    <link href="https://zinirun.github.io/2021/01/16/typescript-study-2-tsconfig/"/>
    <id>https://zinirun.github.io/2021/01/16/typescript-study-2-tsconfig/</id>
    <published>2021-01-16T11:19:59.000Z</published>
    <updated>2021-01-16T11:21:06.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tsc-명령어"><a href="#tsc-명령어" class="headerlink" title="tsc 명령어"></a>tsc 명령어</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc app.ts</span><br></pre></td></tr></table></figure><h3 id="타입스크립트-설정-파일-인식-기준"><a href="#타입스크립트-설정-파일-인식-기준" class="headerlink" title="타입스크립트 설정 파일 인식 기준"></a>타입스크립트 설정 파일 인식 기준</h3><p>tsc 명령어를 대상 파일을 지정하지 않고 실행하면 현재 폴더에 있는 타입스크립트 설정 파일을 기준으로 변환작업을 수행함. (현재 폴더에 tsconfig 파일이 없으면 상위 폴더로 검색해나감)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tsc -p 상대경로</span><br><span class="line">tsc -p .&#x2F;src</span><br></pre></td></tr></table></figure><h2 id="tsconfig-속성"><a href="#tsconfig-속성" class="headerlink" title="tsconfig 속성"></a>tsconfig 속성</h2><h3 id="files"><a href="#files" class="headerlink" title="files"></a>files</h3><p>변환 명령어를 입력할 때마다 대상 파일의 경로를 지정하지 않고 미리 정의할 수 있음</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;files&quot;: [&quot;app.ts&quot;, &quot;.&#x2F;utils&#x2F;math.ts&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><p><code>files</code>와 같이 파일을 개별로 지정하지 않고 변환할 폴더를 지정할 수 있음</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;include&quot;: [&quot;src&#x2F;**&#x2F;*&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>와일드카드 패턴<br>*: 디렉터리 모든 파일<br>?: 디렉터리 내 파일 이름 중 한글자라도 맞으면<br>**: 하위 디렉터리 재귀적으로 접근</p></blockquote><h3 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h3><p>include와 반대, 변환하지 않을 폴더 경로</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;exclude&quot;: [&quot;node_modules&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>그러나 node_modules 폴더의 @types 폴더는 컴파일에 포함함, 변경은 compilerOptions - typeRoots에서</li></ul><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p>특정 tsconfig를 불러와서 추가할 수 있는 속성</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: &quot;.&#x2F;config&#x2F;base&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="target"><a href="#target" class="headerlink" title="target"></a>target</h3><p>자바스크립트로 변환되는 버전. es3, es5, es6, 가장 최신버전은 esnext</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;target&quot;: &quot;esnext&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h3><p>타입스크립트를 자바스크립트로 컴파일할 때 포함할 라이브러리의 목록. 예를 들어 <code>async</code> 코드를 컴파일 할 때 <code>Promise</code> 객체가 필요하므로 아래와 같은 설정을 해야함.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;lib&quot;: [&quot;es2015&quot;, &quot;dom&quot;, &quot;dom.iterable&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allowJs"><a href="#allowJs" class="headerlink" title="allowJs"></a>allowJs</h3><p>컴파일할 때 자바스크립트 파일도 포함할지 설정. (점진적으로 타입스크립트를 적용할 때 사용하면 좋음)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;tsc-명령어&quot;&gt;&lt;a href=&quot;#tsc-명령어&quot; class=&quot;headerlink&quot; title=&quot;tsc 명령어&quot;&gt;&lt;/a&gt;tsc 명령어&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=</summary>
      
    
    
    
    <category term="typescript" scheme="https://zinirun.github.io/categories/typescript/"/>
    
    
    <category term="typescript" scheme="https://zinirun.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>이제와서 쓰는 2020년 회고</title>
    <link href="https://zinirun.github.io/2021/01/14/remind-2020/"/>
    <id>https://zinirun.github.io/2021/01/14/remind-2020/</id>
    <published>2021-01-14T11:19:21.000Z</published>
    <updated>2021-01-14T12:44:38.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="졸업을-준비할-시간"><a href="#졸업을-준비할-시간" class="headerlink" title="졸업을 준비할 시간"></a>졸업을 준비할 시간</h1><p>이제 학부생 4학년이 된다. 졸업이 다가오니 나중엔 내가 뭘 하고 있을지, 어떤 개발자로 살고 있을지, 많은 생각이 든다. 무언갈 배우고 그것으로 무언갈 만드는 것을 너무 좋아한 나머지 2020년은 정말 바쁘게 살았다. 내가 하고 싶은 프로젝트, 1차 졸업작품, 외주 프로젝트를 하면서 옛날보다 코드가 많이 성숙해진 것을 느낀다. 사실 이 2020년 회고는 깔끔하게 2020년 12월 31일에 쓰고 싶었는데 그때는 학교에서 외주를 받아서 프로젝트를 하고 있었고, 지금도 새로운 외주를 받아서 진행중인데 마침 시간이 남아서 쓸 수 있었다.</p><h2 id="2020년의-목표였던-것들"><a href="#2020년의-목표였던-것들" class="headerlink" title="2020년의 목표였던 것들"></a>2020년의 목표였던 것들</h2><p>욕심이 앞선 탓인지 2020년은 목표가 많았다.</p><ol><li>Node.js를 완전히 내 것으로 만들기</li><li>Docker Compose, Shell Script로 빌드 자동화</li><li>AWS</li><li>GraphQL</li><li>React</li><li>SQLD 자격증</li><li>Problem Solving (Python)</li><li>Go</li><li>Redis</li><li>Kubernetes</li><li>Github 블로그</li><li>학과 공부 4.0 이상 (1학년때 싼 똥을 치워야 한다)</li><li>토익</li></ol><p>목표가 과했지만 Go 언어, 쿠버네티스를 제외하고 모두 이룰 수 있었다. AWS는 공부하지 못했고, 학교에서 서버 스터디때 제공해준 NHN Toast Cloud를 사용해서 리눅스 기반 클라우드 환경을 공부할 수 있었다. (이뤘다는 말이 마스터했다는 말은 아니다, 내가 가늠한 목표만큼은 모두 움직였다) 처음에 이 목표를 어떻게 도전할까 고민하다가 생각한 것은, 바쁜 프로젝트 와중에 짬내서 따로 공부하기보단 진행하는 프로젝트에 내가 배우고 싶은 기술을 녹이는 것이었다.</p><p>노드와 GraphQL을 공부하다가 GraphQL에 빠져서 <a href="https://github.com/zinirun/graphql-crud-demo">GraphQL CRUD Demo</a> 시뮬레이터를 만들기도 하고, 학교에서 풀스택으로 외주받은 서비스를 개발하고 배포할때 도커 컴포즈와 쉘 스크립트로 빌드 자동화를 성공하기도 하고, MySQL의 속도가 답답해서 Redis 캐싱을 노드 서버에 도입했다. 토익은 개발의 범주는 벗어나지만 중간중간 머리식힐 겸 했고, 내 나름대로는 만족스러운 결과를 얻어서 졸업하려 한다.</p><p>그리고 정한 목표대로 배울 수 있는 것도 아니었는게, 2020년 초쯤 외주를 받아서 진행하다가 웹 앱을 만들어야 할 일이 있었는데, 그러다가 자연스럽게 React Native와 Expo를 경험하게 됐다.</p><h2 id="2020년을-함께한-프로젝트들"><a href="#2020년을-함께한-프로젝트들" class="headerlink" title="2020년을 함께한 프로젝트들"></a>2020년을 함께한 프로젝트들</h2><p>모든 프로젝트를 나열하기에는 너무 많고, 기억에 남는 프로젝트만 오래된 순으로 적어보려 한다.</p><h4 id="1-곰곰해온라인"><a href="#1-곰곰해온라인" class="headerlink" title="1. 곰곰해온라인"></a>1. 곰곰해온라인</h4><ul><li><code>Node.js</code> <code>Socket.io</code><blockquote><p><a href="https://github.com/zinirun/bearchain">Github</a></p></blockquote></li></ul><p><img src="/images/2021-01-14-20-49-27.png"><br><img src="/images/2021-01-14-20-50-01.png"></p><p>노드와 Socket.io를 사용한 끝말잇기 게임이다. 이 게임을 만들면서 노드에 많은 흥미를 느꼈고 본격적으로 노드를 벡엔드 언어로 깊이있게 공부하는 계기가 되었다. 사실 친구들끼리 PC방에 가던 내기를 할 때 쓰면 좋겠다는 아이디어가 종이 몇 장의 드래프트로, 그 드래프트가 본격적인 프로젝트가 되었다.</p><h4 id="2-피피"><a href="#2-피피" class="headerlink" title="2. 피피"></a>2. 피피</h4><ul><li><code>Python</code> <code>Flask</code> <code>OpenCV</code> <code>scikitlearn</code> <code>uwsgi</code> <code>Docker</code><blockquote><p><a href="https://github.com/zinirun/peepee-app">Github</a></p></blockquote></li></ul><p><img src="/images/2021-01-14-20-54-33.png"></p><p>서버 스터디를 하다가 제작한 일주일의 프로젝트, 피피였다. 변기 사진을 찍어 업로드하면 소변의 색으로 건강을 (어느정도) 판단해준다. 이때 OpenCV, Flask에 대한 경험이 전무해서 어려웠는데 어려운 사람 둘이서 머리를 쥐어짜서 만들어서 그런지 완성도있는 프로젝트를 만들 수 있었다.</p><h4 id="3-우리의-편지"><a href="#3-우리의-편지" class="headerlink" title="3. 우리의 편지"></a>3. 우리의 편지</h4><ul><li><code>Node.js</code> <code>MySQL</code> <code>EJS</code></li></ul><blockquote><p><a href="https://github.com/zinirun/our-letter">Github</a></p></blockquote><p><img src="https://github.com/zinirun/our-letter/raw/master/images/ourletter-1.gif"><br><img src="https://github.com/zinirun/our-letter/raw/master/images/ourletter-2.gif"></p><p>친구에게 의미있는 편지를 쓰고싶을 때가 있었는데, 같은 개발자인지라 카카오톡에서 유행하는 서비스처럼 서로를 알아야 편지를 읽을 수 있는 플랫폼을 만들어보면 어떨까해서 만든 프로젝트이다. (하지만 카페에서 만들다가 들켜서 계획은 무산되었고 울며 겨자먹기로 프로젝트를 끝냈다)</p><h4 id="4-BlueCheck"><a href="#4-BlueCheck" class="headerlink" title="4. BlueCheck"></a>4. BlueCheck</h4><ul><li><code>Node.js</code> <code>ToastCloud</code> <code>MySQL</code> <code>Docker</code> <code>Firebase</code> <code>React Native</code> <code>EJS</code></li></ul><blockquote><p><a href="https://play.google.com/store/apps/details?id=com.denebsoft.newbluecheck">Playstore</a></p></blockquote><p><img src="/images/2021-01-14-21-05-05.png"><br><img src="/images/2021-01-14-21-05-22.png"></p><p>노드를 사용한 첫 외주였다. 2명이서 만드는데 한 달이 안 걸린 것 같다. 실제 사용하는 것은 아니었고, 타대학 건축학과 학생들이 교수님과 함께 부탁한 웹 앱이다. 시연을 목적으로 만든 앱이었지만 기왕 만드는김에 제대로 만들어서 플레이스토어 배포도 연습할겸 사전 체험판으로 배포했다. 새벽까지 푸시알림 서비스를 구현하느라 진빠진 기억이 남는다. 프로젝트를 끝내고 FCM, Expo를 이용한 웹 앱에 도사가 된 것 같다.</p><h4 id="5-LMS-다운로더"><a href="#5-LMS-다운로더" class="headerlink" title="5. LMS 다운로더"></a>5. LMS 다운로더</h4><ul><li><code>Chrome-Extension</code> <code>Javascript</code><blockquote><p><a href="https://github.com/zinirun/LMSDownloader">Github</a></p></blockquote></li></ul><p><img src="/images/2021-01-14-21-13-07.png"><br><img src="/images/2021-01-14-21-13-22.png"><br><img src="/images/2021-01-14-21-16-06.png"></p><p>단국대학교 학생들을 위해 만든 이러닝 동영상 다운로더이다. 코로나 때문에 모든 강의는 온라인으로 진행되었는데, 이러닝 시스템이 참 뭐같은 탓에 복습하려고 하면 강의가 닫혀있고, 다 보지 않으면 뒤의 내용을 볼 수도 없어서 뭔가 크롬 확장 프로그램으로 만들 수 있겠다 싶어서 만들었는데, 생각보다 반응이 너무 뜨거웠다. 덕분에 학교에서 알게모르게 유명해지고 감사 쪽지를 과분하게 많이 받았다.</p><h4 id="6-홈즈"><a href="#6-홈즈" class="headerlink" title="6. 홈즈"></a>6. 홈즈</h4><ul><li><code>Node.js</code> <code>ToastCloud</code> <code>Redis</code> <code>MySQL</code> <code>Docker</code> <code>Firebase</code> <code>React Native</code> <code>EJS</code></li></ul><blockquote><p><a href="https://play.google.com/store/apps/details?id=com.nemobros.homes">Playstore</a></p></blockquote><p><img src="/images/2021-01-14-21-20-44.png"></p><p>첫 졸업작품이다. 우리 학교는 4학년 1학기, 4학년 2학기에 나누어 2개의 졸업작품(캡스톤디자인 프로젝트)을 진행하는데, 4학년 2학기때의 졸작을 땡겨서 했다. 4명이서 팀을 꾸렸고, 기간은 3달 정도였지만 1달이 채 되지않아 프로젝트를 끝냈다. 건물주, 관리인, 세입자 간에 발생하는 사회 문제를 서비스로 해결할 수 있을 것 같았다. 갈아 넣었다는 말은 이 프로젝트에 어울릴 듯 하다. 리더로서 “협업”, “효율적인 프로세스”이라는 텍스트에 대해 많은 생각을 했었다.</p><h4 id="7-단국대학교-서버관리시스템"><a href="#7-단국대학교-서버관리시스템" class="headerlink" title="7. 단국대학교 서버관리시스템"></a>7. 단국대학교 서버관리시스템</h4><ul><li><code>Node.js</code> <code>GraphQL</code> <code>SSH2</code> <code>React</code> <code>Apollo</code> <code>nginx</code> <code>Redis</code> <code>MySQL</code> <code>Docker-compose</code></li></ul><blockquote><p><a href="https://www.notion.so/45de2c8afbda4b25bc9f888924c15b7e">Notion</a></p></blockquote><p><img src="/images/2021-01-14-21-31-32.png"></p><p>단국대학교에서 수주한 프로젝트인데, 서버 스터디에서 연이 닿은 교수님이 마음 맞는 친구 2명을 알아서 구해서 해보면 어떻겠냐고 했고 그렇게 “팀 하모니카”라는 이름을 정하고 두번째 팀 리더를 수행하게 되었다. 새로운 기술들을 많이 접할 수 있었고, 단기간에 많이 발전했다. 4달 정도로 잡았던 프로젝트 기간은 1달이 안되어서 마무리되었다. 원래는 사용자들이 예약하고 반납하는 것을 자동화하는 시스템이었는데, 욕심이 나아가서 실제 서버에 웹 콘솔에서 SSH2를 통해 원격 작업을 요청할 수 있고, 그럴듯한 서버 모니터링 콘솔 역할을 수행할 수 있도록 구현하였다.</p><p>이렇게 2020년이 바쁘게 지나갔다. 지인들은 숨쉴 틈은 있냐고 하는데 숨은 잘 쉬었고, 지인들과 의미있는 시간도 많이 보낸 한 해였다.</p><h2 id="2021년은"><a href="#2021년은" class="headerlink" title="2021년은"></a>2021년은</h2><p>지금도 여러 대학에서 사용하는 학점교류시스템을 외주로 받아서 구축하고 있다. 리더의 진도가 빠른 편인데 잘 따라와주는 팀원에게 고맙다. “다 하고 맘편하게 놀자”라는 말을 하루에 한번씩 한다. 사실 코로나때문에 놀러갈 곳도 없어서 작업실에서 영화보면서 야식이나 먹을 것 같다.</p><h4 id="2021년의-목표"><a href="#2021년의-목표" class="headerlink" title="2021년의 목표"></a>2021년의 목표</h4><p>2021년의 목표는 2020년보다는 적지만 좀 더 고도화된 공부를 할까 한다.</p><ol><li>Typescript</li><li>Go</li><li>Problem Solving</li><li>AWS</li><li>Kubernetes</li></ol><p>타입스크립트에 한번 빠지면 자바스크립트로 못 돌아간다는 말에 한번 발 담가보고 앞으로의 프로젝트에는 Typescript를 적용해보고 싶고, AWS와 쿠버네티스, Go는 밀린 과제이지만 제대로 경험해보고 싶다. 후회없는 2020년을 살았으니 열심히 달려서 대학 4년을 후회없이 마무리해야겠다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;졸업을-준비할-시간&quot;&gt;&lt;a href=&quot;#졸업을-준비할-시간&quot; class=&quot;headerlink&quot; title=&quot;졸업을 준비할 시간&quot;&gt;&lt;/a&gt;졸업을 준비할 시간&lt;/h1&gt;&lt;p&gt;이제 학부생 4학년이 된다. 졸업이 다가오니 나중엔 내가 뭘 하고 있</summary>
      
    
    
    
    <category term="Etc" scheme="https://zinirun.github.io/categories/Etc/"/>
    
    
    <category term="2020" scheme="https://zinirun.github.io/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>Redux 도입이 필요해진 이유</title>
    <link href="https://zinirun.github.io/2020/12/03/redux-start/"/>
    <id>https://zinirun.github.io/2020/12/03/redux-start/</id>
    <published>2020-12-03T11:18:21.000Z</published>
    <updated>2020-12-03T11:49:30.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redux-도입이-필요해진-이유"><a href="#Redux-도입이-필요해진-이유" class="headerlink" title="Redux 도입이 필요해진 이유"></a>Redux 도입이 필요해진 이유</h2><p>학교에서 준 외주 프로젝트를 하고 있는데, 프론트엔드로 리액트를 사용했다. 처음엔 GraphQL 서버로 필요한 값을 요청하고, 받고, 그 결과를 적당한 컴포넌트에 넘겨주고, 컴포넌트는 또 다른 컴포넌트에 넘겨주는 방식으로 만들고 있었다. 부모 컴포넌트에서 자식 컴포넌트로 값이던 함수던 넘기는 것은 어렵지 않았다. 하지만 자식 컴포넌트에서 부모 컴포넌트로 뭔가를 보낼 때 문제가 생기고, Context API를 사용하게 된다. 지금 프로젝트는 꽤 많은 상태를 오직 GraphQL 서버를 통해 받아서 가공해준다. 관리할 상태가 더 많아지니 스트레스는 더 늘어갔다. Redux를 도입할 필요성을 느꼈다.</p><p><img src="/images/2020-12-03-20-31-32.png" alt="redux-store"></p><p>사실 규모가 크거나 로직이 복잡한 프로젝트가 아니면 오직 GraphQL에서 상태를 관리할 수 있고, 아니면 Context API를 통해 충분히 해결할 수 있다. 하지만 한계가 있다. 그 때 리덕스를 도입하는 순간 상태 관리가 정말 쉬워진단다. 노가다로 컴포넌트끼리 상태 관리를 한번 해봤으니 공부해서 새로운 기술을 넣어보는 것도 충분한 가치가 있다고 생각한다..</p><h2 id="리덕스의-3가지-규칙"><a href="#리덕스의-3가지-규칙" class="headerlink" title="리덕스의 3가지 규칙"></a>리덕스의 3가지 규칙</h2><p>리덕스를 사용하면서 꼭 지켜줘야 할 규칙이 3가지 있다.</p><ol><li>하나의 애플리케이션 안에는 하나의 스토어만 있다.</li><li>상태는 읽기 전용이다.</li><li>변화를 일으키는 함수, 리듀서는 순수한 함수여야 한다.</li></ol><p>3번에서 “순수한 함수”라는 말은 동일한 인풋 -&gt; 동일한 아웃풋이어야 하고 네트워크 요청을 보내는 등 불순한(?) 작업을 하면 안된다는 뜻이다. 자세한 설명은 <a href="https://react.vlpt.us/redux/02-rules.html">Velopert Gitbooks</a>에 잘 정리되어 있다.</p><h2 id="Action-Reducer-Store"><a href="#Action-Reducer-Store" class="headerlink" title="Action, Reducer, Store"></a>Action, Reducer, Store</h2><p><img src="/images/2020-12-03-20-32-48.png"></p><p>리덕스에는 Action, Reducer, Store라는 키워드가 나온다.</p><h3 id="Action-액션"><a href="#Action-액션" class="headerlink" title="Action (액션)"></a>Action (액션)</h3><p>상태에 어떠한 변화가 필요할 때 액션을 발생시킨다. <code>type</code> 필드는 필수이고, 나머지는 개발자 마음이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">&quot;INCREASE&quot;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">      diff: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Action-Creator-액션-생성함수"><a href="#Action-Creator-액션-생성함수" class="headerlink" title="Action Creator (액션 생성함수)"></a>Action Creator (액션 생성함수)</h3><p>말 그대로 액션을 만드는 함수이다. 파라미터를 받아서 Action 객체 형태로 반환한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> changeText = <span class="function"><span class="params">text</span> =&gt;</span> (&#123;</span><br><span class="line">    type: <span class="string">&#x27;CHANGE_TEXT&#x27;</span>,</span><br><span class="line">    text</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Reducer-리듀서"><a href="#Reducer-리듀서" class="headerlink" title="Reducer (리듀서)"></a>Reducer (리듀서)</h2><p>리듀서는 변화를 일으키는 함수이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">state = initialState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> INCREASE:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        number: state.number + <span class="number">1</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> DECREASE:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        number: state.number - <span class="number">1</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>여기서 왜 액션 생성함수는 <code>export const</code>로, 리듀서는 <code>export default</code>로 내보냈는지 의아할 수 있다. Redux에서 자주 쓰이는 Duck 패턴이고, 한 파일에 리듀서, 액션, 액션 생성함수를 저렇게 모두 넣어넣고 한 파일에서 가져오기가 편하고 직관적이다.</p></blockquote><h2 id="Store-스토어"><a href="#Store-스토어" class="headerlink" title="Store (스토어)"></a>Store (스토어)</h2><p>리덕스는 한 애플리케이션 당 한 스토어를 만든다. (2개 이상이 안되는 건 아니지만 절대 권장하지 않는다) 스토어 안에는 애플리케이션의 상태와, 리듀서, 내장 메소드들이 들어있다.</p><h2 id="Dispatch-디스패치"><a href="#Dispatch-디스패치" class="headerlink" title="Dispatch (디스패치)"></a>Dispatch (디스패치)</h2><p>디스패치는 Store 내장 함수 중 하나이다. 액션을 발생시킨다. 따라서 dispatch의 파라미터로는 액션이 들어간다. <code>dispatch(action)</code>으로 정의된 <code>action</code>을 리듀서 함수를 통해 실행한다.</p><h2 id="Subscribe-구독"><a href="#Subscribe-구독" class="headerlink" title="Subscribe (구독)"></a>Subscribe (구독)</h2><p>구독도 Store 내장 함수 중 하나이다. 디스패치가 발생할 때마다 호출된다. <code>subscribe</code>에 특정 함수를 파라미터로 넣어주면 된다. <code>console.log(store.getState())</code> 등 디스패치를 통해 상태가 변경될 때마다 스토어의 상태를 가져오는 등의 작업을 할 수 있는데, 나중에 Hook을 사용하여 스토어에 알아서 구독시켜주므로 직접 사용할 일은 거의 없다.</p><blockquote><p>지금 간단한 TodoList를 리덕스를 통해 만들어보고 있는데, 확실히 직관적이고 상태 관리가 편하긴 하다. 하지만 아직 리덕스 미들웨어를 사용하지 않아서 Context API의 dispatch와 크게 다른 점을 못 느꼈다. 더 해봐야 알 것 같다.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redux-도입이-필요해진-이유&quot;&gt;&lt;a href=&quot;#Redux-도입이-필요해진-이유&quot; class=&quot;headerlink&quot; title=&quot;Redux 도입이 필요해진 이유&quot;&gt;&lt;/a&gt;Redux 도입이 필요해진 이유&lt;/h2&gt;&lt;p&gt;학교에서 준 외주 </summary>
      
    
    
    
    <category term="redux" scheme="https://zinirun.github.io/categories/redux/"/>
    
    
    <category term="react" scheme="https://zinirun.github.io/tags/react/"/>
    
    <category term="redux" scheme="https://zinirun.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>Node.js - 바람직한 비밀번호 암호화 (crypto)</title>
    <link href="https://zinirun.github.io/2020/12/02/node-crypto-password/"/>
    <id>https://zinirun.github.io/2020/12/02/node-crypto-password/</id>
    <published>2020-12-02T06:26:19.000Z</published>
    <updated>2020-12-02T06:57:25.577Z</updated>
    
    <content type="html"><![CDATA[<p>비밀번호를 있는 그대로 데이터베이스에 저장하는 개발자는 테러리스트와 같다. 로컬 환경에서 테스트할 목적이라면 모르겠지만, 외부에 배포되는 순간 회원가입 로직이 있다면 무조건 암호화할 의무가 있다. 물론 데이터베이스가 안 뚫리는 것이 가장 이상적이지만, 생명보험을 들어놓는 것과 같다.</p><h3 id="단방향-암호화와-양방향-암호화"><a href="#단방향-암호화와-양방향-암호화" class="headerlink" title="단방향 암호화와 양방향 암호화"></a>단방향 암호화와 양방향 암호화</h3><p>간단하게 설명하자면 단방향은 암호화할 수는 있어도 복호화해서 원래의 비밀번호를 알 수 없고, 양방향은 복호화해서 원래의 비밀번호를 알 수 있다. 대부분의 사이트는 비밀번호를 찾을 때 원래의 비밀번호를 알려주는 것이 아닌 재설정한다. 그렇다. 굳이 복호화할 이유가 없다.</p><p>단방향 암호화는 Hash 알고리즘을 사용한다. 임의의 문자열을 고정된 길이의 다른 문자열로 변경하는 것이다. 비밀번호가 123, 123456으로 길이가 달라도 Hash 알고리즘에서 길이를 5로 설정했다면 비밀번호는 abfe1, bf3sj처럼 5글자로 변경된다.</p><h3 id="Crypto-vs-Bcrypt"><a href="#Crypto-vs-Bcrypt" class="headerlink" title="Crypto vs Bcrypt"></a>Crypto vs Bcrypt</h3><p>Crypto 관련 글을 검색하다가 Bcrypt라는 모듈도 있다는 것을 알게 되었다. 그러나 Bcrypt는 Blowfish 알고리즘을 사용하기 때문에 해싱에 엄청난 비용이 든다고 한다. 만약 해커가 브루트 포스같은 공격을 해대면 뚫리지는 않을지라도 서버에 엄청난 부하가 가해진다.</p><p>Crypto 모듈이 Node 기본 모듈로 들어간 이유가 다 있다고 생각하고 순수하게 Crypto만을 사용해서 바람직한 암호화를 하기로 했다.</p><h3 id="해서는-안될-암호화"><a href="#해서는-안될-암호화" class="headerlink" title="해서는 안될 암호화"></a>해서는 안될 암호화</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> base64crypto = <span class="function"><span class="params">password</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(crypto.createHash(<span class="string">&#x27;sha512&#x27;</span>).update(password).digest(<span class="string">&#x27;base64&#x27;</span>))</span><br><span class="line">base64crypto(<span class="string">&#x27;1234&#x27;</span>)</span><br><span class="line">base64crypto(<span class="string">&#x27;1234&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위에서 작성한 <code>base64crypto</code> 함수는 sha-512 알고리즘으로 해싱한 암호화된 문자열을 뱉어주지만 서로 다른 유저가 ‘1234’, ‘1234’ 비밀번호로 회원가입을 했다고 가정하면, 둘의 암호화된 비밀번호가 같아진다. 해커는 이를 통해 비밀번호를 유추할 수 있다. (이를 찾은 문자열의 목록을 레인보우 테이블이라고 한다)</p><h3 id="Salt-암호화"><a href="#Salt-암호화" class="headerlink" title="Salt 암호화"></a>Salt 암호화</h3><p>보안에 완벽이라고 단언할 암호화는 없지만 현재로서는 가장 안전하다고 여겨지는 Salting과 Key Stretching을 이용하여 강력한 암호화를 할 수 있다.</p><p>Salting은 말 그대로 Salt, 소금을 뿌리는 것이다. 기존의 문자열에 salt를 붙여 새로운 문자열을 반환한다.</p><p>Key Stretching은 기존 문자열의 다이제스트를 생성하고 생성된 다이제스트로 다시 다이제스트를 생성한다. 키 스트레칭을 999번한 비밀번호와 1000번한 비밀번호는 생김새가 완전히 다르다.</p><p>우선 암호화가 필요한 테이블에 salt 컬럼을 추가하자. 비밀번호와 별도로 같이 저장될 랜덤 문자열이고, 로그인 시 <code>password</code> 컬럼과 <code>salt</code> 컬럼을 통해서 유저가 입력한 암호를 다시 암호화하는 로직이다.</p><h4 id="회원가입에-적용하기"><a href="#회원가입에-적용하기" class="headerlink" title="회원가입에 적용하기"></a>회원가입에 적용하기</h4><p>꽤 괜찮다고 생각되는 함수를 작성해보았다.</p><h5 id="createSalt"><a href="#createSalt" class="headerlink" title="createSalt"></a>createSalt</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createSalt = <span class="function">() =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        crypto.randomBytes(<span class="number">64</span>, <span class="function">(<span class="params">err, buf</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">            resolve(buf.toString(<span class="string">&#x27;base64&#x27;</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>우선 Crypto 모듈의 randomBytes 메소드를 통해 Salt를 반환하는 함수를 작성한다.</p><h5 id="createHashedPassword"><a href="#createHashedPassword" class="headerlink" title="createHashedPassword"></a>createHashedPassword</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createHashedPassword = <span class="function">(<span class="params">plainPassword</span>) =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="keyword">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> salt = <span class="keyword">await</span> createSalt();</span><br><span class="line">        crypto.pbkdf2(plainPassword, salt, <span class="number">9999</span>, <span class="number">64</span>, <span class="string">&#x27;sha512&#x27;</span>, <span class="function">(<span class="params">err, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">            resolve(&#123; <span class="attr">password</span>: key.toString(<span class="string">&#x27;base64&#x27;</span>), salt &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>이제 암호화가 안된 비밀번호를 인자로 받아 위에서 작성한 <code>createSalt</code> 함수로 salt를 생성하고 sha-512로 해싱한 암호화된 비밀번호가 생성된다. 이 함수는 <code>password</code>와 <code>salt</code> 모두를 반환하고 데이터베이스에 둘 다 넣어주면 된다. 키 스트레칭은 9999로 해놓았는데 딱 맞아 떨어지는 숫자말고 적당히 큰 수를 넣어줘도 상관없다.</p><p>예를 들어,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; password, salt &#125; = <span class="keyword">await</span> createHashedPassword(req.body.user.password);</span><br></pre></td></tr></table></figure><p>이런식으로 암호화된 비밀번호와 salt를 생성해서 가져온 후,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> models.user</span><br><span class="line">            .create(&#123;</span><br><span class="line">                ...req.body.user,</span><br><span class="line">                password,</span><br><span class="line">                salt,</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><p>이렇게 DB에 넣어주면 된다.</p><p>회원가입 로직은 이렇게 구현하면 끝이다.</p><h5 id="makePasswordHashed"><a href="#makePasswordHashed" class="headerlink" title="makePasswordHashed"></a>makePasswordHashed</h5><p>이제 로그인 로직이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makePasswordHashed = <span class="function">(<span class="params">userId, plainPassword</span>) =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="keyword">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">        <span class="comment">// salt를 가져오는 부분은 각자의 DB에 따라 수정</span></span><br><span class="line">        <span class="keyword">const</span> salt = <span class="keyword">await</span> models.user</span><br><span class="line">            .findOne(&#123;</span><br><span class="line">                attributes: [<span class="string">&#x27;salt&#x27;</span>],</span><br><span class="line">                raw: <span class="literal">true</span>,</span><br><span class="line">                where: &#123;</span><br><span class="line">                    userId,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">result</span>) =&gt;</span> result.salt);</span><br><span class="line">        crypto.pbkdf2(plainPassword, salt, <span class="number">9999</span>, <span class="number">64</span>, <span class="string">&#x27;sha512&#x27;</span>, <span class="function">(<span class="params">err, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">            resolve(key.toString(<span class="string">&#x27;base64&#x27;</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>비밀번호와 유저 ID를 인자로 받아 패스워드를 암호화한다. 단방향 암호화 방식이기 때문에 유저가 보낸 Plain Password를 위에서 한 방식대로 그대로 암호화해서 비교하면 된다.</p><p>여기서 다른 것은 회원가입에서는 salt를 랜덤 문자열로 만들고, 로그인에서는 회원가입에서 만들어진 salt를 가져와서 해싱하는 것이다. 암호화 방식이 똑같기 때문에 키 스트레칭이나 해싱 알고리즘이 서로 다르면 안된다.</p><p>함수를 사용하는 예를 들면,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; userId, <span class="attr">password</span>: plainPassword &#125; = req.body.user;</span><br><span class="line"><span class="keyword">const</span> password = <span class="keyword">await</span> makePasswordHashed(userId, plainPassword);</span><br></pre></td></tr></table></figure><p>나는 이런식으로 사용한다. 그러면 <code>password</code>에는 비교할 암호화된 문자열이 만들어질 것이고, 각자 사용하는 데이터베이스에서 유저의 ID와 password를 비교해주면 된다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;비밀번호를 있는 그대로 데이터베이스에 저장하는 개발자는 테러리스트와 같다. 로컬 환경에서 테스트할 목적이라면 모르겠지만, 외부에 배포되는 순간 회원가입 로직이 있다면 무조건 암호화할 의무가 있다. 물론 데이터베이스가 안 뚫리는 것이 가장 이상적이</summary>
      
    
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/categories/nodejs/"/>
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/tags/nodejs/"/>
    
    <category term="crypto" scheme="https://zinirun.github.io/tags/crypto/"/>
    
  </entry>
  
  <entry>
    <title>Typescript를 시작하는 이유</title>
    <link href="https://zinirun.github.io/2020/11/23/typescript-study-1/"/>
    <id>https://zinirun.github.io/2020/11/23/typescript-study-1/</id>
    <published>2020-11-23T12:22:44.000Z</published>
    <updated>2020-11-23T12:38:45.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Typescript-공부를-시작하는-이유"><a href="#Typescript-공부를-시작하는-이유" class="headerlink" title="Typescript 공부를 시작하는 이유"></a>Typescript 공부를 시작하는 이유</h2><p>Javascript를 몇 년을 써오면서 큰 불편함은 느끼지 못했다. 그래서 Typescript는 Javascript의 가려운 부분을 긁어준다는 말을 들어도 굳이 해야하나 싶었다.</p><p>하지만 요즘 학교에서 발주한 대형 프로젝트(기술 스택은 크게 <code>Node.js</code>, <code>GraphQL</code>, <code>React</code>, <code>Apollo</code>를 사용한다)를 진행중에 타입스크립트 도입의 필요성을 느꼈다.  서버 사이드로나 클라이언트 사이드로나 자바스크립트를 사용하다 보니 모듈화된 함수가 인자로 어떤 타입을 받는지, 반환하는 값은 어떤 종류인지 찾으려고 파일들을 왔다갔다하다가, 결국 주석으로 input과 output의 값을 명시하는 작업을 하고 있다.</p><p>주석으로 명시하더라도 사람은 늘 실수를 하고, 특히나 GraphQL에서의 타입 준수는 정말 중요하기 때문에 항상 실행해보고 나서 에러를 발견하기도 한다.</p><p>그렇게 나는 타입스크립트 공부를 시작하기로 했다. <a href="https://typescript-kr.github.io/">Typescript Handbook KR</a>에 정말 잘 정리되어 있으니, 교과서로 쓰기에도 충분할 것 같다.</p><p>사실 배운 내용에 대해서 포스팅하려고 했는데, 핸드북(위 링크)에 정말 잘 나와있어서 이론을 적기 보다는 공부하다가 겪은 고난(?) 위주의 글을 적어볼 생각이다.</p><p>지금은 기본적인 자료형과, 함수 선언, 인터페이스, 타입을 1시간도 채안되서 공부했는데, 새로운 언어를 배우는 것이 아니라서 자바스크립트를 어느정도 다룰 줄 안다면 정말 빠르게 배울 수 있다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Typescript-공부를-시작하는-이유&quot;&gt;&lt;a href=&quot;#Typescript-공부를-시작하는-이유&quot; class=&quot;headerlink&quot; title=&quot;Typescript 공부를 시작하는 이유&quot;&gt;&lt;/a&gt;Typescript 공부를 시작하는 </summary>
      
    
    
    
    <category term="typescript" scheme="https://zinirun.github.io/categories/typescript/"/>
    
    
    <category term="typescript" scheme="https://zinirun.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>React Apollo Client에서 데이터가 섞이는 오류 해결(GraphQL)</title>
    <link href="https://zinirun.github.io/2020/11/10/react-apollo-graphql-data-mixed/"/>
    <id>https://zinirun.github.io/2020/11/10/react-apollo-graphql-data-mixed/</id>
    <published>2020-11-10T12:36:00.000Z</published>
    <updated>2020-11-10T12:44:17.181Z</updated>
    
    <content type="html"><![CDATA[<p>한 화면에서 다수의 컴포넌트가 모두 같은 GraphQL Query를 실행할 때 데이터가 섞이는 오류가 있었다. 처음에는 벡엔드 (<code>Node.js + GraphQL Server</code>)와 동기적으로 데이터를 주고 받을 수 없어서 그런 것 같았는데, 코드 상의 문제는 없었다.</p><p>구글링끝에 답을 찾았다. Apollo Client의 캐싱 오류였고, 클라이언트측 쿼리(gql)에 <code>__typename @skip(if: true)</code>를 붙여주면 된다.</p><p>어디에 붙이냐면, 예를 들어</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">query getRoutine($id: ID!) &#123;</span><br><span class="line">        getRoutine(id: $id) &#123;</span><br><span class="line">            day</span><br><span class="line">            dayName</span><br><span class="line">            tasks &#123;</span><br><span class="line">                id</span><br><span class="line">                name</span><br><span class="line">                time</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>나는 다음과 같은 쿼리를 동시에 요청할 때 데이터가 섞였는데,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">query getRoutine($id: ID!) &#123;</span><br><span class="line">        getRoutine(id: $id) &#123;</span><br><span class="line">            __typename @skip(<span class="keyword">if</span>: <span class="literal">true</span>)</span><br><span class="line">            day</span><br><span class="line">            dayName</span><br><span class="line">            tasks &#123;</span><br><span class="line">                id</span><br><span class="line">                __typename @skip(<span class="keyword">if</span>: <span class="literal">true</span>)</span><br><span class="line">                name</span><br><span class="line">                time</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>위를 참고하여 <code>id</code>를 조회한다면 id 밑에 넣던지, <code>id</code>를 조회하지 않는다면 그냥 제일 위에 넣으면 된다.</p><blockquote><p>출처 <a href="https://stackoverflow.com/questions/53272112/apollo-is-mixing-results-from-a-graphql-query-in-react">stackoverflow</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;한 화면에서 다수의 컴포넌트가 모두 같은 GraphQL Query를 실행할 때 데이터가 섞이는 오류가 있었다. 처음에는 벡엔드 (&lt;code&gt;Node.js + GraphQL Server&lt;/code&gt;)와 동기적으로 데이터를 주고 받을 수 없어서 그런</summary>
      
    
    
    
    <category term="ReactJS" scheme="https://zinirun.github.io/categories/ReactJS/"/>
    
    
    <category term="graphql" scheme="https://zinirun.github.io/tags/graphql/"/>
    
    <category term="react" scheme="https://zinirun.github.io/tags/react/"/>
    
    <category term="apollo" scheme="https://zinirun.github.io/tags/apollo/"/>
    
  </entry>
  
  <entry>
    <title>React CORS 이슈 해결 (XMLHttpRequest.handleError)</title>
    <link href="https://zinirun.github.io/2020/11/03/react-cors-proxy/"/>
    <id>https://zinirun.github.io/2020/11/03/react-cors-proxy/</id>
    <published>2020-11-03T08:19:12.000Z</published>
    <updated>2020-11-03T08:26:34.237Z</updated>
    
    <content type="html"><![CDATA[<p>현재 프론트엔드(React), 벡엔드(Node)를 분리하여 프로젝트를 진행중에 있다. 그래서 당연히 포트가 다르다. 나는 노드측에서 CORS 설정을 해두었기에 프론트엔드 단에서는 별 다른 설정이 필요없다고 생각했다.</p><p>그러나 노드의 응답을 리액트에서 받지 못하는 것 같았고, XMLHttpRequest 에러가 발생했다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">at createError (createError.js)</span><br><span class="line">at XMLHttpRequest.handleError (xhr.js)</span><br></pre></td></tr></table></figure><p>확인 후 알아낸 것은, React에서도 cors에 대한 설정이 필요하다는 것이다. 프록시 설정으로 간단하게 해결할 수 있다.</p><p>React의 <code>package.json</code>에</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;lazy-dolphin&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;private&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;proxy&quot;</span>: <span class="string">&quot;http://localhost:4000&quot;</span>, <span class="comment">// Proxy 추가</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br></pre></td></tr></table></figure><p><code>proxy</code>에 노드의 주소를 추가하면 된다. 프록시를 설정하면 REST 요청을 보낼 때 <code>http://localhost:4000/signup</code>이 아닌 <code>/signup</code>으로 요청해도 알아서 프록시 서버로 데이터를 주고 받으니까 편리하다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;현재 프론트엔드(React), 벡엔드(Node)를 분리하여 프로젝트를 진행중에 있다. 그래서 당연히 포트가 다르다. 나는 노드측에서 CORS 설정을 해두었기에 프론트엔드 단에서는 별 다른 설정이 필요없다고 생각했다.&lt;/p&gt;
&lt;p&gt;그러나 노드의 응</summary>
      
    
    
    
    <category term="ReactJS" scheme="https://zinirun.github.io/categories/ReactJS/"/>
    
    
    <category term="javascript" scheme="https://zinirun.github.io/tags/javascript/"/>
    
    <category term="react" scheme="https://zinirun.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>CORS에 대하여</title>
    <link href="https://zinirun.github.io/2020/10/28/node-cors/"/>
    <id>https://zinirun.github.io/2020/10/28/node-cors/</id>
    <published>2020-10-28T04:08:06.000Z</published>
    <updated>2020-10-28T04:27:38.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS(Cross Origin Resource Sharing)는 도메인/포트가 다른 서버의 자원을 요청하는 메커니즘이다. 일반적인 환경에서는 동일 출처 정책(same-origin policy)때문에 CORS 상황이 발생하면 브라우저에서 데이터 요청을 보안 목적으로 차단한다.</p><blockquote><p>동일 출처 정책(same-origin policy)은 어떤 출처에서 불러온 문서나 스크립트가 다른 출처에서 가져온 리소스와 상호작용하는 것을 제한하는 중요한 보안 방식입니다. 동일 출처 정책은 잠재적으로 해로울 수 있는 문서를 분리함으로써 공격받을 수 있는 경로를 줄여줍니다. - <a href="https://developer.mozilla.org/ko/docs/Web/Security/Same-origin_policy">MDN Web Docs</a></p></blockquote><h2 id="노드에서-해결하기"><a href="#노드에서-해결하기" class="headerlink" title="노드에서 해결하기"></a>노드에서 해결하기</h2><p>노드 서버 환경에서는 CORS 미들웨어를 사용하여 간단하게 CORS를 조정할 수 있다.</p><p>먼저 cors npm을 설치한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add cors <span class="comment"># npm install cors --save</span></span><br></pre></td></tr></table></figure><p>이제 express의 미들웨어로 cors를 등록하면 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(cors()); <span class="comment">// CORS Middleware 추가</span></span><br></pre></td></tr></table></figure><p>위와 같이 CORS 미들웨어를 적용하면 모든 Cross Domain 요청에 대해 허가하게 된다. 로컬 테스트 환경이라면 괜찮겠지만, 배포 환경에서는 보안적으로 취약해지게 된다.</p><p>그러면 CORS 요청에 대한 허가 도메인을 정해주고, 그 옵션으로 cors를 추가하면 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> corsOption = &#123;</span><br><span class="line">    origin: <span class="string">&#x27;https://zini.run&#x27;</span>, <span class="comment">// 허가 도메인</span></span><br><span class="line">    credentials: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(cors(corsOption));</span><br></pre></td></tr></table></figure><p>크로스 도메인에 대한 정보만 적절하게 조정한다면 CORS 보안 문제는 일어나지 않을 것이다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CORS&quot;&gt;&lt;a href=&quot;#CORS&quot; class=&quot;headerlink&quot; title=&quot;CORS&quot;&gt;&lt;/a&gt;CORS&lt;/h2&gt;&lt;p&gt;CORS(Cross Origin Resource Sharing)는 도메인/포트가 다른 서버의 자원을 요청하는 메</summary>
      
    
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/categories/nodejs/"/>
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/tags/nodejs/"/>
    
    <category term="cors" scheme="https://zinirun.github.io/tags/cors/"/>
    
  </entry>
  
  <entry>
    <title>Redis, Node.js에서 시작하기</title>
    <link href="https://zinirun.github.io/2020/10/28/node-redis-start/"/>
    <id>https://zinirun.github.io/2020/10/28/node-redis-start/</id>
    <published>2020-10-27T16:06:03.000Z</published>
    <updated>2020-10-27T16:25:44.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-시작하기"><a href="#Redis-시작하기" class="headerlink" title="Redis 시작하기"></a>Redis 시작하기</h2><p>노드에서 Redis 기반의 캐싱을 해보고 싶어서 기본적으로 노드 환경에서 Redis에 연결하고, 데이터를 써보고 읽는 것부터 해보기로 했다.</p><p>우선 Redis의 데이터 타입에는 Strings, Lists, Sets, Hashes가 있다. 각각 읽거나 쓰는 방법이 다르지만 정말 간단하다.</p><h2 id="Redis-환경-구축하기"><a href="#Redis-환경-구축하기" class="headerlink" title="Redis 환경 구축하기"></a>Redis 환경 구축하기</h2><p>Windows는 공식적으로 지원하지 않는다고 한다. Microsoft에서 관리하는 윈도우용 redis가 있지만 깔끔한 환경을 바로 세팅하기 위해서 Docker 기반의 Redis를 사용하기로 했다.</p><p>먼저 호스트 PC에서 Docker Terminal를 실행한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name redis-db -d -p 6379:6379 redis</span><br></pre></td></tr></table></figure><p>이제 redis 이미지를 pull하고 컨테이너로 실행한다. <code>docker ps</code>로 실행된 것을 확인해보자.</p><p><img src="/images/2020-10-28-01-14-22.png"></p><p>이제 컨테이너에 접속한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it redis-db /bin/bash</span><br></pre></td></tr></table></figure><p>redis 컨테이너로 접속했다. 이제 터미널에 <code>redis-cli</code>를 입력하면 redis를 사용할 수 있다.</p><h2 id="Node-js와-Redis-연동하기"><a href="#Node-js와-Redis-연동하기" class="headerlink" title="Node.js와 Redis 연동하기"></a>Node.js와 Redis 연동하기</h2><p>먼저 Redis npm을 먼저 설치한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add redis <span class="comment"># npm install redis</span></span><br></pre></td></tr></table></figure><p>이제 js 파일을 작성해보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> redis = <span class="built_in">require</span>(<span class="string">&quot;redis&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> client = redis.createClient();</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">&quot;error&quot;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">&quot;ready&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Redis is ready&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="connection-to-127-0-0-1-6379-failed-connect-ECONNREFUSED"><a href="#connection-to-127-0-0-1-6379-failed-connect-ECONNREFUSED" class="headerlink" title="connection to 127.0.0.1:6379 failed - connect ECONNREFUSED"></a><code>connection to 127.0.0.1:6379 failed - connect ECONNREFUSED</code></h3><p>사실 여기서 애를 많이 먹었다. 호스트의 Docker로 실행한 컨테이너의 IP로 접속을 못 하는 것 같았는데, 알고보니 Docker Machine의 IP로 접속해야 했다. 일반적인 접속 방법은 위와 같지만 호스트 환경의 도커에서 실습하는 경우 IP를 직접 설정해줘야 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> redisHost = <span class="string">&quot;192.168.99.100&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> client = redis.createClient(<span class="number">6379</span>, redisHost);</span><br></pre></td></tr></table></figure><p>이제 잘 접속된다.</p><h2 id="Redis에-값-쓰고-불러오기"><a href="#Redis에-값-쓰고-불러오기" class="headerlink" title="Redis에 값 쓰고 불러오기"></a>Redis에 값 쓰고 불러오기</h2><p><code>client</code>에 redis의 클라이언트를 정의해놨으므로 이제 <code>client</code>에서 redis 명령어를 그대로 사용할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fruit &#123;</span><br><span class="line">    lemon: <span class="number">5000</span>,</span><br><span class="line">    green: <span class="number">2000</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 Hash 값을 redis에 저장해보자. Redis에서 Hash를 저장하는 명령어인 <code>hmset</code>을 그대로 사용한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client.hmset(<span class="string">&quot;fruit&quot;</span>, &#123;</span><br><span class="line">  lemon: <span class="number">5000</span>,</span><br><span class="line">  green: <span class="number">2000</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이제 이 값을 가져와보자. Hash 데이터의 전체 값을 가져올 수 있는 <code>hgetall</code> 명령어를 사용하면 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client.hgetall(<span class="string">&quot;fruit&quot;</span>, <span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="/images/2020-10-28-01-23-37.png"></p><p>실행하면, 값이 잘 출력된다.</p><p>명령어마다 어떤 콜백이 나오는지 모르면 <a href="https://www.npmjs.com/package/redis">npmjs</a> 공식 문서가 잘 되어 있으니, 참조하면 된다.</p><p>(정말) 간단하게 Redis를 Node에서 다뤄봤는데, 이제 세션 스토어나 캐싱을 해볼 생각이다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis-시작하기&quot;&gt;&lt;a href=&quot;#Redis-시작하기&quot; class=&quot;headerlink&quot; title=&quot;Redis 시작하기&quot;&gt;&lt;/a&gt;Redis 시작하기&lt;/h2&gt;&lt;p&gt;노드에서 Redis 기반의 캐싱을 해보고 싶어서 기본적으로 노드 환경</summary>
      
    
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/categories/nodejs/"/>
    
    <category term="redis" scheme="https://zinirun.github.io/categories/nodejs/redis/"/>
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/tags/nodejs/"/>
    
    <category term="docker" scheme="https://zinirun.github.io/tags/docker/"/>
    
    <category term="redis" scheme="https://zinirun.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL 시뮬레이터, graphql-crud-demo 제작기</title>
    <link href="https://zinirun.github.io/2020/10/27/graphql-crud-demo/"/>
    <id>https://zinirun.github.io/2020/10/27/graphql-crud-demo/</id>
    <published>2020-10-27T07:52:22.000Z</published>
    <updated>2020-10-27T08:04:19.575Z</updated>
    
    <content type="html"><![CDATA[<p>시험 기간에 머리 식힐 겸(?) 만들어 본 간단한 GraphQL 시뮬레이터를 만들었다. GraphQL 자체가 간결해서 그런지 순 제작시간은 5시간정도 걸린 것 같다.</p><p>그럴듯한 Readme 마크다운도 만들었는데, 설명은 이것으로 대체한다. 세부적인 CRUD API 구축 방법은 <a href="https://zinirun.github.io/2020/10/27/graphql-crud-sample/">이전 포스팅 - GraphQL로 CRUD 만들기</a>에서 볼 수 있다.</p><blockquote><p><a href="https://gql-crud.herokuapp.com/">여기</a>에서 샘플을 볼 수 있다. 헤로쿠로 호스팅해서 초반 로딩 속도는 조금 걸린다.</p></blockquote><h1 id="graphql-crud-demo"><a href="#graphql-crud-demo" class="headerlink" title="graphql-crud-demo"></a>graphql-crud-demo</h1><p>GraphQL CRUD Operations in Node.js, Axios, VanillaJS</p><img src="https://github.com/zinirun/graphql-crud-demo/blob/main/img/readme.png?raw=true" alt="gql-crud-page-sample" /><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/zinirun/graphql-crud-demo</span><br><span class="line">$ <span class="built_in">cd</span> ./graphql-crud-demo</span><br><span class="line">$ npm install <span class="comment"># yarn install</span></span><br></pre></td></tr></table></figure><h2 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h2><h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutation addProduct($input: ProductInput) &#123;</span><br><span class="line">    addProduct(input: $input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; getProduct(id : ?) &#123; id price name description&#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutation updateProduct($id: ID!, $input: ProductInput!)&#123;</span><br><span class="line">    updateProduct(id: $id, <span class="attr">input</span>: $input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutation deleteProduct&#123;</span><br><span class="line">    deleteProduct(id: $&#123;id&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Also-supports"><a href="#Also-supports" class="headerlink" title="Also supports"></a>Also supports</h3><ul><li>Get all items</li><li>Debouncing Search (customized timer)</li><li>Set data-set default</li></ul><h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><ul><li>GraphQL Server<ul><li><code>/src/schema.js</code> - Build-Schema defined</li><li><code>/src/rootValue.js</code> - Mutations and queries implemented</li><li><code>/src/products.js</code> - Shared data accessed from gql</li><li><code>/src/defaultProducts.js</code> - Default data-set</li></ul></li><li>Express<ul><li><code>/app.js</code> - Express instance defined</li><li><code>/server.js</code> - Server started from <code>/app.js</code></li></ul></li><li>Client<ul><li><code>/static/mod.js</code> - DOM Initialized, all events added</li><li><code>/static/crud.js</code> - Events implemented</li><li><code>/static/graphiql.js</code> - Iframe for GraphiQL(GUI)</li></ul></li></ul><p>Hard-coded dataset <code>/src/defaultProducts.js</code> can be replaced by with Redis, etc…</p><blockquote><p>사실 만들고 아무 생각 없이 Netlify로 만들다가 왜 안되나 했는데 저번에 그렇게 삽질했던 “Netlify는 정적 호스팅을 위한 서비스”라는게 떠올라서 부랴부랴 헤로쿠로 배포했다. 리액트를 조금 더 배워 React + Apollo + GraphQL + Redis 서비스를 배포해 봐야겠다.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;시험 기간에 머리 식힐 겸(?) 만들어 본 간단한 GraphQL 시뮬레이터를 만들었다. GraphQL 자체가 간결해서 그런지 순 제작시간은 5시간정도 걸린 것 같다.&lt;/p&gt;
&lt;p&gt;그럴듯한 Readme 마크다운도 만들었는데, 설명은 이것으로 대체한</summary>
      
    
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/categories/nodejs/"/>
    
    <category term="graphql" scheme="https://zinirun.github.io/categories/nodejs/graphql/"/>
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/tags/nodejs/"/>
    
    <category term="graphql" scheme="https://zinirun.github.io/tags/graphql/"/>
    
  </entry>
  
  <entry>
    <title>Node.js - GraphQL로 CRUD 만들기</title>
    <link href="https://zinirun.github.io/2020/10/27/graphql-crud-sample/"/>
    <id>https://zinirun.github.io/2020/10/27/graphql-crud-sample/</id>
    <published>2020-10-27T07:16:15.000Z</published>
    <updated>2020-10-27T07:51:33.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="REST-API-VS-GraphQL"><a href="#REST-API-VS-GraphQL" class="headerlink" title="REST API VS GraphQL"></a>REST API VS GraphQL</h2><p>REST API로만 벡엔드 서버 API를 구현한 나로서는 굳이 GraphQL이란 것을 알아야할까 싶었다. 이 생각은 GraphQL로 간단한 프로젝트를 만들어 보며 완전히 바뀌게 되었다.</p><div class="video-container"><iframe src="https://www.youtube.com/embed/EkWI6Ru8lFQ" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>11분동안 정말 재밌게 설명해주신 유튜버가 있어 REST와 GraphQL에 대한 긴 설명은 이것으로 대체한다.</p><p>뭘 써야할 지 모르겠다면 GraphQL, Rest API 모두 만들어서 필요한 작업마다 다르게 써먹으면 된다. 일반적으로 파일 전송같은 경우 RESTful이 더 유리하다고 하고, CRUD 작업이 대부분이라면 GraphQL이 훨씬 편하다.</p><h2 id="Node-js에서-GraphQL-구축하기"><a href="#Node-js에서-GraphQL-구축하기" class="headerlink" title="Node.js에서 GraphQL 구축하기"></a>Node.js에서 GraphQL 구축하기</h2><p>우선 express에서 GraphQL을 사용하기 위해 관련 패키지를 설치한다. (물론 express 세팅은 끝난 가정하이다)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add graphql</span><br><span class="line">$ yarn add express-graphql</span><br></pre></td></tr></table></figure><p>간단하게 GraphQL은 스키마 + 리졸버로 구성된다. 스키마 안에 변수나 함수를 정의하고, 리졸버에서 함수를 구현하면 된다.</p><p>우선 스키마를 정의하자. 나는 모듈화를 위해 파일을 용도에 맞게 쪼개서 쓰기로 했다.</p><h3 id="스키마-만들기"><a href="#스키마-만들기" class="headerlink" title="스키마 만들기"></a>스키마 만들기</h3><p><code>schema.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; buildSchema &#125; = <span class="built_in">require</span>(<span class="string">&#x27;graphql&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = buildSchema(<span class="string">`</span></span><br><span class="line"><span class="string">    input ProductInput &#123;</span></span><br><span class="line"><span class="string">    name: String,</span></span><br><span class="line"><span class="string">    price: Int,</span></span><br><span class="line"><span class="string">    description: String</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    type Product &#123;</span></span><br><span class="line"><span class="string">        id: ID!,</span></span><br><span class="line"><span class="string">        name: String,</span></span><br><span class="line"><span class="string">        price: Int,</span></span><br><span class="line"><span class="string">        description: String</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    type Query &#123;</span></span><br><span class="line"><span class="string">        getProduct(id: ID!): Product</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    type Mutation &#123;</span></span><br><span class="line"><span class="string">        addProduct(input: ProductInput): Int</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure><p>먼저 <code>type Query</code>와 <code>type Mutation</code>을 보자. 일반적으로 GET 작업은 Query로, POST 작업은 Mutation으로 정의한다.</p><h4 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h4><p><code>getProduct</code>라는 함수는 <code>ID</code> 유형의 <code>id</code> 변수를 인자로 받고, <code>Product</code> 객체를 반환한다는 의미이다. (여기서 <code>ID</code>는 MySQL에서의 일반적인 PK로 생각하면 된다)</p><p>이제 반환할 <code>Product</code> 객체에 뭐가 들었는지 <code>type Product</code>로 정의해주면 된다. 나만의 자료형을 만든다고 생각하면 쉽다.</p><p>참고로 <code>!</code>가 붙은 변수는 무조건 해당 인자는 받아야 한다는 <code>required</code>의 의미와 비슷한 표시이다.</p><h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><p><code>addProduct</code>는 말그대로 POST 메소드로 상품을 등록하는 함수이다. 입력값이 <code>ProductInput</code>으로 되어 있는데, <code>Product</code> type을 만들 때와 비슷하게 클라이언트의 입력 값을 미리 정의해둔 것이다. (일반적으로 뒤에 <code>Input</code>을 붙인다고 한다)</p><h3 id="Resolver-만들기"><a href="#Resolver-만들기" class="headerlink" title="Resolver 만들기"></a>Resolver 만들기</h3><p>이제 <code>getProduct</code>와 <code>addProduct</code>의 함수를 구현하면 거의 끝이다.</p><p><code>rootValue.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> products = <span class="built_in">require</span>(<span class="string">&#x27;./products&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> defaultProducts = <span class="built_in">require</span>(<span class="string">&#x27;./defaultProducts&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    getProduct: <span class="function">(<span class="params">&#123; id &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> products.find(<span class="function">(<span class="params">product</span>) =&gt;</span> product.id === <span class="built_in">parseInt</span>(id));</span><br><span class="line">    &#125;,</span><br><span class="line">    addProduct: <span class="function">(<span class="params">&#123; input &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        input.id = products.length === <span class="number">0</span> ? <span class="number">1</span> : products[products.length - <span class="number">1</span>].id + <span class="number">1</span>;</span><br><span class="line">        products.push(input);</span><br><span class="line">        <span class="keyword">return</span> input.id;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>나는 <code>products</code>라는 데이터 배열을 모듈화하여 사용하였다. 스키마에서 선언한 인자를 그대로 받아 적절한 함수를 짜고, 미리 정해놓은 리턴 자료형대로 반환하면 된다.</p><h3 id="Express로-라우팅하기"><a href="#Express로-라우팅하기" class="headerlink" title="Express로 라우팅하기"></a>Express로 라우팅하기</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.app.use(</span><br><span class="line">            <span class="string">&#x27;/graphql&#x27;</span>,</span><br><span class="line">            graphqlHTTP(&#123;</span><br><span class="line">                schema,</span><br><span class="line">                rootValue,</span><br><span class="line">                graphiql: <span class="literal">true</span>, <span class="comment">// support GUI</span></span><br><span class="line">            &#125;),</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>이제 <code>/graphql</code>이라는 경로로 GraphQL API를 라우팅하면 모든 구축이 끝난다. 스키마는 <code>schema</code>로, 리졸버는 <code>rootValue</code>라는 값으로 받는다. (그렇기 때문에 난 파일 이름을 똑같이 만들었다) <code>graphiql</code>은 URL에서 <code>/graphql</code>로 접속했을 때 쿼리와 뮤테이션을 써볼 수 있는 GUI 환경을 제공한다. 당연히 보안을 위해 배포시에는 <code>graphiql</code>을 <code>false</code>로 세팅해야 한다.</p><h2 id="클라이언트에서-데이터-주고-받기"><a href="#클라이언트에서-데이터-주고-받기" class="headerlink" title="클라이언트에서 데이터 주고 받기"></a>클라이언트에서 데이터 주고 받기</h2><p>이제 쿼리와 뮤테이션을 각각 GET, POST 요청으로 데이터를 주고 받을 수 있다. <code>fetch</code>, <code>axios</code> 등 방법은 많은데 <code>fetch</code>는 브라우저 호환에 문제가 있다고 하여 <code>axios</code>를 사용하기로 했다.</p><h3 id="GET-요청"><a href="#GET-요청" class="headerlink" title="GET 요청"></a>GET 요청</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> apiUri = <span class="string">&#x27;http://localhost:3000/graphql&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProduct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    axios</span><br><span class="line">        .get(apiUri, &#123;</span><br><span class="line">            params: &#123;</span><br><span class="line">                query: <span class="string">`&#123;getProduct(id : <span class="subst">$&#123;pid.value&#125;</span>) &#123;id price name description&#125;&#125;`</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(result)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스키마에서 짜놓은 형식대로 쿼리를 GET으로 넘기면 된다. axios 자체적으로 promise를 지원하기 때문에 then, catch를 사용하면 에러 핸들링이 수월하다. 이제 <code>result</code>를 가지고 데이터를 가공하여 클라이언트에게 제공할 수 있다.</p><h3 id="POST-요청"><a href="#POST-요청" class="headerlink" title="POST 요청"></a>POST 요청</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postProduct</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    axios</span><br><span class="line">        .post(apiUri, &#123;</span><br><span class="line">            query: <span class="string">&#x27;mutation addProduct($input: ProductInput) &#123; addProduct(input: $input)&#125;&#x27;</span>,</span><br><span class="line">            variables: &#123;</span><br><span class="line">                input: &#123;</span><br><span class="line">                    price: <span class="built_in">parseInt</span>(<span class="built_in">this</span>.price.value),</span><br><span class="line">                    name: <span class="built_in">String</span>(<span class="built_in">this</span>.name.value),</span><br><span class="line">                    description: <span class="built_in">String</span>(<span class="built_in">this</span>.description.value),</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            operationName: <span class="literal">null</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(result);</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GET과 방식은 거의 똑같은데, POST 메소드이므로 <code>params</code>가 아닌 <code>query</code>를 넘긴다. <code>$</code>를 사용하여 변수를 <code>variables</code>로 빼서 사용할 수도 있고, 백틱을 사용해서 하드코딩해도 상관은 없다.</p><h2 id="매력적인-GraphQL"><a href="#매력적인-GraphQL" class="headerlink" title="매력적인 GraphQL"></a>매력적인 GraphQL</h2><p>사실 기존의 서버 API를 바꾸는 것은 많은 시간과 노력이 든다. 하지만 REST API와 GraphQL를 한번에 사용할 수도 있으므로 클라이언트(프론트엔드) 부분만 살짝 손대주면 나중을 생각할 때 훨씬 간결한 CRUD 환경을 구축할 수 있다. 현재도 폭발적인 인기를 받아 많은 발전이 이뤄지고 있다고 한다.</p><p>GraphQL의 CRUD 작업을 시뮬레이션할 수 있는 서비스 <code>graphql-crud-demo</code> 를 개발했는데, 다음 글에 포스팅해보겠다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;REST-API-VS-GraphQL&quot;&gt;&lt;a href=&quot;#REST-API-VS-GraphQL&quot; class=&quot;headerlink&quot; title=&quot;REST API VS GraphQL&quot;&gt;&lt;/a&gt;REST API VS GraphQL&lt;/h2&gt;&lt;p&gt;RE</summary>
      
    
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/categories/nodejs/"/>
    
    <category term="graphql" scheme="https://zinirun.github.io/categories/nodejs/graphql/"/>
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/tags/nodejs/"/>
    
    <category term="graphql" scheme="https://zinirun.github.io/tags/graphql/"/>
    
  </entry>
  
  <entry>
    <title>클러스터 인덱스 vs 넌클러스터 인덱스</title>
    <link href="https://zinirun.github.io/2020/10/23/database-index/"/>
    <id>https://zinirun.github.io/2020/10/23/database-index/</id>
    <published>2020-10-23T00:11:37.000Z</published>
    <updated>2020-10-23T01:17:39.511Z</updated>
    
    <content type="html"><![CDATA[<p>학과 공부와 시험을 준비하다가 클러스터 인덱스와 넌클러스터 인덱스를 정리해 본다.</p><h2 id="개념"><a href="#개념" class="headerlink" title="개념"></a>개념</h2><p>영어 사전을 생각해보자. 기본적으로 A~Z 알파벳 순으로 책 자체가 정렬되어 있다. 이건 <strong>클러스터 인덱스</strong>이다. 사전 마지막에는 “색인”이 있는데, 필요한 단어를 찾고, 거기에 적힌 페이지로 간다. 이게 <strong>넌클러스터 인덱스</strong>이다.</p><h3 id="클러스터-인덱스"><a href="#클러스터-인덱스" class="headerlink" title="클러스터 인덱스"></a>클러스터 인덱스</h3><ul><li>테이블 당 1개만 허용</li><li>기본 키 설정시 자동으로 만들어짐</li><li>테이블 자체가 인덱스 (클러스터 인덱스를 기준으로 테이블을 정렬하기 때문에 인덱스 페이지가 없다)</li><li>데이터 입력, 수정, 삭제 시 항상 정렬을 유지함</li><li>기본적으로 접근 성능이 좋음</li></ul><h3 id="넌클러스터-인덱스"><a href="#넌클러스터-인덱스" class="headerlink" title="넌클러스터 인덱스"></a>넌클러스터 인덱스</h3><ul><li>테이블 당 최대 240개 생성 가능</li><li>인덱스 페이지를 별도로 저장</li><li>테이블 자체는 정렬되지 않고, 인덱스 페이지에만 정렬</li><li>성능 증가는 정말 “Case By Case”</li></ul><p>부가적으로 설명하자면, <strong>클러스터 인덱스</strong>는 항상 정렬을 유지하기 때문에 기본적으로 성능이 보장된다. AUTO_INCREMENT 같은 id에 클러스터 인덱스가 있어도 조회 성능이 향상된다. 하지만 테이블을 정렬 상태로 유지해야하므로 데이터를 입력, 수정, 삭제하는 경우에 즉각 정렬이 일어나기 때문에 느려진다. Trade Off라고 생각하면 된다. 따라서 DML 작업이 자주 일어나는 테이블에 클러스터 인덱스는 정말 신중하게 결정해야 한다.</p><p><strong>넌클러스터 인덱스</strong>는 DML 작업이 일어나도 괜찮다. 별도의 인덱스 페이지가 있기 때문에 테이블 전체를 정렬하는 것보다 훨씬 낫다. 하지만 어디에 넌클러스터 인덱스를 걸어야 할 지는 정말 신중해야 한다. 바보같이 걸면 성능도 바보가 된다. 인덱스가 없는 것보다 느려질 수도 있다.</p><h2 id="활용"><a href="#활용" class="headerlink" title="활용"></a>활용</h2><h3 id="클러스터-인덱스-1"><a href="#클러스터-인덱스-1" class="headerlink" title="클러스터 인덱스"></a>클러스터 인덱스</h3><p>쿼리를 기준으로 예를 들면,</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>(hire_date), <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> hire_date &gt;= <span class="string">&#x27;1997-01-01&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">year</span>(hire_date); </span><br></pre></td></tr></table></figure><p>조건절에 <code>hire_date</code>가 있고, 범위 탐색이다. 이 경우 <code>hire_date</code>에 클러스터 인덱스를 보여하면 성능이 엄청나게 향상된다. 여기서 WHERE 절만 빼보자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>(hire_date), <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">year</span>(hire_date); </span><br></pre></td></tr></table></figure><p>여기서 마찬가지로 <code>hire_date</code>에 클러스터 인덱스를 건다면? 성능 향상에 도움이 안되거나, 데이터가 많아지는 경우 오히려 느려진다. 스캔 방식을 생각해야 한다. 클러스터 인덱스가 없는 경우 기본적으로 Heap 테이블 스캔이 이루어진다. 클러스터 인덱스가 있는 경우에는 클러스터 인덱스 스캔이 이루어진다. 하지만 조건절이 없으므로 무식하게 다 읽는건 Heap 테이블 스캔이 빠르다.</p><h3 id="넌클러스터-인덱스-1"><a href="#넌클러스터-인덱스-1" class="headerlink" title="넌클러스터 인덱스"></a>넌클러스터 인덱스</h3><p>위의 예시와 같은 쿼리이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>(hire_date), <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> hire_date &gt;= <span class="string">&#x27;1997-01-01&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">year</span>(hire_date); </span><br></pre></td></tr></table></figure><p>여기서 <code>hire_date</code>에 넌클러스터 인덱스를 건다면? 놀랍게도 클러스터 인덱스를 걸었을 때보다 더 빠르다. 이 경우 때문에 구글링을 2시간은 한 것 같다. 내가 내린 결론은, 넌클러스터 인덱스가 탐색 범위에 포함되었기 때문에 옵티마이저에서는 인덱스 스캔이 아닌 <strong>Non-Clustered Index Seek</strong> 방식을 선택한다. Index Scan은 인덱스의 모든 행을 인덱스 순서로 읽는 반면에, Index Seek은 필터 기준에 따라 일치하는 행이나 한정된 행만 찾으려고 리프 노드를 거치기 때문에 논리적 읽기 수가 훨씬 감소한다.(고 한다)</p><p>하지만 포인트 쿼리인지 범위 쿼리인지, 범위 쿼리라면 조건절의 탐색 범위는 얼마나인지에 따라서 경우가 달라진다. 결국 실무에서 클러스터링 최적화를 위해서는 테스트를 거친 후 적용해야 하고, 클러스터 인덱스를 걸 때는 인덱스를 거는 행동만으로 데이터 정렬에 비용이 소요되므로 신중하게 결정해야 한다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;학과 공부와 시험을 준비하다가 클러스터 인덱스와 넌클러스터 인덱스를 정리해 본다.&lt;/p&gt;
&lt;h2 id=&quot;개념&quot;&gt;&lt;a href=&quot;#개념&quot; class=&quot;headerlink&quot; title=&quot;개념&quot;&gt;&lt;/a&gt;개념&lt;/h2&gt;&lt;p&gt;영어 사전을 생각해보자. 기본적</summary>
      
    
    
    
    <category term="database" scheme="https://zinirun.github.io/categories/database/"/>
    
    
    <category term="database" scheme="https://zinirun.github.io/tags/database/"/>
    
    <category term="index" scheme="https://zinirun.github.io/tags/index/"/>
    
    <category term="clustered index" scheme="https://zinirun.github.io/tags/clustered-index/"/>
    
    <category term="nonclustered index" scheme="https://zinirun.github.io/tags/nonclustered-index/"/>
    
    <category term="sql" scheme="https://zinirun.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>Node.js - 좀 더 바람직하게 Express 서버 여는 법</title>
    <link href="https://zinirun.github.io/2020/10/16/node-better-express-app/"/>
    <id>https://zinirun.github.io/2020/10/16/node-better-express-app/</id>
    <published>2020-10-16T14:24:09.000Z</published>
    <updated>2020-10-16T15:07:00.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="바람직한-코드"><a href="#바람직한-코드" class="headerlink" title="바람직한 코드"></a>바람직한 코드</h2><p>이전부터 Node.js로 작고 큰 프로젝트들을 해왔지만 뚜렷한 코드 작성의 방향없이 생각나는 대로 집어 쓰는 경우가 많았다. “되기만 하면 된다”는 생각을 버려야 한다. 난 요즘 코드를 작성할 때 내가 만든 프로그램이 오픈소스가 되었을 때 사람들에게 당당하게 보여줄 수 있는 코드를 쓰려 노력하고 있다.</p><p>노드로 서버를 구축하면 항상 쓰는 Express 작성 방식부터가 엉망이었다. 처음에 책에서 하란 대로 하는데 되니까 그저 서버가 돌아가는 것에 만족하고 사용해왔다가, 여러 강의와 오픈 소스들을 살펴보니 Express 서버(app) 자체를 Class화하여 효율적으로 관리할 수 있는 방법이 있었다.</p><h2 id="이전의-주먹구구식-Express"><a href="#이전의-주먹구구식-Express" class="headerlink" title="이전의 주먹구구식 Express"></a>이전의 주먹구구식 Express</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>).createServer(app);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>),</span><br><span class="line">  bodyParser = <span class="built_in">require</span>(<span class="string">&quot;body-parser&quot;</span>),</span><br><span class="line">  cookieParser = <span class="built_in">require</span>(<span class="string">&quot;cookie-parser&quot;</span>),</span><br><span class="line">  <span class="keyword">static</span> = <span class="built_in">require</span>(<span class="string">&quot;serve-static&quot;</span>),</span><br><span class="line">  errorHandler = <span class="built_in">require</span>(<span class="string">&quot;errorhandler&quot;</span>),</span><br><span class="line">  expressErrorHandler = <span class="built_in">require</span>(<span class="string">&quot;express-error-handler&quot;</span>),</span><br><span class="line">  expressSession = <span class="built_in">require</span>(<span class="string">&quot;express-session&quot;</span>),</span><br><span class="line">  ejs = <span class="built_in">require</span>(<span class="string">&quot;ejs&quot;</span>),</span><br><span class="line">  fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>),</span><br><span class="line">  url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>),</span><br><span class="line">  cors = <span class="built_in">require</span>(<span class="string">&quot;cors&quot;</span>);</span><br><span class="line"></span><br><span class="line">app.set(<span class="string">&quot;port&quot;</span>, process.env.PORT || <span class="number">3000</span>);</span><br><span class="line">app.use(express.json());</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(</span><br><span class="line">  bodyParser.urlencoded(&#123;</span><br><span class="line">    extended: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line">app.use(<span class="string">&quot;/public&quot;</span>, express.static(__dirname + <span class="string">&quot;/public&quot;</span>));</span><br><span class="line">app.use(cookieParser());</span><br><span class="line">app.use(</span><br><span class="line">  expressSession(&#123;</span><br><span class="line">    secret: <span class="string">&quot;my key&quot;</span>,</span><br><span class="line">    resave: <span class="literal">true</span>,</span><br><span class="line">    saveUninitialized: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line">app.use(cors());</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 404 에러 페이지 처리</span></span><br><span class="line"><span class="keyword">var</span> errorHandler = expressErrorHandler(&#123;</span><br><span class="line">  <span class="keyword">static</span>: &#123;</span><br><span class="line">    <span class="number">404</span>: <span class="string">&quot;./public/404.html&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(expressErrorHandler.httpError(<span class="number">404</span>));</span><br><span class="line">app.use(errorHandler);</span><br><span class="line"></span><br><span class="line">http.listen(app.get(<span class="string">&quot;port&quot;</span>), <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;server started - port: &quot;</span> + app.get(<span class="string">&quot;port&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>가관이지만, 사실 이 형편없는 코드만으로도 서버는 정상적으로 돌아간다. 하지만 내가 노드를 쓰는 사람을 뽑는 채용 담당자라면 미들웨어가 이렇게 엉켜있고 재선언할 리 없는 변수나 라이브러리를 <code>var</code>로 남발하는 등의 엉성한 코드를 쓰는 사람에게 프로젝트를 믿고 맡길 수는 없을 것 같다.</p><h2 id="보다-나은-Express"><a href="#보다-나은-Express" class="headerlink" title="보다 나은 Express"></a>보다 나은 Express</h2><p>먼저 <code>app.js</code>를 <code>server.js</code>, <code>app.js</code>로 분할한다. (이름은 상관없다)</p><p>Express 관련 코드를 <code>app</code>에 담고, 그 <code>app</code>을 <code>http</code>와 <code>https</code>로 오픈할 <code>server</code> 소스로 나누어 작성한다.</p><p>먼저 <code>app.js</code>를 보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&quot;body-parser&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">&quot;cookie-parser&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> expressSession = <span class="built_in">require</span>(<span class="string">&quot;express-session&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&quot;cors&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">&quot;morgan&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.app = express();</span><br><span class="line">    <span class="built_in">this</span>.setViewEngine();</span><br><span class="line">    <span class="built_in">this</span>.setMiddleWare();</span><br><span class="line">    <span class="built_in">this</span>.setStatic();</span><br><span class="line">    <span class="built_in">this</span>.setLocals();</span><br><span class="line">    <span class="built_in">this</span>.getRouting();</span><br><span class="line">    <span class="built_in">this</span>.errorHandler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setMiddleWare() &#123;</span><br><span class="line">    <span class="comment">// HTTP -&gt; HTTPS Redirection</span></span><br><span class="line">    <span class="built_in">this</span>.app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (req.secure) &#123;</span><br><span class="line">        next();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> to = <span class="string">`https://<span class="subst">$&#123;req.hostname&#125;</span><span class="subst">$&#123;req.url&#125;</span>`</span>;</span><br><span class="line">        res.redirect(to);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.app.use(logger(<span class="string">&quot;dev&quot;</span>));</span><br><span class="line">    <span class="built_in">this</span>.app.use(bodyParser.json());</span><br><span class="line">    <span class="built_in">this</span>.app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line">    <span class="built_in">this</span>.app.use(cookieParser());</span><br><span class="line">    <span class="built_in">this</span>.app.use(</span><br><span class="line">      expressSession(&#123;</span><br><span class="line">        secret: <span class="string">&quot;my key&quot;</span>,</span><br><span class="line">        resave: <span class="literal">true</span>,</span><br><span class="line">        saveUninitialized: <span class="literal">true</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">this</span>.app.use(cors());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setViewEngine() &#123;</span><br><span class="line">    <span class="built_in">this</span>.app.set(<span class="string">&quot;view engine&quot;</span>, <span class="string">&quot;ejs&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.app.set(<span class="string">&quot;views&quot;</span>, <span class="string">&quot;./public&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.app.engine(<span class="string">&quot;html&quot;</span>, <span class="built_in">require</span>(<span class="string">&quot;ejs&quot;</span>).renderFile);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setStatic() &#123;</span><br><span class="line">    <span class="built_in">this</span>.app.use(<span class="string">&quot;/public&quot;</span>, express.static(__dirname + <span class="string">&quot;/public&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setLocals() &#123;</span><br><span class="line">    <span class="built_in">this</span>.app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.app.locals.isLogin = <span class="literal">true</span>;</span><br><span class="line">      next();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getRouting() &#123;</span><br><span class="line">    <span class="built_in">this</span>.app.use(<span class="built_in">require</span>(<span class="string">&quot;./controllers&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  errorHandler() &#123;</span><br><span class="line">    <span class="built_in">this</span>.app.use(<span class="function">(<span class="params">req, res, _</span>) =&gt;</span> &#123;</span><br><span class="line">      res.status(<span class="number">404</span>).render(<span class="string">&quot;404.html&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.app.use(<span class="function">(<span class="params">err, req, res, _</span>) =&gt;</span> &#123;</span><br><span class="line">      res.status(<span class="number">500</span>).render(<span class="string">&quot;500.html&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> App().app;</span><br></pre></td></tr></table></figure><p>코드만 봐도 Express에서 미들웨어를 설정하는지, 뷰엔진을 설정하는지, 라우터를 설정하는지, 에러핸들링을 하는지 알 수 있다. 만약에 미들웨어를 추가할 일이 생겼다면 <code>setMiddleware()</code>를 보고 여기가 미들웨어 넣는 자리구나하고 넣으면 된다.</p><p>이 Express app을 Class로 관리하면 또 다른 장점이 있는데, 서버 앱을 하나의 인스턴스로 관리할 수 있다. 비동기식 실행과 스레딩의 장점으로 노드를 CDN 서버 등으로 많이 활용하는데 접속된 인스턴스가 몇 개인지 관리하거나 접속 인스턴스의 갯수 제한을 두는 등의 작업을 편하게 할 수 있다.</p><p>이제 이 app을 기반으로 서버를 열면 된다. <code>server.js</code>를 보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">&quot;./app.js&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">&quot;https&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> options = <span class="built_in">require</span>(<span class="string">&quot;./config/pem_config&quot;</span>).options;</span><br><span class="line"><span class="keyword">const</span> httpPort = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">const</span> httpsPort = <span class="number">443</span>;</span><br><span class="line"></span><br><span class="line">https.createServer(options, app).listen(httpsPort, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`HTTPS: Express listening on port <span class="subst">$&#123;httpsPort&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(httpPort, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`HTTP: Express listening on port <span class="subst">$&#123;httpPort&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>작성해놓은 app을 불러와서 <code>http</code>와 <code>https</code> 모두로 열어주면 된다. 당연히 <code>https</code>는 발급한 SSL 인증서 정보를 같이 넣어주어야 한다. SSL 인증서로 https 서버를 구축하는 방법은 <a href="https://zinirun.github.io/2020/10/07/nodejs-https-server/">여기</a>에 포스팅해두었다. 학습용으로 만드는 토이 프로젝트가 아닌 이상 배포시에는 https를 당연히 지원해야 한다. 그래서 위에 <code>app.js</code>에는 http 접속을 https로 리다이렉트하는 미들웨어가 작성되어 있다.</p><p>이 방법이 완벽한 방법은 아닐 수 있다. 분명 더 세세하게 분리되어 있거나, 다른 좋은 방법으로 express 서버를 관리하는 방법도 많을 것이다. 중요한 것은 질 나쁜 코드를 작성하는 것을 끊임없이 지양하는 것에 있다고 생각한다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;바람직한-코드&quot;&gt;&lt;a href=&quot;#바람직한-코드&quot; class=&quot;headerlink&quot; title=&quot;바람직한 코드&quot;&gt;&lt;/a&gt;바람직한 코드&lt;/h2&gt;&lt;p&gt;이전부터 Node.js로 작고 큰 프로젝트들을 해왔지만 뚜렷한 코드 작성의 방향없이 생각나</summary>
      
    
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/categories/nodejs/"/>
    
    
    <category term="nodejs" scheme="https://zinirun.github.io/tags/nodejs/"/>
    
    <category term="express" scheme="https://zinirun.github.io/tags/express/"/>
    
    <category term="https" scheme="https://zinirun.github.io/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>SQLD 38회 결과 (국가공인 SQL 개발자 자격증)</title>
    <link href="https://zinirun.github.io/2020/10/12/sqld-38-result/"/>
    <id>https://zinirun.github.io/2020/10/12/sqld-38-result/</id>
    <published>2020-10-12T00:08:42.000Z</published>
    <updated>2020-10-12T00:15:59.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="합격"><a href="#합격" class="headerlink" title="합격"></a>합격</h2><p><img src="/images/2020-10-12-09-10-48.png"></p><p>SQLD 사이트가 결과 발표 날에 마비되어 뒤늦게 확인했다. 결과는 합격! 순공시간 하루 정도에 좋은 결과를 얻었다. 자격증보다 프로젝트 하나가 낫다고 생각하지만 공부하는 머리도 돌릴겸 재미로 자격증 하나씩 따는건 재미있다. 오라클 자격증도 따보고 싶은데 터무니없이 비싸기도 하고 그 시간에 하둡이나 카프카를 공부해보고 싶기도 하다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;합격&quot;&gt;&lt;a href=&quot;#합격&quot; class=&quot;headerlink&quot; title=&quot;합격&quot;&gt;&lt;/a&gt;합격&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/2020-10-12-09-10-48.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;SQLD 사이트가 결과 발표 날에 </summary>
      
    
    
    
    <category term="Etc" scheme="https://zinirun.github.io/categories/Etc/"/>
    
    
    <category term="sqld" scheme="https://zinirun.github.io/tags/sqld/"/>
    
  </entry>
  
</feed>
